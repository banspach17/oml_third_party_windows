; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3BitsetNew
PUBLIC	antlr3BitsetOf
PUBLIC	antlr3BitsetList
PUBLIC	antlr3BitsetCopy
PUBLIC	antlr3BitsetLoad
PUBLIC	antlr3BitsetSetAPI
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3EnumNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetNew DD imagerel $LN6
	DD	imagerel $LN6+202
	DD	imagerel $unwind$antlr3BitsetNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetOf DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$antlr3BitsetOf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetList DD imagerel $LN5
	DD	imagerel $LN5+149
	DD	imagerel $unwind$antlr3BitsetList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetCopy DD imagerel $LN6
	DD	imagerel $LN6+196
	DD	imagerel $unwind$antlr3BitsetCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetLoad DD imagerel $LN8
	DD	imagerel $LN8+174
	DD	imagerel $unwind$antlr3BitsetLoad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetSetAPI DD imagerel $LN3
	DD	imagerel $LN3+216
	DD	imagerel $unwind$antlr3BitsetSetAPI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetClone DD imagerel antlr3BitsetClone
	DD	imagerel antlr3BitsetClone+110
	DD	imagerel $unwind$antlr3BitsetClone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetOR DD imagerel antlr3BitsetOR
	DD	imagerel antlr3BitsetOR+116
	DD	imagerel $unwind$antlr3BitsetOR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetORInPlace DD imagerel antlr3BitsetORInPlace
	DD	imagerel antlr3BitsetORInPlace+232
	DD	imagerel $unwind$antlr3BitsetORInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetSize DD imagerel antlr3BitsetSize
	DD	imagerel antlr3BitsetSize+199
	DD	imagerel $unwind$antlr3BitsetSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetAdd DD imagerel antlr3BitsetAdd
	DD	imagerel antlr3BitsetAdd+148
	DD	imagerel $unwind$antlr3BitsetAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetEquals DD imagerel antlr3BitsetEquals
	DD	imagerel antlr3BitsetEquals+327
	DD	imagerel $unwind$antlr3BitsetEquals
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetMember DD imagerel antlr3BitsetMember
	DD	imagerel antlr3BitsetMember+135
	DD	imagerel $unwind$antlr3BitsetMember
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetNumBits DD imagerel antlr3BitsetNumBits
	DD	imagerel antlr3BitsetNumBits+19
	DD	imagerel $unwind$antlr3BitsetNumBits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetRemove DD imagerel antlr3BitsetRemove
	DD	imagerel antlr3BitsetRemove+137
	DD	imagerel $unwind$antlr3BitsetRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetIsNil DD imagerel antlr3BitsetIsNil
	DD	imagerel antlr3BitsetIsNil+92
	DD	imagerel $unwind$antlr3BitsetIsNil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetToIntList DD imagerel antlr3BitsetToIntList
	DD	imagerel antlr3BitsetToIntList+223
	DD	imagerel $unwind$antlr3BitsetToIntList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$growToInclude DD imagerel growToInclude
	DD	imagerel growToInclude+113
	DD	imagerel $unwind$growToInclude
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grow DD	imagerel grow
	DD	imagerel grow+151
	DD	imagerel $unwind$grow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bitMask DD imagerel bitMask
	DD	imagerel bitMask+60
	DD	imagerel $unwind$bitMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$numWordsToHold DD imagerel numWordsToHold
	DD	imagerel numWordsToHold+16
	DD	imagerel $unwind$numWordsToHold
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wordNumber DD imagerel wordNumber
	DD	imagerel wordNumber+14
	DD	imagerel $unwind$wordNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetFree DD imagerel antlr3BitsetFree
	DD	imagerel antlr3BitsetFree+84
	DD	imagerel $unwind$antlr3BitsetFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wordNumber DD 010501H
	DD	07005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$numWordsToHold DD 010501H
	DD	07005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bitMask DD 021c01H
	DD	070051209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grow DD	022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$growToInclude DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetToIntList DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetIsNil DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetRemove DD 022201H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetNumBits DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetMember DD 022201H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetEquals DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetAdd DD 022201H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetSize DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetORInPlace DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetOR DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetClone DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetSetAPI DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetLoad DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetCopy DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetList DD 022101H
	DD	07006d20aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3BitsetList$rtcName$0 DB 06bH
	DB	065H
	DB	079H
	DB	00H
antlr3BitsetList$rtcName$1 DB 062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+8
antlr3BitsetList$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:antlr3BitsetList$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:antlr3BitsetList$rtcName$0
	ORG $+96
antlr3BitsetList$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:antlr3BitsetList$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetOf DD 022b01H
	DD	070149218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3BitsetOf$rtcName$0 DB 061H
	DB	070H
	DB	00H
	ORG $+13
antlr3BitsetOf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:antlr3BitsetOf$rtcName$0
	ORG $+48
antlr3BitsetOf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:antlr3BitsetOf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetNew DD 021c01H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetFree
_TEXT	SEGMENT
bitset$ = 48
antlr3BitsetFree PROC					; COMDAT

; 64   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 65   :     if	(bitset->blist.bits != NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  00023	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00027	74 1a		 je	 SHORT $LN2@antlr3Bits

; 66   :     {
; 67   : 		ANTLR3_FREE(bitset->blist.bits);

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  0002e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 68   : 		bitset->blist.bits = NULL;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  0003c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@antlr3Bits:

; 69   :     }
; 70   :     ANTLR3_FREE(bitset);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 71   : 
; 72   :     return;
; 73   : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
antlr3BitsetFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT wordNumber
_TEXT	SEGMENT
bit$ = 16
wordNumber PROC						; COMDAT

; 628  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi

; 629  :     return  bit >> ANTLR3_BITSET_LOG_BITS;

  00005	8b 44 24 10	 mov	 eax, DWORD PTR bit$[rsp]
  00009	c1 e8 06	 shr	 eax, 6

; 630  : }

  0000c	5f		 pop	 rdi
  0000d	c3		 ret	 0
wordNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT numWordsToHold
_TEXT	SEGMENT
bit$ = 16
numWordsToHold PROC					; COMDAT

; 622  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi

; 623  :     return  (bit >> ANTLR3_BITSET_LOG_BITS) + 1;

  00005	8b 44 24 10	 mov	 eax, DWORD PTR bit$[rsp]
  00009	c1 e8 06	 shr	 eax, 6
  0000c	ff c0		 inc	 eax

; 624  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
numWordsToHold ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT bitMask
_TEXT	SEGMENT
tv69 = 0
bitNumber$ = 32
bitMask	PROC						; COMDAT

; 478  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 10	 sub	 rsp, 16
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 04 00 00 00	 mov	 ecx, 4
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 20	 mov	 ecx, DWORD PTR [rsp+32]

; 479  :     return  ((ANTLR3_UINT64)1) << (bitNumber & (ANTLR3_BITSET_MOD_MASK));

  0001c	8b 44 24 20	 mov	 eax, DWORD PTR bitNumber$[rsp]
  00020	83 e0 3f	 and	 eax, 63			; 0000003fH
  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	48 89 0c 24	 mov	 QWORD PTR tv69[rsp], rcx
  0002c	0f b6 c8	 movzx	 ecx, al
  0002f	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]
  00033	48 d3 e0	 shl	 rax, cl

; 480  : }

  00036	48 83 c4 10	 add	 rsp, 16
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
bitMask	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT grow
_TEXT	SEGMENT
newBits$ = 32
bitset$ = 64
newSize$ = 72
grow	PROC						; COMDAT

; 396  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 397  :     pANTLR3_BITWORD   newBits;
; 398  : 
; 399  :     // Space for newly sized bitset - TODO: come back to this and use realloc?, it may
; 400  :     // be more efficient...
; 401  :     //
; 402  :     newBits = (pANTLR3_BITWORD) ANTLR3_CALLOC(1, (size_t)(newSize * sizeof(ANTLR3_BITWORD)));

  00022	48 63 44 24 48	 movsxd	 rax, DWORD PTR newSize$[rsp]
  00027	48 c1 e0 03	 shl	 rax, 3
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	b9 01 00 00 00	 mov	 ecx, 1
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00039	48 89 44 24 20	 mov	 QWORD PTR newBits$[rsp], rax

; 403  :     if	(bitset->blist.bits != NULL)

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00043	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00047	74 2f		 je	 SHORT $LN2@grow

; 404  :     {
; 405  : 		// Copy existing bits
; 406  : 		//
; 407  : 		ANTLR3_MEMCPY((void *)newBits, (const void *)bitset->blist.bits, (size_t)(bitset->blist.length * sizeof(ANTLR3_BITWORD)));

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0004e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00051	48 c1 e0 03	 shl	 rax, 3
  00055	4c 8b c0	 mov	 r8, rax
  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0005d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newBits$[rsp]
  00065	e8 00 00 00 00	 call	 memcpy

; 408  : 
; 409  : 		// Out with the old bits... de de de derrr
; 410  : 		//
; 411  : 		ANTLR3_FREE(bitset->blist.bits);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@grow:

; 412  :     }
; 413  : 
; 414  :     // In with the new bits... keerrrang.
; 415  :     //
; 416  :     bitset->blist.bits      = newBits;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newBits$[rsp]
  00082	48 89 08	 mov	 QWORD PTR [rax], rcx

; 417  :     bitset->blist.length    = newSize;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0008a	8b 4c 24 48	 mov	 ecx, DWORD PTR newSize$[rsp]
  0008e	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 418  : }

  00091	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
grow	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT growToInclude
_TEXT	SEGMENT
bl$ = 32
nw$ = 36
bitset$ = 64
bit$ = 72
growToInclude PROC					; COMDAT

; 422  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 423  : 	ANTLR3_UINT32	bl;
; 424  : 	ANTLR3_UINT32	nw;
; 425  : 
; 426  : 	bl = (bitset->blist.length << 1);

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00027	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002a	d1 e0		 shl	 eax, 1
  0002c	89 44 24 20	 mov	 DWORD PTR bl$[rsp], eax

; 427  : 	nw = numWordsToHold(bit);

  00030	8b 4c 24 48	 mov	 ecx, DWORD PTR bit$[rsp]
  00034	e8 00 00 00 00	 call	 numWordsToHold
  00039	89 44 24 24	 mov	 DWORD PTR nw$[rsp], eax

; 428  : 
; 429  : 	if	(bl > nw)

  0003d	8b 44 24 24	 mov	 eax, DWORD PTR nw$[rsp]
  00041	39 44 24 20	 cmp	 DWORD PTR bl$[rsp], eax
  00045	76 13		 jbe	 SHORT $LN2@growToIncl

; 430  : 	{
; 431  : 		bitset->grow(bitset, bl);

  00047	8b 54 24 20	 mov	 edx, DWORD PTR bl$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00055	ff 50 38	 call	 QWORD PTR [rax+56]

; 432  : 	}

  00058	eb 11		 jmp	 SHORT $LN3@growToIncl
$LN2@growToIncl:

; 433  : 	else
; 434  : 	{
; 435  : 		bitset->grow(bitset, nw);

  0005a	8b 54 24 24	 mov	 edx, DWORD PTR nw$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00068	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@growToIncl:

; 436  : 	}
; 437  : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
growToInclude ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetToIntList
_TEXT	SEGMENT
numInts$ = 32
numBits$ = 36
i$ = 40
index$ = 44
intList$ = 48
bitset$ = 80
antlr3BitsetToIntList PROC				; COMDAT

; 647  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 648  :     ANTLR3_UINT32   numInts;	    // How many integers we will need
; 649  :     ANTLR3_UINT32   numBits;	    // How many bits are in the set
; 650  :     ANTLR3_UINT32   i;
; 651  :     ANTLR3_UINT32   index;
; 652  : 
; 653  :     pANTLR3_INT32  intList;
; 654  : 
; 655  :     numInts = bitset->size(bitset) + 1;

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00028	ff 50 28	 call	 QWORD PTR [rax+40]
  0002b	ff c0		 inc	 eax
  0002d	89 44 24 20	 mov	 DWORD PTR numInts$[rsp], eax

; 656  :     numBits = bitset->numBits(bitset);

  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  0003b	ff 50 50	 call	 QWORD PTR [rax+80]
  0003e	89 44 24 24	 mov	 DWORD PTR numBits$[rsp], eax

; 657  :  
; 658  :     intList = (pANTLR3_INT32)ANTLR3_MALLOC(numInts * sizeof(ANTLR3_INT32));

  00042	8b 44 24 20	 mov	 eax, DWORD PTR numInts$[rsp]
  00046	48 c1 e0 02	 shl	 rax, 2
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00053	48 89 44 24 30	 mov	 QWORD PTR intList$[rsp], rax

; 659  : 
; 660  :     if	(intList == NULL)

  00058	48 83 7c 24 30
	00		 cmp	 QWORD PTR intList$[rsp], 0
  0005e	75 04		 jne	 SHORT $LN5@antlr3Bits

; 661  :     {
; 662  : 		return NULL;	// Out of memory

  00060	33 c0		 xor	 eax, eax
  00062	eb 75		 jmp	 SHORT $LN1@antlr3Bits
$LN5@antlr3Bits:

; 663  :     }
; 664  : 
; 665  :     intList[0] = numInts;

  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	48 6b c0 00	 imul	 rax, rax, 0
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intList$[rsp]
  00072	8b 54 24 20	 mov	 edx, DWORD PTR numInts$[rsp]
  00076	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 666  : 
; 667  :     // Enumerate the bits that are turned on
; 668  :     //
; 669  :     for	(i = 0, index = 1; i<numBits; i++)

  00079	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00081	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR index$[rsp], 1
  00089	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  0008b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00095	8b 44 24 24	 mov	 eax, DWORD PTR numBits$[rsp]
  00099	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0009d	73 35		 jae	 SHORT $LN3@antlr3Bits

; 670  :     {
; 671  : 		if  (bitset->isMember(bitset, i) == ANTLR3_TRUE)

  0009f	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  000ad	ff 50 48	 call	 QWORD PTR [rax+72]
  000b0	0f b6 c0	 movzx	 eax, al
  000b3	83 f8 01	 cmp	 eax, 1
  000b6	75 1a		 jne	 SHORT $LN6@antlr3Bits

; 672  : 		{
; 673  : 			intList[index++]    = i;

  000b8	8b 44 24 2c	 mov	 eax, DWORD PTR index$[rsp]
  000bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intList$[rsp]
  000c1	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  000c5	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  000c8	8b 44 24 2c	 mov	 eax, DWORD PTR index$[rsp]
  000cc	ff c0		 inc	 eax
  000ce	89 44 24 2c	 mov	 DWORD PTR index$[rsp], eax
$LN6@antlr3Bits:

; 674  : 		}
; 675  :     }

  000d2	eb b7		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 676  : 
; 677  :     // Result set
; 678  :     //
; 679  :     return  intList;

  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR intList$[rsp]
$LN1@antlr3Bits:

; 680  : }

  000d9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
antlr3BitsetToIntList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetIsNil
_TEXT	SEGMENT
i$ = 0
bitset$ = 32
antlr3BitsetIsNil PROC					; COMDAT

; 606  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 607  :    ANTLR3_INT32    i;
; 608  : 
; 609  :    for	(i = bitset->blist.length -1; i>= 0; i--)

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0002b	eb 08		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c8		 dec	 eax
  00032	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00035	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00039	7c 19		 jl	 SHORT $LN3@antlr3Bits

; 610  :    {
; 611  :        if   (bitset->blist.bits[i] != 0)

  0003b	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00044	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00047	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0004c	74 04		 je	 SHORT $LN5@antlr3Bits

; 612  :        {
; 613  : 			return ANTLR3_FALSE;

  0004e	32 c0		 xor	 al, al
  00050	eb 04		 jmp	 SHORT $LN1@antlr3Bits
$LN5@antlr3Bits:

; 614  :        }
; 615  :    }

  00052	eb d9		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 616  :    
; 617  :    return   ANTLR3_TRUE;

  00054	b0 01		 mov	 al, 1
$LN1@antlr3Bits:

; 618  : }

  00056	48 83 c4 10	 add	 rsp, 16
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
antlr3BitsetIsNil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetRemove
_TEXT	SEGMENT
wordNo$ = 32
tv69 = 40
tv81 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetRemove PROC					; COMDAT

; 594  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 595  :     ANTLR3_UINT32    wordNo;
; 596  : 
; 597  :     wordNo  = wordNumber(bit);

  00022	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00026	e8 00 00 00 00	 call	 wordNumber
  0002b	89 44 24 20	 mov	 DWORD PTR wordNo$[rsp], eax

; 598  : 
; 599  :     if	(wordNo < bitset->blist.length)

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00037	39 44 24 20	 cmp	 DWORD PTR wordNo$[rsp], eax
  0003b	73 46		 jae	 SHORT $LN2@antlr3Bits

; 600  :     {
; 601  : 		bitset->blist.bits[wordNo] &= ~(bitMask(bit));

  0003d	8b 44 24 20	 mov	 eax, DWORD PTR wordNo$[rsp]
  00041	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  0004b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004e	48 89 4c 24 30	 mov	 QWORD PTR tv81[rsp], rcx
  00053	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00057	e8 00 00 00 00	 call	 bitMask
  0005c	48 f7 d0	 not	 rax
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00064	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv69[rsp]
  00069	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0006d	48 23 c8	 and	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	8b 4c 24 20	 mov	 ecx, DWORD PTR wordNo$[rsp]
  00077	48 8b 54 24 50	 mov	 rdx, QWORD PTR bitset$[rsp]
  0007c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0007f	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN2@antlr3Bits:

; 602  :     }
; 603  : }

  00083	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
antlr3BitsetRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetNumBits
_TEXT	SEGMENT
bitset$ = 16
antlr3BitsetNumBits PROC				; COMDAT

; 634  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 635  :     return  bitset->blist.length << ANTLR3_BITSET_LOG_BITS;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000e	c1 e0 06	 shl	 eax, 6

; 636  : }

  00011	5f		 pop	 rdi
  00012	c3		 ret	 0
antlr3BitsetNumBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetMember
_TEXT	SEGMENT
wordNo$ = 32
tv69 = 40
tv76 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetMember PROC					; COMDAT

; 572  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 573  :     ANTLR3_UINT32    wordNo;
; 574  : 
; 575  :     wordNo  = wordNumber(bit);

  00022	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00026	e8 00 00 00 00	 call	 wordNumber
  0002b	89 44 24 20	 mov	 DWORD PTR wordNo$[rsp], eax

; 576  : 
; 577  :     if	(wordNo >= bitset->blist.length)

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00037	39 44 24 20	 cmp	 DWORD PTR wordNo$[rsp], eax
  0003b	72 04		 jb	 SHORT $LN2@antlr3Bits

; 578  :     {
; 579  : 		return	ANTLR3_FALSE;

  0003d	32 c0		 xor	 al, al
  0003f	eb 40		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 580  :     }
; 581  :     
; 582  :     if	((bitset->blist.bits[wordNo] & bitMask(bit)) == 0)

  00041	8b 44 24 20	 mov	 eax, DWORD PTR wordNo$[rsp]
  00045	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  0004f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00052	48 89 4c 24 30	 mov	 QWORD PTR tv76[rsp], rcx
  00057	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  0005b	e8 00 00 00 00	 call	 bitMask
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv76[rsp]
  00065	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv69[rsp]
  0006a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0006e	48 23 c8	 and	 rcx, rax
  00071	48 8b c1	 mov	 rax, rcx
  00074	48 85 c0	 test	 rax, rax
  00077	75 06		 jne	 SHORT $LN3@antlr3Bits

; 583  :     {
; 584  : 		return	ANTLR3_FALSE;

  00079	32 c0		 xor	 al, al
  0007b	eb 04		 jmp	 SHORT $LN1@antlr3Bits

; 585  :     }

  0007d	eb 02		 jmp	 SHORT $LN4@antlr3Bits
$LN3@antlr3Bits:

; 586  :     else
; 587  :     {
; 588  : 		return	ANTLR3_TRUE;

  0007f	b0 01		 mov	 al, 1
$LN4@antlr3Bits:
$LN1@antlr3Bits:

; 589  :     }
; 590  : }

  00081	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
antlr3BitsetMember ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetEquals
_TEXT	SEGMENT
minimum$ = 0
i$ = 4
bitset1$ = 32
bitset2$ = 40
antlr3BitsetEquals PROC					; COMDAT

; 513  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 514  :     ANTLR3_INT32   minimum;
; 515  :     ANTLR3_INT32   i;
; 516  : 
; 517  :     if	(bitset1 == NULL || bitset2 == NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset1$[rsp], 0
  00029	74 08		 je	 SHORT $LN12@antlr3Bits
  0002b	48 83 7c 24 28
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  00031	75 07		 jne	 SHORT $LN11@antlr3Bits
$LN12@antlr3Bits:

; 518  :     {
; 519  : 	return	ANTLR3_FALSE;

  00033	32 c0		 xor	 al, al
  00035	e9 07 01 00 00	 jmp	 $LN1@antlr3Bits
$LN11@antlr3Bits:

; 520  :     }
; 521  : 
; 522  :     // Work out the minimum comparison set
; 523  :     //
; 524  :     if	(bitset1->blist.length < bitset2->blist.length)

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00044	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00047	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0004a	73 0d		 jae	 SHORT $LN13@antlr3Bits

; 525  :     {
; 526  : 		minimum = bitset1->blist.length;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  00051	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00054	89 04 24	 mov	 DWORD PTR minimum$[rsp], eax

; 527  :     }

  00057	eb 0b		 jmp	 SHORT $LN14@antlr3Bits
$LN13@antlr3Bits:

; 528  :     else
; 529  :     {
; 530  : 		minimum = bitset2->blist.length;

  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  0005e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00061	89 04 24	 mov	 DWORD PTR minimum$[rsp], eax
$LN14@antlr3Bits:

; 531  :     }
; 532  : 
; 533  :     // Make sure explict in common bits are equal
; 534  :     //
; 535  :     for	(i = minimum - 1; i >=0 ; i--)

  00064	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  00067	ff c8		 dec	 eax
  00069	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  0006d	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  0006f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00073	ff c8		 dec	 eax
  00075	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00079	83 7c 24 04 00	 cmp	 DWORD PTR i$[rsp], 0
  0007e	7c 2d		 jl	 SHORT $LN3@antlr3Bits

; 536  :     {
; 537  : 		if  (bitset1->blist.bits[i] != bitset2->blist.bits[i])

  00080	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset1$[rsp]
  0008a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008d	48 63 54 24 04	 movsxd	 rdx, DWORD PTR i$[rsp]
  00092	4c 8b 44 24 28	 mov	 r8, QWORD PTR bitset2$[rsp]
  00097	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0009a	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  0009e	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  000a2	74 07		 je	 SHORT $LN15@antlr3Bits

; 538  : 		{
; 539  : 			return  ANTLR3_FALSE;

  000a4	32 c0		 xor	 al, al
  000a6	e9 96 00 00 00	 jmp	 $LN1@antlr3Bits
$LN15@antlr3Bits:

; 540  : 		}
; 541  :     }

  000ab	eb c2		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 542  : 
; 543  :     // Now make sure the bits of the larger set are all turned
; 544  :     // off.
; 545  :     //
; 546  :     if	(bitset1->blist.length > (ANTLR3_UINT32)minimum)

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  000b2	8b 0c 24	 mov	 ecx, DWORD PTR minimum$[rsp]
  000b5	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  000b8	76 3d		 jbe	 SHORT $LN16@antlr3Bits

; 547  :     {
; 548  : 		for (i = minimum ; (ANTLR3_UINT32)i < bitset1->blist.length; i++)

  000ba	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  000bd	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  000c1	eb 0a		 jmp	 SHORT $LN7@antlr3Bits
$LN5@antlr3Bits:
  000c3	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  000c7	ff c0		 inc	 eax
  000c9	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN7@antlr3Bits:
  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  000d2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000d5	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  000d9	73 1a		 jae	 SHORT $LN6@antlr3Bits

; 549  : 		{
; 550  : 			if	(bitset1->blist.bits[i] != 0)

  000db	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset1$[rsp]
  000e5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e8	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ed	74 04		 je	 SHORT $LN18@antlr3Bits

; 551  : 			{
; 552  : 				return	ANTLR3_FALSE;

  000ef	32 c0		 xor	 al, al
  000f1	eb 4e		 jmp	 SHORT $LN1@antlr3Bits
$LN18@antlr3Bits:

; 553  : 			}
; 554  : 		}

  000f3	eb ce		 jmp	 SHORT $LN5@antlr3Bits
$LN6@antlr3Bits:

; 555  :     }

  000f5	eb 48		 jmp	 SHORT $LN17@antlr3Bits
$LN16@antlr3Bits:

; 556  :     else if (bitset2->blist.length > (ANTLR3_UINT32)minimum)

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  000fc	8b 0c 24	 mov	 ecx, DWORD PTR minimum$[rsp]
  000ff	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00102	76 3b		 jbe	 SHORT $LN19@antlr3Bits

; 557  :     {
; 558  : 		for (i = minimum; (ANTLR3_UINT32)i < bitset2->blist.length; i++)

  00104	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  00107	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  0010b	eb 0a		 jmp	 SHORT $LN10@antlr3Bits
$LN8@antlr3Bits:
  0010d	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00111	ff c0		 inc	 eax
  00113	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN10@antlr3Bits:
  00117	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  0011c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011f	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00123	73 1a		 jae	 SHORT $LN9@antlr3Bits

; 559  : 		{
; 560  : 			if	(bitset2->blist.bits[i] != 0)

  00125	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0012a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bitset2$[rsp]
  0012f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00132	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00137	74 04		 je	 SHORT $LN20@antlr3Bits

; 561  : 			{
; 562  : 				return	ANTLR3_FALSE;

  00139	32 c0		 xor	 al, al
  0013b	eb 04		 jmp	 SHORT $LN1@antlr3Bits
$LN20@antlr3Bits:

; 563  : 			}
; 564  : 		}

  0013d	eb ce		 jmp	 SHORT $LN8@antlr3Bits
$LN9@antlr3Bits:
$LN19@antlr3Bits:
$LN17@antlr3Bits:

; 565  :     }
; 566  : 
; 567  :     return  ANTLR3_TRUE;

  0013f	b0 01		 mov	 al, 1
$LN1@antlr3Bits:

; 568  : }

  00141	48 83 c4 10	 add	 rsp, 16
  00145	5f		 pop	 rdi
  00146	c3		 ret	 0
antlr3BitsetEquals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetAdd
_TEXT	SEGMENT
word$ = 32
tv71 = 40
tv82 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetAdd PROC					; COMDAT

; 380  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 381  :     ANTLR3_UINT32   word;
; 382  : 
; 383  :     word    = wordNumber(bit);

  00022	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00026	e8 00 00 00 00	 call	 wordNumber
  0002b	89 44 24 20	 mov	 DWORD PTR word$[rsp], eax

; 384  : 
; 385  :     if	(word	>= bitset->blist.length)

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00037	39 44 24 20	 cmp	 DWORD PTR word$[rsp], eax
  0003b	72 0e		 jb	 SHORT $LN2@antlr3Bits

; 386  :     {
; 387  : 		growToInclude(bitset, bit);

  0003d	8b 54 24 58	 mov	 edx, DWORD PTR bit$[rsp]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00046	e8 00 00 00 00	 call	 growToInclude
$LN2@antlr3Bits:

; 388  :     }
; 389  : 
; 390  :     bitset->blist.bits[word] |= bitMask(bit);

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR word$[rsp]
  0004f	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00059	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005c	48 89 4c 24 30	 mov	 QWORD PTR tv82[rsp], rcx
  00061	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00065	e8 00 00 00 00	 call	 bitMask
  0006a	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv82[rsp]
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv71[rsp]
  00074	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00078	48 0b c8	 or	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	8b 4c 24 20	 mov	 ecx, DWORD PTR word$[rsp]
  00082	48 8b 54 24 50	 mov	 rdx, QWORD PTR bitset$[rsp]
  00087	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0008a	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 391  : 
; 392  : }

  0008e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
antlr3BitsetAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetSize
_TEXT	SEGMENT
degree$ = 0
i$ = 4
bit$ = 8
tv85 = 16
bitset$ = 48
antlr3BitsetSize PROC					; COMDAT

; 484  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 485  :     ANTLR3_UINT32   degree;
; 486  :     ANTLR3_INT32   i;
; 487  :     ANTLR3_INT8    bit;
; 488  :     
; 489  :     // TODO: Come back to this, it may be faster to & with 0x01
; 490  :     // then shift right a copy of the 4 bits, than shift left a constant of 1.
; 491  :     // But then again, the optimizer might just work this out
; 492  :     // anyway.
; 493  :     //
; 494  :     degree  = 0;

  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR degree$[rsp], 0

; 495  :     for	(i = bitset->blist.length - 1; i>= 0; i--)

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002d	ff c8		 dec	 eax
  0002f	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  00033	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  00035	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00039	ff c8		 dec	 eax
  0003b	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  0003f	83 7c 24 04 00	 cmp	 DWORD PTR i$[rsp], 0
  00044	7c 78		 jl	 SHORT $LN3@antlr3Bits

; 496  :     {
; 497  : 		if  (bitset->blist.bits[i] != 0)

  00046	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  00050	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00053	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00058	74 5f		 je	 SHORT $LN8@antlr3Bits

; 498  : 		{
; 499  : 			for	(bit = ANTLR3_BITSET_BITS - 1; bit >= 0; bit--)

  0005a	c6 44 24 08 3f	 mov	 BYTE PTR bit$[rsp], 63	; 0000003fH
  0005f	eb 0b		 jmp	 SHORT $LN7@antlr3Bits
$LN5@antlr3Bits:
  00061	0f b6 44 24 08	 movzx	 eax, BYTE PTR bit$[rsp]
  00066	fe c8		 dec	 al
  00068	88 44 24 08	 mov	 BYTE PTR bit$[rsp], al
$LN7@antlr3Bits:
  0006c	0f be 44 24 08	 movsx	 eax, BYTE PTR bit$[rsp]
  00071	85 c0		 test	 eax, eax
  00073	7c 44		 jl	 SHORT $LN6@antlr3Bits

; 500  : 			{
; 501  : 				if  ((bitset->blist.bits[i] & (((ANTLR3_BITWORD)1) << bit)) != 0)

  00075	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  0007f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00082	48 89 4c 24 10	 mov	 QWORD PTR tv85[rsp], rcx
  00087	0f be 54 24 08	 movsx	 edx, BYTE PTR bit$[rsp]
  0008c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00092	0f b6 ca	 movzx	 ecx, dl
  00095	41 8b d0	 mov	 edx, r8d
  00098	48 d3 e2	 shl	 rdx, cl
  0009b	48 8b ca	 mov	 rcx, rdx
  0009e	48 8b 54 24 10	 mov	 rdx, QWORD PTR tv85[rsp]
  000a3	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  000a7	48 23 c1	 and	 rax, rcx
  000aa	48 85 c0	 test	 rax, rax
  000ad	74 08		 je	 SHORT $LN9@antlr3Bits

; 502  : 				{
; 503  : 					degree++;

  000af	8b 04 24	 mov	 eax, DWORD PTR degree$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 04 24	 mov	 DWORD PTR degree$[rsp], eax
$LN9@antlr3Bits:

; 504  : 				}
; 505  : 			}

  000b7	eb a8		 jmp	 SHORT $LN5@antlr3Bits
$LN6@antlr3Bits:
$LN8@antlr3Bits:

; 506  : 		}
; 507  :     }

  000b9	e9 77 ff ff ff	 jmp	 $LN2@antlr3Bits
$LN3@antlr3Bits:

; 508  :     return degree;

  000be	8b 04 24	 mov	 eax, DWORD PTR degree$[rsp]

; 509  : }

  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
antlr3BitsetSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetORInPlace
_TEXT	SEGMENT
minimum$ = 32
i$ = 36
bitset$ = 64
bitset2$ = 72
antlr3BitsetORInPlace PROC				; COMDAT

; 441  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 442  :     ANTLR3_UINT32   minimum;
; 443  :     ANTLR3_UINT32   i;
; 444  : 
; 445  :     if	(bitset2 == NULL)

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  00029	75 05		 jne	 SHORT $LN5@antlr3Bits

; 446  :     {
; 447  : 		return;

  0002b	e9 b2 00 00 00	 jmp	 $LN1@antlr3Bits
$LN5@antlr3Bits:

; 448  :     }
; 449  : 
; 450  : 
; 451  :     // First make sure that the target bitset is big enough
; 452  :     // for the new bits to be ored in.
; 453  :     //
; 454  :     if	(bitset->blist.length < bitset2->blist.length)

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  0003a	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0003d	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00040	73 18		 jae	 SHORT $LN6@antlr3Bits

; 455  :     {
; 456  : 		growToInclude(bitset, (bitset2->blist.length * sizeof(ANTLR3_BITWORD)));

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR bitset2$[rsp]
  00047	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004a	48 c1 e0 03	 shl	 rax, 3
  0004e	8b d0		 mov	 edx, eax
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  00055	e8 00 00 00 00	 call	 growToInclude
$LN6@antlr3Bits:

; 457  :     }
; 458  :     
; 459  :     // Or the miniimum number of bits after any resizing went on
; 460  :     //
; 461  :     if	(bitset->blist.length < bitset2->blist.length)

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00064	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00067	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0006a	73 0e		 jae	 SHORT $LN7@antlr3Bits

; 462  : 	{
; 463  : 		minimum = bitset->blist.length;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00071	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00074	89 44 24 20	 mov	 DWORD PTR minimum$[rsp], eax

; 464  : 	}

  00078	eb 0c		 jmp	 SHORT $LN8@antlr3Bits
$LN7@antlr3Bits:

; 465  : 	else
; 466  : 	{
; 467  : 		minimum = bitset2->blist.length;

  0007a	48 8b 44 24 48	 mov	 rax, QWORD PTR bitset2$[rsp]
  0007f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00082	89 44 24 20	 mov	 DWORD PTR minimum$[rsp], eax
$LN8@antlr3Bits:

; 468  : 	}
; 469  : 
; 470  :     for	(i = minimum; i > 0; i--)

  00086	8b 44 24 20	 mov	 eax, DWORD PTR minimum$[rsp]
  0008a	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  0008e	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  00090	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00094	ff c8		 dec	 eax
  00096	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  0009a	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0009f	76 41		 jbe	 SHORT $LN3@antlr3Bits

; 471  :     {
; 472  : 		bitset->blist.bits[i-1] |= bitset2->blist.bits[i-1];

  000a1	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000a5	ff c8		 dec	 eax
  000a7	8b c0		 mov	 eax, eax
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  000ae	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b1	8b 54 24 24	 mov	 edx, DWORD PTR i$[rsp]
  000b5	ff ca		 dec	 edx
  000b7	8b d2		 mov	 edx, edx
  000b9	4c 8b 44 24 48	 mov	 r8, QWORD PTR bitset2$[rsp]
  000be	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000c1	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  000c5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000c9	48 0b c2	 or	 rax, rdx
  000cc	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  000d0	ff c9		 dec	 ecx
  000d2	8b c9		 mov	 ecx, ecx
  000d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR bitset$[rsp]
  000d9	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000dc	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 473  :     }

  000e0	eb ae		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:
$LN1@antlr3Bits:

; 474  : }

  000e2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
antlr3BitsetORInPlace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetOR
_TEXT	SEGMENT
bitset$ = 32
bitset1$ = 64
bitset2$ = 72
antlr3BitsetOR PROC					; COMDAT

; 355  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 356  :     pANTLR3_BITSET  bitset;
; 357  : 
; 358  :     if	(bitset1 == NULL)

  00023	48 83 7c 24 40
	00		 cmp	 QWORD PTR bitset1$[rsp], 0
  00029	75 0c		 jne	 SHORT $LN2@antlr3Bits

; 359  :     {
; 360  : 		return antlr3BitsetClone(bitset2);

  0002b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00030	e8 00 00 00 00	 call	 antlr3BitsetClone
  00035	eb 37		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 361  :     }
; 362  : 
; 363  :     if	(bitset2 == NULL)

  00037	48 83 7c 24 48
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  0003d	75 0c		 jne	 SHORT $LN3@antlr3Bits

; 364  :     {
; 365  : 		return	antlr3BitsetClone(bitset1);

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset1$[rsp]
  00044	e8 00 00 00 00	 call	 antlr3BitsetClone
  00049	eb 23		 jmp	 SHORT $LN1@antlr3Bits
$LN3@antlr3Bits:

; 366  :     }
; 367  : 
; 368  :     // Allocate memory for the newly ordered bitset structure itself.
; 369  :     //
; 370  :     bitset  = antlr3BitsetClone(bitset1);

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset1$[rsp]
  00050	e8 00 00 00 00	 call	 antlr3BitsetClone
  00055	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 371  :     
; 372  :     antlr3BitsetORInPlace(bitset, bitset2);

  0005a	48 8b 54 24 48	 mov	 rdx, QWORD PTR bitset2$[rsp]
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00064	e8 00 00 00 00	 call	 antlr3BitsetORInPlace

; 373  : 
; 374  :     return  bitset;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 375  : 
; 376  : }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
antlr3BitsetOR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetClone
_TEXT	SEGMENT
bitset$ = 32
inSet$ = 64
antlr3BitsetClone PROC					; COMDAT

; 185  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 186  :     pANTLR3_BITSET  bitset;
; 187  : 
; 188  :     // Allocate memory for the bitset structure itself
; 189  :     //
; 190  :     bitset  = antlr3BitsetNew(ANTLR3_BITSET_BITS * inSet->blist.length);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  00023	6b 40 08 40	 imul	 eax, DWORD PTR [rax+8], 64 ; 00000040H
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 antlr3BitsetNew
  0002e	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 191  : 
; 192  :     if	(bitset == NULL)

  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00039	75 04		 jne	 SHORT $LN2@antlr3Bits

; 193  :     {
; 194  : 		return	NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 29		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 195  :     }
; 196  : 
; 197  :     // Install the actual bits in the source set
; 198  :     //
; 199  :     ANTLR3_MEMCPY(bitset->blist.bits, inSet->blist.bits, (ANTLR3_UINT64)(inSet->blist.length * sizeof(ANTLR3_BITWORD)));

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  00044	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00047	48 c1 e0 03	 shl	 rax, 3
  0004b	4c 8b c0	 mov	 r8, rax
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  00053	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0005b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005e	e8 00 00 00 00	 call	 memcpy

; 200  : 
; 201  :     // All seems good
; 202  :     //
; 203  :     return  bitset;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 204  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
antlr3BitsetClone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetSetAPI
_TEXT	SEGMENT
bitset$ = 16
antlr3BitsetSetAPI PROC					; COMDAT

; 123  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 124  :     bitset->clone		=    antlr3BitsetClone;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetClone
  00012	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 125  :     bitset->bor			=    antlr3BitsetOR;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetOR
  00022	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 126  :     bitset->borInPlace	=    antlr3BitsetORInPlace;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetORInPlace
  00032	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 127  :     bitset->size		=    antlr3BitsetSize;

  00036	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetSize
  00042	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 128  :     bitset->add			=    antlr3BitsetAdd;

  00046	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetAdd
  00052	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 129  :     bitset->grow		=    grow;

  00056	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:grow
  00062	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 130  :     bitset->equals		=    antlr3BitsetEquals;

  00066	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetEquals
  00072	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 131  :     bitset->isMember	=    antlr3BitsetMember;

  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetMember
  00082	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 132  :     bitset->numBits		=    antlr3BitsetNumBits;

  00086	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetNumBits
  00092	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 133  :     bitset->remove		=    antlr3BitsetRemove;

  00096	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetRemove
  000a2	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 134  :     bitset->isNilNode		=    antlr3BitsetIsNil;

  000a6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetIsNil
  000b2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 135  :     bitset->toIntList	=    antlr3BitsetToIntList;

  000b6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetToIntList
  000c2	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 136  : 
; 137  :     bitset->free		=    antlr3BitsetFree;

  000c6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetFree
  000d2	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 138  : }

  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
antlr3BitsetSetAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetLoad
_TEXT	SEGMENT
bitset$ = 32
count$ = 40
inBits$ = 64
antlr3BitsetLoad PROC					; COMDAT

; 255  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 256  : 	pANTLR3_BITSET  bitset;
; 257  : 	ANTLR3_UINT32  count;
; 258  : 
; 259  : 	// Allocate memory for the bitset structure itself
; 260  : 	// the input parameter is the bit number (0 based)
; 261  : 	// to include in the bitset, so we need at at least
; 262  : 	// bit + 1 bits. If any arguments indicate a 
; 263  : 	// a bit higher than the default number of bits (0 means default size)
; 264  : 	// then Add() will take care
; 265  : 	// of it.
; 266  : 	//
; 267  : 	bitset  = antlr3BitsetNew(0);

  0001e	33 c9		 xor	 ecx, ecx
  00020	e8 00 00 00 00	 call	 antlr3BitsetNew
  00025	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 268  : 
; 269  : 	if	(bitset == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00030	75 04		 jne	 SHORT $LN4@antlr3Bits

; 270  : 	{
; 271  : 		return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	eb 72		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 272  : 	}
; 273  : 
; 274  : 	if	(inBits != NULL)

  00036	48 83 7c 24 40
	00		 cmp	 QWORD PTR inBits$[rsp], 0
  0003c	74 65		 je	 SHORT $LN5@antlr3Bits

; 275  : 	{
; 276  : 		// Now we can add the element bits into the set
; 277  : 		//
; 278  : 		count=0;

  0003e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@antlr3Bits:

; 279  : 		while (count < inBits->length)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR inBits$[rsp]
  0004b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004e	39 44 24 28	 cmp	 DWORD PTR count$[rsp], eax
  00052	73 4f		 jae	 SHORT $LN3@antlr3Bits

; 280  : 		{
; 281  : 			if  (bitset->blist.length <= count)

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00059	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  0005d	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00060	77 15		 ja	 SHORT $LN6@antlr3Bits

; 282  : 			{
; 283  : 				bitset->grow(bitset, count+1);

  00062	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  00066	ff c0		 inc	 eax
  00068	8b d0		 mov	 edx, eax
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00074	ff 50 38	 call	 QWORD PTR [rax+56]
$LN6@antlr3Bits:

; 284  : 			}
; 285  : 
; 286  : 			bitset->blist.bits[count] = *((inBits->bits)+count);

  00077	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inBits$[rsp]
  00080	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00083	8b 54 24 28	 mov	 edx, DWORD PTR count$[rsp]
  00087	4c 8b 44 24 20	 mov	 r8, QWORD PTR bitset$[rsp]
  0008c	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0008f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00093	49 89 04 d0	 mov	 QWORD PTR [r8+rdx*8], rax

; 287  : 			count++;

  00097	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax

; 288  : 		}

  000a1	eb a3		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:
$LN5@antlr3Bits:

; 289  : 	}
; 290  : 
; 291  : 	// return the new bitset
; 292  : 	//
; 293  : 	return  bitset;

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 294  : }

  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
antlr3BitsetLoad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetCopy
_TEXT	SEGMENT
bitset$ = 32
numElements$ = 40
blist$ = 64
antlr3BitsetCopy PROC					; COMDAT

; 142  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 143  :     pANTLR3_BITSET  bitset;
; 144  : 	int				numElements;
; 145  : 
; 146  :     // Allocate memory for the bitset structure itself
; 147  :     //
; 148  :     bitset  = (pANTLR3_BITSET) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BITSET));

  0001e	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 149  : 
; 150  :     if	(bitset == NULL)

  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00034	75 07		 jne	 SHORT $LN2@antlr3Bits

; 151  :     {
; 152  : 		return	NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 81 00 00 00	 jmp	 $LN1@antlr3Bits
$LN2@antlr3Bits:

; 153  :     }
; 154  : 
; 155  : 	numElements = blist->length;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR blist$[rsp]
  00042	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00045	89 44 24 28	 mov	 DWORD PTR numElements$[rsp], eax

; 156  : 
; 157  :     // Avoid memory thrashing at the expense of a few more bytes
; 158  :     //
; 159  :     if	(numElements < 8)

  00049	83 7c 24 28 08	 cmp	 DWORD PTR numElements$[rsp], 8
  0004e	7d 08		 jge	 SHORT $LN3@antlr3Bits

; 160  :     {
; 161  : 		numElements = 8;

  00050	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR numElements$[rsp], 8
$LN3@antlr3Bits:

; 162  :     }
; 163  : 
; 164  :     // Install the length in ANTLR3_UINT64 units
; 165  :     //
; 166  :     bitset->blist.length  = numElements;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0005d	8b 4c 24 28	 mov	 ecx, DWORD PTR numElements$[rsp]
  00061	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 167  : 
; 168  :     bitset->blist.bits    = (pANTLR3_BITWORD)ANTLR3_MALLOC((size_t)(numElements * sizeof(ANTLR3_BITWORD)));

  00064	48 63 44 24 28	 movsxd	 rax, DWORD PTR numElements$[rsp]
  00069	48 c1 e0 03	 shl	 rax, 3
  0006d	48 8b c8	 mov	 rcx, rax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0007b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 169  : 
; 170  :     if	(bitset->blist.bits == NULL)

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00083	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00087	75 0f		 jne	 SHORT $LN4@antlr3Bits

; 171  :     {
; 172  : 		ANTLR3_FREE(bitset);

  00089	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 173  : 		return	NULL;

  00094	33 c0		 xor	 eax, eax
  00096	eb 26		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 174  :     }
; 175  : 
; 176  : 	ANTLR3_MEMCPY(bitset->blist.bits, blist->bits, (ANTLR3_UINT64)(numElements * sizeof(ANTLR3_BITWORD)));

  00098	48 63 44 24 28	 movsxd	 rax, DWORD PTR numElements$[rsp]
  0009d	48 c1 e0 03	 shl	 rax, 3
  000a1	4c 8b c0	 mov	 r8, rax
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR blist$[rsp]
  000a9	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  000b1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b4	e8 00 00 00 00	 call	 memcpy

; 177  : 
; 178  :     // All seems good
; 179  :     //
; 180  :     return  bitset;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 181  : }

  000be	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
antlr3BitsetCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetList
_TEXT	SEGMENT
bitSet$ = 32
en$ = 40
key$ = 56
bit$ = 88
list$ = 128
antlr3BitsetList PROC					; COMDAT

; 209  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 1c 00 00 00	 mov	 ecx, 28
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]

; 210  :     pANTLR3_BITSET		bitSet;
; 211  :     pANTLR3_HASH_ENUM	en;
; 212  :     pANTLR3_HASH_KEY	key;
; 213  :     ANTLR3_UINT64		bit;
; 214  : 
; 215  :     // We have no idea what exactly is in the list
; 216  :     // so create a default bitset and then just add stuff
; 217  :     // as we enumerate.
; 218  :     //
; 219  :     bitSet  = antlr3BitsetNew(0);

  00021	33 c9		 xor	 ecx, ecx
  00023	e8 00 00 00 00	 call	 antlr3BitsetNew
  00028	48 89 44 24 20	 mov	 QWORD PTR bitSet$[rsp], rax

; 220  : 
; 221  :     en		= antlr3EnumNew(list);

  0002d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00035	e8 00 00 00 00	 call	 antlr3EnumNew
  0003a	48 89 44 24 28	 mov	 QWORD PTR en$[rsp], rax
$LN2@antlr3Bits:

; 222  : 
; 223  :     while   (en->next(en, &key, (void **)(&bit)) == ANTLR3_SUCCESS)

  0003f	4c 8d 44 24 58	 lea	 r8, QWORD PTR bit$[rsp]
  00044	48 8d 54 24 38	 lea	 rdx, QWORD PTR key$[rsp]
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR en$[rsp]
  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR en$[rsp]
  00053	ff 50 18	 call	 QWORD PTR [rax+24]
  00056	85 c0		 test	 eax, eax
  00058	75 13		 jne	 SHORT $LN3@antlr3Bits

; 224  :     {
; 225  : 		bitSet->add(bitSet, (ANTLR3_UINT32)bit);

  0005a	8b 54 24 58	 mov	 edx, DWORD PTR bit$[rsp]
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitSet$[rsp]
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR bitSet$[rsp]
  00068	ff 50 30	 call	 QWORD PTR [rax+48]

; 226  :     }

  0006b	eb d2		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 227  :     en->free(en);

  0006d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR en$[rsp]
  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR en$[rsp]
  00077	ff 50 20	 call	 QWORD PTR [rax+32]

; 228  : 
; 229  :     return NULL;

  0007a	33 c0		 xor	 eax, eax

; 230  : }

  0007c	8b f8		 mov	 edi, eax
  0007e	48 8b cc	 mov	 rcx, rsp
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3BitsetList$rtcFrameData
  00088	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0008d	8b c7		 mov	 eax, edi
  0008f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
antlr3BitsetList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetOf
_TEXT	SEGMENT
bitset$ = 32
ap$ = 56
bit$ = 96
antlr3BitsetOf PROC					; COMDAT

; 318  : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 14 00 00 00	 mov	 ecx, 20
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 4c 24 60	 mov	 ecx, DWORD PTR [rsp+96]

; 319  :     pANTLR3_BITSET  bitset;
; 320  : 
; 321  :     va_list ap;
; 322  : 
; 323  :     // Allocate memory for the bitset structure itself
; 324  :     // the input parameter is the bit number (0 based)
; 325  :     // to include in the bitset, so we need at at least
; 326  :     // bit + 1 bits. If any arguments indicate a 
; 327  :     // a bit higher than the default number of bits (0 menas default size)
; 328  :     // then Add() will take care
; 329  :     // of it.
; 330  :     //
; 331  :     bitset  = antlr3BitsetNew(0);

  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 antlr3BitsetNew
  00032	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 332  : 
; 333  :     if	(bitset == NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  0003d	75 04		 jne	 SHORT $LN4@antlr3Bits

; 334  :     {
; 335  : 		return	NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 49		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 336  :     }
; 337  : 
; 338  :     // Now we can add the element bits into the set
; 339  :     //
; 340  :     va_start(ap, bit);

  00043	48 8d 44 24 68	 lea	 rax, QWORD PTR bit$[rsp+8]
  00048	48 89 44 24 38	 mov	 QWORD PTR ap$[rsp], rax
$LN2@antlr3Bits:

; 341  :     while   (bit != -1)

  0004d	83 7c 24 60 ff	 cmp	 DWORD PTR bit$[rsp], -1
  00052	74 2a		 je	 SHORT $LN3@antlr3Bits

; 342  :     {
; 343  : 		antlr3BitsetAdd(bitset, bit);

  00054	8b 54 24 60	 mov	 edx, DWORD PTR bit$[rsp]
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0005d	e8 00 00 00 00	 call	 antlr3BitsetAdd

; 344  : 		bit = va_arg(ap, ANTLR3_UINT32);

  00062	48 8b 44 24 38	 mov	 rax, QWORD PTR ap$[rsp]
  00067	48 83 c0 08	 add	 rax, 8
  0006b	48 89 44 24 38	 mov	 QWORD PTR ap$[rsp], rax
  00070	48 8b 44 24 38	 mov	 rax, QWORD PTR ap$[rsp]
  00075	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  00078	89 44 24 60	 mov	 DWORD PTR bit$[rsp], eax

; 345  :     }

  0007c	eb cf		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 346  :     va_end(ap);

  0007e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ap$[rsp], 0

; 347  : 
; 348  :     // return the new bitset
; 349  :     //
; 350  :     return  bitset;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 351  : }

  0008c	48 8b f8	 mov	 rdi, rax
  0008f	48 8b cc	 mov	 rcx, rsp
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3BitsetOf$rtcFrameData
  00099	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009e	48 8b c7	 mov	 rax, rdi
  000a1	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
antlr3BitsetOf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3bitset.c
;	COMDAT antlr3BitsetNew
_TEXT	SEGMENT
bitset$ = 32
numelements$ = 40
numBits$ = 64
antlr3BitsetNew PROC					; COMDAT

; 77   : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 78   : 	pANTLR3_BITSET  bitset;
; 79   : 
; 80   : 	ANTLR3_UINT32   numelements;
; 81   : 
; 82   : 	// Allocate memory for the bitset structure itself
; 83   : 	//
; 84   : 	bitset  = (pANTLR3_BITSET) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BITSET));

  0001c	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 85   : 
; 86   : 	if	(bitset == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00032	75 07		 jne	 SHORT $LN2@antlr3Bits

; 87   : 	{
; 88   : 		return	NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 89 00 00 00	 jmp	 $LN1@antlr3Bits
$LN2@antlr3Bits:

; 89   : 	}
; 90   : 
; 91   : 	// Avoid memory thrashing at the up front expense of a few bytes
; 92   : 	//
; 93   : 	if	(numBits < (8 * ANTLR3_BITSET_BITS))

  0003b	81 7c 24 40 00
	02 00 00	 cmp	 DWORD PTR numBits$[rsp], 512 ; 00000200H
  00043	73 08		 jae	 SHORT $LN3@antlr3Bits

; 94   : 	{
; 95   : 		numBits = 8 * ANTLR3_BITSET_BITS;

  00045	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR numBits$[rsp], 512 ; 00000200H
$LN3@antlr3Bits:

; 96   : 	}
; 97   : 
; 98   : 	// No we need to allocate the memory for the number of bits asked for
; 99   : 	// in multiples of ANTLR3_UINT64. 
; 100  : 	//
; 101  : 	numelements	= ((numBits -1) >> ANTLR3_BITSET_LOG_BITS) + 1;

  0004d	8b 44 24 40	 mov	 eax, DWORD PTR numBits$[rsp]
  00051	ff c8		 dec	 eax
  00053	c1 e8 06	 shr	 eax, 6
  00056	ff c0		 inc	 eax
  00058	89 44 24 28	 mov	 DWORD PTR numelements$[rsp], eax

; 102  : 
; 103  : 	bitset->blist.bits    = (pANTLR3_BITWORD) ANTLR3_MALLOC((size_t)(numelements * sizeof(ANTLR3_BITWORD)));

  0005c	8b 44 24 28	 mov	 eax, DWORD PTR numelements$[rsp]
  00060	48 c1 e0 03	 shl	 rax, 3
  00064	48 8b c8	 mov	 rcx, rax
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00072	48 89 01	 mov	 QWORD PTR [rcx], rax

; 104  : 	memset(bitset->blist.bits, 0, (size_t)(numelements * sizeof(ANTLR3_BITWORD)));

  00075	8b 44 24 28	 mov	 eax, DWORD PTR numelements$[rsp]
  00079	48 c1 e0 03	 shl	 rax, 3
  0007d	4c 8b c0	 mov	 r8, rax
  00080	33 d2		 xor	 edx, edx
  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00087	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008a	e8 00 00 00 00	 call	 memset

; 105  : 	bitset->blist.length  = numelements;

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR numelements$[rsp]
  00098	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 106  : 
; 107  : 	if	(bitset->blist.bits == NULL)

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  000a0	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a4	75 0f		 jne	 SHORT $LN4@antlr3Bits

; 108  : 	{
; 109  : 		ANTLR3_FREE(bitset);

  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 110  : 		return	NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	eb 0f		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 111  : 	}
; 112  : 
; 113  : 	antlr3BitsetSetAPI(bitset);

  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  000ba	e8 00 00 00 00	 call	 antlr3BitsetSetAPI

; 114  : 
; 115  : 
; 116  : 	// All seems good
; 117  : 	//
; 118  : 	return  bitset;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 119  : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
antlr3BitsetNew ENDP
_TEXT	ENDS
END
