; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3FileStreamNew
PUBLIC	antlr3StringStreamNew
PUBLIC	antlr3Fopen
PUBLIC	antlr3Fclose
PUBLIC	antlr3Fsize
PUBLIC	antlr3read8Bit
PUBLIC	antlr3Fread
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__stat64i32:PROC
EXTRN	antlr38BitSetupStream:PROC
EXTRN	antlr3UTF16SetupStream:PROC
EXTRN	antlr3UTF32SetupStream:PROC
EXTRN	antlr3UTF8SetupStream:PROC
EXTRN	antlr3EBCDICSetupStream:PROC
EXTRN	antlr3GenericSetupStream:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3FileStreamNew DD imagerel $LN4
	DD	imagerel $LN4+156
	DD	imagerel $unwind$antlr3FileStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StringStreamNew DD imagerel $LN4
	DD	imagerel $LN4+178
	DD	imagerel $unwind$antlr3StringStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fopen DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$antlr3Fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fclose DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$antlr3Fclose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fsize DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$antlr3Fsize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3read8Bit DD imagerel $LN5
	DD	imagerel $LN5+191
	DD	imagerel $unwind$antlr3read8Bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fread DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$antlr3Fread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupInputStream DD imagerel setupInputStream
	DD	imagerel setupInputStream+873
	DD	imagerel $unwind$setupInputStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateFileStream DD imagerel antlr3CreateFileStream
	DD	imagerel antlr3CreateFileStream+139
	DD	imagerel $unwind$antlr3CreateFileStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateStringStream DD imagerel antlr3CreateStringStream
	DD	imagerel antlr3CreateStringStream+122
	DD	imagerel $unwind$antlr3CreateStringStream
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateStringStream DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateFileStream DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupInputStream DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fread DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3read8Bit DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fsize DD 023319H
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3Fsize$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+8
antlr3Fsize$rtcVarDesc DD 028H
	DD	030H
	DQ	FLAT:antlr3Fsize$rtcName$0
	ORG $+48
antlr3Fsize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:antlr3Fsize$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fclose DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fopen DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StringStreamNew DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3FileStreamNew DD 022201H
	DD	0700a520eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateStringStream
_TEXT	SEGMENT
input$ = 32
data$ = 64
antlr3CreateStringStream PROC				; COMDAT

; 443  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 444  : 	// Pointer to the input stream we are going to create
; 445  : 	//
; 446  : 	pANTLR3_INPUT_STREAM    input;
; 447  : 
; 448  : 	if	(data == NULL)

  0001e	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$[rsp], 0
  00024	75 04		 jne	 SHORT $LN2@antlr3Crea

; 449  : 	{
; 450  : 		return NULL;

  00026	33 c0		 xor	 eax, eax
  00028	eb 4a		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 451  : 	}
; 452  : 
; 453  : 	// Allocate memory for the input stream structure
; 454  : 	//
; 455  : 	input   = (pANTLR3_INPUT_STREAM)

  0002a	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0003a	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 456  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 457  : 
; 458  : 	if	(input == NULL)

  0003f	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00045	75 04		 jne	 SHORT $LN3@antlr3Crea

; 459  : 	{
; 460  : 		return	NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 29		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 461  : 	}
; 462  : 
; 463  : 	// Structure was allocated correctly, now we can install the pointer
; 464  : 	//
; 465  :         input->data             = data;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00055	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 466  :         input->isAllocated	= ANTLR3_FALSE;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0005e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 467  : 
; 468  : 	// Call the common 8 bit input stream handler
; 469  : 	// initialization.
; 470  : 	//
; 471  : 	antlr3GenericSetupStream(input);

  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0006a	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 472  : 
; 473  :         return  input;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 474  : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
antlr3CreateStringStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateFileStream
_TEXT	SEGMENT
input$ = 32
status$ = 40
fileName$ = 64
antlr3CreateFileStream PROC				; COMDAT

; 309  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 310  : 	// Pointer to the input stream we are going to create
; 311  : 	//
; 312  : 	pANTLR3_INPUT_STREAM    input;
; 313  : 	ANTLR3_UINT32	    status;
; 314  : 
; 315  : 	if	(fileName == NULL)

  0001e	48 83 7c 24 40
	00		 cmp	 QWORD PTR fileName$[rsp], 0
  00024	75 04		 jne	 SHORT $LN2@antlr3Crea

; 316  : 	{
; 317  : 		return NULL;

  00026	33 c0		 xor	 eax, eax
  00028	eb 5b		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 318  : 	}
; 319  : 
; 320  : 	// Allocate memory for the input stream structure
; 321  : 	//
; 322  : 	input   = (pANTLR3_INPUT_STREAM)

  0002a	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0003a	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 323  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 324  : 
; 325  : 	if	(input == NULL)

  0003f	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00045	75 04		 jne	 SHORT $LN3@antlr3Crea

; 326  : 	{
; 327  : 		return	NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 3a		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 328  : 	}
; 329  : 
; 330  : 	// Structure was allocated correctly, now we can read the file.
; 331  : 	//
; 332  : 	status  = antlr3read8Bit(input, fileName);

  0004b	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00055	e8 00 00 00 00	 call	 antlr3read8Bit
  0005a	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 333  : 
; 334  : 	// Call the common 8 bit input stream handler
; 335  : 	// initialization.
; 336  : 	//
; 337  : 	antlr3GenericSetupStream(input);

  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00063	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 338  : 
; 339  :         // However if the file was not there or something then we
; 340  :         // need to close. Have to wait until here as we cannot call
; 341  :         // close until the API is installed of course.
; 342  :         // 
; 343  : 	if	(status != ANTLR3_SUCCESS)

  00068	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  0006d	74 11		 je	 SHORT $LN4@antlr3Crea

; 344  : 	{
; 345  : 		input->close(input);

  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00079	ff 50 60	 call	 QWORD PTR [rax+96]

; 346  : 		return	NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN1@antlr3Crea
$LN4@antlr3Crea:

; 347  : 	}
; 348  : 
; 349  : 	return  input;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 350  : }

  00085	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
antlr3CreateFileStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT setupInputStream
_TEXT	SEGMENT
isBigEndian$ = 32
bomTest$ = 36
tv67 = 40
input$ = 64
setupInputStream PROC					; COMDAT

; 131  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 132  :     ANTLR3_BOOLEAN  isBigEndian;
; 133  : 
; 134  :     // Used to determine the endianness of the machine we are currently
; 135  :     // running on.
; 136  :     //
; 137  :     ANTLR3_UINT16 bomTest = 0xFEFF;

  0001e	b8 ff fe 00 00	 mov	 eax, 65279		; 0000feffH
  00023	66 89 44 24 24	 mov	 WORD PTR bomTest$[rsp], ax

; 138  :     
; 139  :     // What endianess is the machine we are running on? If the incoming
; 140  :     // encoding endianess is the same as this machine's natural byte order
; 141  :     // then we can use more efficient API calls.
; 142  :     //
; 143  :     if  (*((pANTLR3_UINT8)(&bomTest)) == 0xFE)

  00028	0f b6 44 24 24	 movzx	 eax, BYTE PTR bomTest$[rsp]
  0002d	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00032	75 07		 jne	 SHORT $LN4@setupInput

; 144  :     {
; 145  :         isBigEndian = ANTLR3_TRUE;

  00034	c6 44 24 20 01	 mov	 BYTE PTR isBigEndian$[rsp], 1

; 146  :     }

  00039	eb 05		 jmp	 SHORT $LN5@setupInput
$LN4@setupInput:

; 147  :     else
; 148  :     {
; 149  :         isBigEndian = ANTLR3_FALSE;

  0003b	c6 44 24 20 00	 mov	 BYTE PTR isBigEndian$[rsp], 0
$LN5@setupInput:

; 150  :     }
; 151  : 
; 152  :     // What encoding did the user tell us {s}he thought it was? I am going
; 153  :     // to get sick of the questions on antlr-interest, I know I am.
; 154  :     //
; 155  :     switch  (input->encoding)

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00045	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  0004b	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  0004f	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00053	83 e8 08	 sub	 eax, 8
  00056	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  0005a	83 7c 24 28 38	 cmp	 DWORD PTR tv67[rsp], 56	; 00000038H
  0005f	0f 87 97 02 00
	00		 ja	 $LN23@setupInput
  00065	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00070	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN25@setupInput[rcx+rax]
  00078	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN26@setupInput[rcx+rax*4]
  0007f	48 03 c1	 add	 rax, rcx
  00082	ff e0		 jmp	 rax
$LN6@setupInput:

; 156  :     {
; 157  :         case    ANTLR3_ENC_UTF8:
; 158  : 
; 159  :             // See if there is a BOM at the start of this UTF-8 sequence
; 160  :             // and just eat it if there is. Windows .TXT files have this for instance
; 161  :             // as it identifies UTF-8 even though it is of no consequence for byte order
; 162  :             // as UTF-8 does not have a byte order.
; 163  :             //
; 164  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xEF
; 165  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xBB
; 166  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xBF

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00089	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00090	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00095	75 3e		 jne	 SHORT $LN7@setupInput
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0009c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000a4	3d bb 00 00 00	 cmp	 eax, 187		; 000000bbH
  000a9	75 2a		 jne	 SHORT $LN7@setupInput
  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b4	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000b8	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000bd	75 16		 jne	 SHORT $LN7@setupInput

; 167  :                 )
; 168  :             {
; 169  :                 // The UTF8 BOM is present so skip it
; 170  :                 //
; 171  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 3);

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000c4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c8	48 83 c0 03	 add	 rax, 3
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000d1	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN7@setupInput:

; 172  :             }
; 173  : 
; 174  :             // Install the UTF8 input routines
; 175  :             //
; 176  :             antlr3UTF8SetupStream(input);

  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000da	e8 00 00 00 00	 call	 antlr3UTF8SetupStream

; 177  :             break;

  000df	e9 22 02 00 00	 jmp	 $LN2@setupInput
$LN8@setupInput:

; 178  : 
; 179  :         case    ANTLR3_ENC_UTF16:
; 180  : 
; 181  :             // See if there is a BOM at the start of the input. If not then
; 182  :             // we assume that the byte order is the natural order of this
; 183  :             // machine (or it is really UCS2). If there is a BOM we determine if the encoding
; 184  :             // is the same as the natural order of this machine.
; 185  :             //
; 186  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFE
; 187  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFF

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e9	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ed	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f0	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000f5	75 3e		 jne	 SHORT $LN9@setupInput
  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fc	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00100	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00104	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00109	75 2a		 jne	 SHORT $LN9@setupInput

; 188  :                 )
; 189  :             {
; 190  :                 // BOM Present, indicates Big Endian
; 191  :                 //
; 192  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00110	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00114	48 83 c0 02	 add	 rax, 2
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0011d	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 193  : 
; 194  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  00121	41 b0 01	 mov	 r8b, 1
  00124	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0012e	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 195  :             }

  00133	eb 66		 jmp	 SHORT $LN10@setupInput
$LN9@setupInput:

; 196  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 197  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE

  00135	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0013a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00141	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00146	75 3e		 jne	 SHORT $LN11@setupInput
  00148	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0014d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00151	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00155	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0015a	75 2a		 jne	 SHORT $LN11@setupInput

; 198  :                 )
; 199  :             {
; 200  :                 // BOM present, indicates Little Endian
; 201  :                 //
; 202  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  0015c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00161	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00165	48 83 c0 02	 add	 rax, 2
  00169	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0016e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 203  : 
; 204  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00172	45 33 c0	 xor	 r8d, r8d
  00175	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0017f	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 205  :             }

  00184	eb 15		 jmp	 SHORT $LN12@setupInput
$LN11@setupInput:

; 206  :             else
; 207  :             {
; 208  :                 // No BOM present, assume local computer byte order
; 209  :                 //
; 210  :                 antlr3UTF16SetupStream(input, isBigEndian, isBigEndian);

  00186	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00191	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00196	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
$LN12@setupInput:
$LN10@setupInput:

; 211  :             }
; 212  :             break;

  0019b	e9 66 01 00 00	 jmp	 $LN2@setupInput
$LN13@setupInput:

; 213  : 
; 214  :         case    ANTLR3_ENC_UTF32:
; 215  : 
; 216  :             // See if there is a BOM at the start of the input. If not then
; 217  :             // we assume that the byte order is the natural order of this
; 218  :             // machine. If there is we determine if the encoding
; 219  :             // is the same as the natural order of this machine.
; 220  :             //
; 221  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0x00
; 222  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 223  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xFE
; 224  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+3))    == 0xFF

  001a0	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001a5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001a9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ac	85 c0		 test	 eax, eax
  001ae	75 66		 jne	 SHORT $LN14@setupInput
  001b0	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001b5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001b9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001bd	85 c0		 test	 eax, eax
  001bf	75 55		 jne	 SHORT $LN14@setupInput
  001c1	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001c6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ca	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001ce	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  001d3	75 41		 jne	 SHORT $LN14@setupInput
  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001da	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001de	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e7	75 2d		 jne	 SHORT $LN14@setupInput

; 225  :                 )
; 226  :             {
; 227  :                 // BOM Present, indicates Big Endian
; 228  :                 //
; 229  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  001e9	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001ee	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001f2	48 83 c0 04	 add	 rax, 4
  001f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  001fb	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 230  : 
; 231  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  001ff	41 b0 01	 mov	 r8b, 1
  00202	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00207	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0020c	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 232  :             }

  00211	e9 88 00 00 00	 jmp	 $LN15@setupInput
$LN14@setupInput:

; 233  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 234  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE
; 235  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 236  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00

  00216	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0021b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0021f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00222	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00227	75 60		 jne	 SHORT $LN16@setupInput
  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0022e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00232	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00236	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0023b	75 4c		 jne	 SHORT $LN16@setupInput
  0023d	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00242	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00246	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0024a	85 c0		 test	 eax, eax
  0024c	75 3b		 jne	 SHORT $LN16@setupInput
  0024e	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00253	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	85 c0		 test	 eax, eax
  0025d	75 2a		 jne	 SHORT $LN16@setupInput

; 237  :                 )
; 238  :             {
; 239  :                 // BOM present, indicates Little Endian
; 240  :                 //
; 241  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  0025f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00264	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00268	48 83 c0 04	 add	 rax, 4
  0026c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00271	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 242  : 
; 243  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00275	45 33 c0	 xor	 r8d, r8d
  00278	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  0027d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00282	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 244  :             }

  00287	eb 15		 jmp	 SHORT $LN17@setupInput
$LN16@setupInput:

; 245  :             else
; 246  :             {
; 247  :                 // No BOM present, assume local computer byte order
; 248  :                 //
; 249  :                 antlr3UTF32SetupStream(input, isBigEndian, isBigEndian);

  00289	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  0028f	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00294	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00299	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
$LN17@setupInput:
$LN15@setupInput:

; 250  :             }
; 251  :             break;

  0029e	eb 66		 jmp	 SHORT $LN2@setupInput
$LN18@setupInput:

; 252  : 
; 253  :         case    ANTLR3_ENC_UTF16BE:
; 254  : 
; 255  :             // Encoding is definately Big Endian with no BOM
; 256  :             //
; 257  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  002a0	41 b0 01	 mov	 r8b, 1
  002a3	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002ad	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 258  :             break;

  002b2	eb 52		 jmp	 SHORT $LN2@setupInput
$LN19@setupInput:

; 259  : 
; 260  :         case    ANTLR3_ENC_UTF16LE:
; 261  : 
; 262  :             // Encoding is definately Little Endian with no BOM
; 263  :             //
; 264  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002b4	45 33 c0	 xor	 r8d, r8d
  002b7	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002c1	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 265  :             break;

  002c6	eb 3e		 jmp	 SHORT $LN2@setupInput
$LN20@setupInput:

; 266  : 
; 267  :         case    ANTLR3_ENC_UTF32BE:
; 268  : 
; 269  :             // Encoding is definately Big Endian with no BOM
; 270  :             //
; 271  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  002c8	41 b0 01	 mov	 r8b, 1
  002cb	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002d5	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 272  :             break;

  002da	eb 2a		 jmp	 SHORT $LN2@setupInput
$LN21@setupInput:

; 273  : 
; 274  :         case    ANTLR3_ENC_UTF32LE:
; 275  : 
; 276  :             // Encoding is definately Little Endian with no BOM
; 277  :             //
; 278  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002dc	45 33 c0	 xor	 r8d, r8d
  002df	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002e9	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 279  :             break;

  002ee	eb 16		 jmp	 SHORT $LN2@setupInput
$LN22@setupInput:

; 280  : 
; 281  :         case    ANTLR3_ENC_EBCDIC:
; 282  : 
; 283  :             // EBCDIC is basically the same as ASCII but with an on the
; 284  :             // fly translation to ASCII
; 285  :             //
; 286  :             antlr3EBCDICSetupStream(input);

  002f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002f5	e8 00 00 00 00	 call	 antlr3EBCDICSetupStream

; 287  :             break;

  002fa	eb 0a		 jmp	 SHORT $LN2@setupInput
$LN23@setupInput:

; 288  : 
; 289  :         case    ANTLR3_ENC_8BIT:
; 290  :         default:
; 291  : 
; 292  :             // Standard 8bit/ASCII
; 293  :             //
; 294  :             antlr38BitSetupStream(input);

  002fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00301	e8 00 00 00 00	 call	 antlr38BitSetupStream
$LN2@setupInput:

; 295  :             break;
; 296  :     }    
; 297  : }

  00306	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0030a	5f		 pop	 rdi
  0030b	c3		 ret	 0
$LN26@setupInput:
  0030c	00 00 00 00	 DD	 $LN6@setupInput
  00310	00 00 00 00	 DD	 $LN8@setupInput
  00314	00 00 00 00	 DD	 $LN18@setupInput
  00318	00 00 00 00	 DD	 $LN19@setupInput
  0031c	00 00 00 00	 DD	 $LN13@setupInput
  00320	00 00 00 00	 DD	 $LN20@setupInput
  00324	00 00 00 00	 DD	 $LN21@setupInput
  00328	00 00 00 00	 DD	 $LN22@setupInput
  0032c	00 00 00 00	 DD	 $LN23@setupInput
$LN25@setupInput:
  00330	00		 DB	 0
  00331	08		 DB	 8
  00332	08		 DB	 8
  00333	08		 DB	 8
  00334	08		 DB	 8
  00335	08		 DB	 8
  00336	08		 DB	 8
  00337	08		 DB	 8
  00338	01		 DB	 1
  00339	02		 DB	 2
  0033a	03		 DB	 3
  0033b	08		 DB	 8
  0033c	08		 DB	 8
  0033d	08		 DB	 8
  0033e	08		 DB	 8
  0033f	08		 DB	 8
  00340	08		 DB	 8
  00341	08		 DB	 8
  00342	08		 DB	 8
  00343	08		 DB	 8
  00344	08		 DB	 8
  00345	08		 DB	 8
  00346	08		 DB	 8
  00347	08		 DB	 8
  00348	04		 DB	 4
  00349	05		 DB	 5
  0034a	06		 DB	 6
  0034b	08		 DB	 8
  0034c	08		 DB	 8
  0034d	08		 DB	 8
  0034e	08		 DB	 8
  0034f	08		 DB	 8
  00350	08		 DB	 8
  00351	08		 DB	 8
  00352	08		 DB	 8
  00353	08		 DB	 8
  00354	08		 DB	 8
  00355	08		 DB	 8
  00356	08		 DB	 8
  00357	08		 DB	 8
  00358	08		 DB	 8
  00359	08		 DB	 8
  0035a	08		 DB	 8
  0035b	08		 DB	 8
  0035c	08		 DB	 8
  0035d	08		 DB	 8
  0035e	08		 DB	 8
  0035f	08		 DB	 8
  00360	08		 DB	 8
  00361	08		 DB	 8
  00362	08		 DB	 8
  00363	08		 DB	 8
  00364	08		 DB	 8
  00365	08		 DB	 8
  00366	08		 DB	 8
  00367	08		 DB	 8
  00368	07		 DB	 7
setupInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fread
_TEXT	SEGMENT
fdsc$ = 48
count$ = 56
data$ = 64
antlr3Fread PROC					; COMDAT

; 429  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 430  :     return  (ANTLR3_UINT32)fread(data, (size_t)count, 1, fdsc);

  00027	8b 44 24 38	 mov	 eax, DWORD PTR count$[rsp]
  0002b	4c 8b 4c 24 30	 mov	 r9, QWORD PTR fdsc$[rsp]
  00030	41 b8 01 00 00
	00		 mov	 r8d, 1
  00036	8b d0		 mov	 edx, eax
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 431  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
antlr3Fread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3read8Bit
_TEXT	SEGMENT
infile$ = 32
fSize$ = 40
input$ = 64
fileName$ = 72
antlr3read8Bit PROC					; COMDAT

; 354  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 355  : 	ANTLR3_FDSC	    infile;
; 356  : 	ANTLR3_UINT32	    fSize;
; 357  : 
; 358  : 	/* Open the OS file in read binary mode
; 359  : 	*/
; 360  : 	infile  = antlr3Fopen(fileName, "rb");

  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  0002f	e8 00 00 00 00	 call	 antlr3Fopen
  00034	48 89 44 24 20	 mov	 QWORD PTR infile$[rsp], rax

; 361  : 
; 362  : 	/* Check that it was there
; 363  : 	*/
; 364  : 	if	(infile == NULL)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR infile$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN2@antlr3read

; 365  : 	{
; 366  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOFILE;

  00041	b8 02 00 00 00	 mov	 eax, 2
  00046	eb 71		 jmp	 SHORT $LN1@antlr3read
$LN2@antlr3read:

; 367  : 	}
; 368  : 
; 369  : 	/* It was there, so we can read the bytes now
; 370  : 	*/
; 371  : 	fSize   = antlr3Fsize(fileName);	/* Size of input file	*/

  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  0004d	e8 00 00 00 00	 call	 antlr3Fsize
  00052	89 44 24 28	 mov	 DWORD PTR fSize$[rsp], eax

; 372  : 
; 373  : 	/* Allocate buffer for this input set   
; 374  : 	*/
; 375  : 	input->data	    = ANTLR3_MALLOC((size_t)fSize);

  00056	8b 44 24 28	 mov	 eax, DWORD PTR fSize$[rsp]
  0005a	8b c8		 mov	 ecx, eax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 376  : 	input->sizeBuf  = fSize;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00070	8b 4c 24 28	 mov	 ecx, DWORD PTR fSize$[rsp]
  00074	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 377  : 
; 378  : 	if	(input->data == NULL)

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0007c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00081	75 07		 jne	 SHORT $LN3@antlr3read

; 379  : 	{
; 380  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOMEM;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	eb 2f		 jmp	 SHORT $LN1@antlr3read
$LN3@antlr3read:

; 381  : 	}
; 382  : 
; 383  : 	input->isAllocated	= ANTLR3_TRUE;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0008f	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 384  : 
; 385  : 	/* Now we read the file. Characters are not converted to
; 386  : 	* the internal ANTLR encoding until they are read from the buffer
; 387  : 	*/
; 388  : 	antlr3Fread(infile, fSize, input->data);

  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0009b	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0009f	8b 54 24 28	 mov	 edx, DWORD PTR fSize$[rsp]
  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  000a8	e8 00 00 00 00	 call	 antlr3Fread

; 389  : 
; 390  : 	/* And close the file handle
; 391  : 	*/
; 392  : 	antlr3Fclose(infile);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  000b2	e8 00 00 00 00	 call	 antlr3Fclose

; 393  : 
; 394  : 	return  ANTLR3_SUCCESS;

  000b7	33 c0		 xor	 eax, eax
$LN1@antlr3read:

; 395  : }

  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
antlr3read8Bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fsize
_TEXT	SEGMENT
statbuf$ = 40
__$ArrayPad$ = 112
fileName$ = 144
antlr3Fsize PROC					; COMDAT

; 419  : {   

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 420  :     struct _stat	statbuf;
; 421  : 
; 422  :     _stat((const char *)fileName, &statbuf);

  00033	48 8d 54 24 28	 lea	 rdx, QWORD PTR statbuf$[rsp]
  00038	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fileName$[rsp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64i32

; 423  : 
; 424  :     return (ANTLR3_UINT32)statbuf.st_size;

  00046	8b 44 24 3c	 mov	 eax, DWORD PTR statbuf$[rsp+20]

; 425  : }

  0004a	8b f8		 mov	 edi, eax
  0004c	48 8b cc	 mov	 rcx, rsp
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3Fsize$rtcFrameData
  00056	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0005b	8b c7		 mov	 eax, edi
  0005d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
antlr3Fsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fclose
_TEXT	SEGMENT
fd$ = 48
antlr3Fclose PROC					; COMDAT

; 414  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 415  :     fclose(fd);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fd$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 416  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
antlr3Fclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fopen
_TEXT	SEGMENT
filename$ = 48
mode$ = 56
antlr3Fopen PROC					; COMDAT

; 405  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 406  :     return  (ANTLR3_FDSC)fopen((const char *)filename, mode);

  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR mode$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filename$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen

; 407  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
antlr3Fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3StringStreamNew
_TEXT	SEGMENT
input$ = 32
data$ = 64
encoding$ = 72
size$ = 80
name$ = 88
antlr3StringStreamNew PROC				; COMDAT

; 90   : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 91   :     pANTLR3_INPUT_STREAM    input;
; 92   : 
; 93   :     // First order of business is to set up the stream and install the data pointer.
; 94   :     // Then we will work out the encoding and byte order and adjust the API functions that are installed for the
; 95   :     // default 8Bit stream accordingly.
; 96   :     //
; 97   :     input   = antlr3CreateStringStream(data);

  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00031	e8 00 00 00 00	 call	 antlr3CreateStringStream
  00036	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 98   :     if  (input == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00041	75 04		 jne	 SHORT $LN2@antlr3Stri

; 99   :     {
; 100  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	eb 65		 jmp	 SHORT $LN1@antlr3Stri
$LN2@antlr3Stri:

; 101  :     }
; 102  :     
; 103  :     // Size (in bytes) of the given 'string'
; 104  :     //
; 105  :     input->sizeBuf		= size;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  00050	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 106  : 
; 107  :     // We have the data in memory now so we can deal with it according to 
; 108  :     // the encoding scheme we were given by the user.
; 109  :     //
; 110  :     input->encoding = encoding;

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00058	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  0005c	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 111  : 
; 112  :     // Now we need to work out the endian type and install any 
; 113  :     // API functions that differ from 8Bit
; 114  :     //
; 115  :     setupInputStream(input);

  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00067	e8 00 00 00 00	 call	 setupInputStream

; 116  : 
; 117  :     // Now we can set up the file name
; 118  :     //	
; 119  :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, name);

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00071	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00075	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0007f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00083	ff 50 38	 call	 QWORD PTR [rax+56]
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0008b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 120  :     input->fileName		= input->istream->streamName;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00097	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0009f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a3	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 121  : 
; 122  :     return input;

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Stri:

; 123  : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
antlr3StringStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3FileStreamNew
_TEXT	SEGMENT
input$ = 32
fileName$ = 64
encoding$ = 72
antlr3FileStreamNew PROC				; COMDAT

; 55   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 56   :     pANTLR3_INPUT_STREAM input;
; 57   : 
; 58   :     // First order of business is to read the file into some buffer space
; 59   :     // as just straight 8 bit bytes. Then we will work out the encoding and
; 60   :     // byte order and adjust the API functions that are installed for the
; 61   :     // default 8Bit stream accordingly.
; 62   :     //
; 63   :     input   = antlr3CreateFileStream(fileName);

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fileName$[rsp]
  00027	e8 00 00 00 00	 call	 antlr3CreateFileStream
  0002c	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 64   :     if  (input == NULL)

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00037	75 04		 jne	 SHORT $LN2@antlr3File

; 65   :     {
; 66   :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 59		 jmp	 SHORT $LN1@antlr3File
$LN2@antlr3File:

; 67   :     }
; 68   : 
; 69   :     // We have the data in memory now so we can deal with it according to 
; 70   :     // the encoding scheme we were given by the user.
; 71   :     //
; 72   :     input->encoding = encoding;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00042	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  00046	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 73   : 
; 74   :     // Now we need to work out the endian type and install any 
; 75   :     // API functions that differ from 8Bit
; 76   :     //
; 77   :     setupInputStream(input);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00051	e8 00 00 00 00	 call	 setupInputStream

; 78   : 
; 79   :     // Now we can set up the file name
; 80   :     //	
; 81   :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, fileName);

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0005b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005f	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00069	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006d	ff 50 38	 call	 QWORD PTR [rax+56]
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00075	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00078	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 82   :     input->fileName		= input->istream->streamName;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00081	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00089	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008d	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 83   : 
; 84   :     return input;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3File:

; 85   : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
antlr3FileStreamNew ENDP
_TEXT	ENDS
END
