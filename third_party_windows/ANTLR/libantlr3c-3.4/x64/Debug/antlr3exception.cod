; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3ExceptionNew
PUBLIC	??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08X@ ; `string'
PUBLIC	??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6?$AA@ ; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ExceptionNew DD imagerel $LN4
	DD	imagerel $LN4+177
	DD	imagerel $unwind$antlr3ExceptionNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ExceptionPrint DD imagerel antlr3ExceptionPrint
	DD	imagerel antlr3ExceptionPrint+151
	DD	imagerel $unwind$antlr3ExceptionPrint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ExceptionFree DD imagerel antlr3ExceptionFree
	DD	imagerel antlr3ExceptionFree+148
	DD	imagerel $unwind$antlr3ExceptionFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6?$AA@ DB 'ANTLR3_EXCEPTION:'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08X@
CONST	SEGMENT
??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08X@ DB 'ANTL'
	DB	'R3_EXCEPTION number %d (%08X).', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ExceptionFree DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ExceptionPrint DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ExceptionNew DD 022b01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3exception.c
;	COMDAT antlr3ExceptionFree
_TEXT	SEGMENT
next$ = 32
ex$ = 64
antlr3ExceptionFree PROC				; COMDAT

; 155  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
$LN2@antlr3Exce:

; 156  :     pANTLR3_EXCEPTION next;
; 157  : 
; 158  :     /* Ensure valid pointer
; 159  :      */
; 160  :     while   (ex != NULL)

  0001e	48 83 7c 24 40
	00		 cmp	 QWORD PTR ex$[rsp], 0
  00024	74 68		 je	 SHORT $LN3@antlr3Exce

; 161  :     {
; 162  : 	/* Pick up anythign following now, before we free the
; 163  : 	 * current memory block.
; 164  : 	 */
; 165  : 	next	= ex->nextException;

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  0002b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0002f	48 89 44 24 20	 mov	 QWORD PTR next$[rsp], rax

; 166  : 
; 167  : 	/* Free the message pointer if advised to
; 168  : 	 */
; 169  : 	if  (ex->freeMessage == ANTLR3_TRUE)

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  00039	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0003d	83 f8 01	 cmp	 eax, 1
  00040	75 0f		 jne	 SHORT $LN4@antlr3Exce

; 170  : 	{
; 171  : 	    ANTLR3_FREE(ex->message);

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  00047	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@antlr3Exce:

; 172  : 	}
; 173  : 
; 174  : 	/* Call the programmer's custom free routine if advised to
; 175  : 	 */
; 176  : 	if  (ex->freeCustom != NULL)

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  00056	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0005e	74 17		 je	 SHORT $LN5@antlr3Exce

; 177  : 	{
; 178  : 	    ex->freeCustom(ex->custom);

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  00065	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR ex$[rsp]
  00071	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
$LN5@antlr3Exce:

; 179  : 	}
; 180  : 
; 181  : 	/* Free the actual structure itself
; 182  : 	 */
; 183  : 	ANTLR3_FREE(ex);

  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ex$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 184  : 
; 185  : 	ex = next;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR next$[rsp]
  00087	48 89 44 24 40	 mov	 QWORD PTR ex$[rsp], rax

; 186  :     }

  0008c	eb 90		 jmp	 SHORT $LN2@antlr3Exce
$LN3@antlr3Exce:

; 187  : 
; 188  :     return;
; 189  : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
antlr3ExceptionFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3exception.c
;	COMDAT antlr3ExceptionPrint
_TEXT	SEGMENT
ex$ = 48
antlr3ExceptionPrint PROC				; COMDAT

; 119  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
$LN2@antlr3Exce:

; 120  :     /* Ensure valid pointer
; 121  :      */
; 122  :     while   (ex != NULL)

  0001e	48 83 7c 24 30
	00		 cmp	 QWORD PTR ex$[rsp], 0
  00024	74 6b		 je	 SHORT $LN3@antlr3Exce

; 123  :     {
; 124  : 	/* Number if no message, else the message
; 125  : 	 */
; 126  : 	if  (ex->message == NULL)

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR ex$[rsp]
  0002b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00030	75 2c		 jne	 SHORT $LN4@antlr3Exce

; 127  : 	{
; 128  : 	    ANTLR3_FPRINTF(stderr, "ANTLR3_EXCEPTION number %d (%08X).\n", ex->type, ex->type);

  00032	b9 02 00 00 00	 mov	 ecx, 2
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ex$[rsp]
  00042	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ex$[rsp]
  0004a	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08X@
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 fprintf

; 129  : 	}

  0005c	eb 23		 jmp	 SHORT $LN5@antlr3Exce
$LN4@antlr3Exce:

; 130  : 	else
; 131  : 	{
; 132  : 	    ANTLR3_FPRINTF(stderr, "ANTLR3_EXCEPTION: %s\n", (char *)(ex->message));

  0005e	b9 02 00 00 00	 mov	 ecx, 2
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ex$[rsp]
  0006e	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6?$AA@
  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 fprintf
$LN5@antlr3Exce:

; 133  : 	}
; 134  : 
; 135  : 	/* Move to next in the chain (if any)
; 136  : 	 */
; 137  : 	ex = ex->nextException;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR ex$[rsp]
  00086	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0008a	48 89 44 24 30	 mov	 QWORD PTR ex$[rsp], rax

; 138  :     }

  0008f	eb 8d		 jmp	 SHORT $LN2@antlr3Exce
$LN3@antlr3Exce:

; 139  : 
; 140  :     return;
; 141  : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
antlr3ExceptionPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3exception.c
;	COMDAT antlr3ExceptionNew
_TEXT	SEGMENT
ex$ = 32
exception$ = 64
name$ = 72
message$ = 80
freeMessage$ = 88
antlr3ExceptionNew PROC					; COMDAT

; 73   : {

$LN4:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 74   : 	pANTLR3_EXCEPTION	ex;
; 75   : 
; 76   : 	/* Allocate memory for the structure
; 77   : 	*/
; 78   : 	ex	= (pANTLR3_EXCEPTION) ANTLR3_CALLOC(1, sizeof(ANTLR3_EXCEPTION));

  0002b	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0003b	48 89 44 24 20	 mov	 QWORD PTR ex$[rsp], rax

; 79   : 
; 80   : 	/* Check for memory allocation
; 81   : 	*/
; 82   : 	if	(ex == NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR ex$[rsp], 0
  00046	75 04		 jne	 SHORT $LN2@antlr3Exce

; 83   : 	{
; 84   : 		return	NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 5f		 jmp	 SHORT $LN1@antlr3Exce
$LN2@antlr3Exce:

; 85   : 	}
; 86   : 
; 87   : 	ex->name		= name;		/* Install exception name	*/

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00051	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00056	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 88   : 	ex->type		= exception;	/* Install the exception number	*/

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0005f	8b 4c 24 40	 mov	 ecx, DWORD PTR exception$[rsp]
  00063	89 08		 mov	 DWORD PTR [rax], ecx

; 89   : 	ex->message		= message;	/* Install message string	*/

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR message$[rsp]
  0006f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 90   : 
; 91   : 	/* Indicate whether the string should be freed if exception is destroyed    
; 92   : 	*/
; 93   : 	ex->freeMessage	= freeMessage;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00078	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR freeMessage$[rsp]
  0007d	88 48 20	 mov	 BYTE PTR [rax+32], cl

; 94   : 
; 95   : 	/* Install the API
; 96   : 	*/
; 97   : 	ex->print	    =  antlr3ExceptionPrint;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ExceptionPrint
  0008c	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 98   : 	ex->freeEx	    =  antlr3ExceptionFree;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ExceptionFree
  0009f	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 99   : 
; 100  : 	return ex;

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
$LN1@antlr3Exce:

; 101  : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
antlr3ExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00049	e8 00 00 00 00	 call	 _vfprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 838  : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
