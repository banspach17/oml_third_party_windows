; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3BaseRecognizerNew
PUBLIC	antlr3RecognitionExceptionNew
PUBLIC	antlr3MTExceptionNew
PUBLIC	??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedToke@ ; `string'
PUBLIC	??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3R@ ; `string'
PUBLIC	??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionExc@ ; `string'
PUBLIC	??_C@_0BF@BIIJEBMB@Unexpected?5character?$AA@	; `string'
PUBLIC	??_C@_0BB@FKAIECKK@Unexpected?5token?$AA@	; `string'
PUBLIC	??_C@_0BB@DHPGECBL@?9unknown?5source?9?$AA@	; `string'
PUBLIC	??_C@_0BA@IGJLDFLP@Unexpected?5node?$AA@	; `string'
PUBLIC	??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match?8@ ; `string'
PUBLIC	??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8matchA@ ; `string'
PUBLIC	??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8mismat@ ; `string'
PUBLIC	??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedTokenE@ ; `string'
PUBLIC	??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenEx@ ; `string'
PUBLIC	??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI?$AA@	; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI?$AA@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@		; `string'
PUBLIC	??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO?$AA@	; `string'
PUBLIC	??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5?$AA@ ; `string'
PUBLIC	??_C@_09NBGEJOP@?0?5near?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5display@ ; `string'
PUBLIC	??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5?$DM@ ; `string'
PUBLIC	??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5?$CF@ ; `string'
PUBLIC	??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicted@ ; `string'
PUBLIC	??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expecte@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5to@ ; `string'
PUBLIC	??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was?5@ ; `string'
PUBLIC	??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recover@ ; `string'
PUBLIC	??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recover@ ; `string'
PUBLIC	??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recover@ ; `string'
PUBLIC	??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consum@ ; `string'
PUBLIC	??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consum@ ; `string'
PUBLIC	??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alread@ ; `string'
PUBLIC	??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consume@ ; `string'
PUBLIC	??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPre@ ; `string'
PUBLIC	??_C@_09MLMDPBIO@?$DMmissing?5?$AA@		; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3IntTrieNew:PROC
EXTRN	antlr3BitsetNew:PROC
EXTRN	antlr3BitsetLoad:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	antlr3StackNew:PROC
EXTRN	antlr3ExceptionNew:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseRecognizerNew DD imagerel $LN8
	DD	imagerel $LN8+1029
	DD	imagerel $unwind$antlr3BaseRecognizerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RecognitionExceptionNew DD imagerel $LN20
	DD	imagerel $LN20+1114
	DD	imagerel $unwind$antlr3RecognitionExceptionNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3MTExceptionNew DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$antlr3MTExceptionNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginResync DD imagerel beginResync
	DD	imagerel beginResync+72
	DD	imagerel $unwind$beginResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$computeErrorRecoverySet DD imagerel computeErrorRecoverySet
	DD	imagerel computeErrorRecoverySet+54
	DD	imagerel $unwind$computeErrorRecoverySet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endResync DD imagerel endResync
	DD	imagerel endResync+72
	DD	imagerel $unwind$endResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginBacktrack DD imagerel beginBacktrack
	DD	imagerel beginBacktrack+80
	DD	imagerel $unwind$beginBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endBacktrack DD imagerel endBacktrack
	DD	imagerel endBacktrack+91
	DD	imagerel $unwind$endBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match DD	imagerel match
	DD	imagerel match+360
	DD	imagerel $unwind$match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchAny DD imagerel matchAny
	DD	imagerel matchAny+219
	DD	imagerel $unwind$matchAny
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatch DD imagerel mismatch
	DD	imagerel mismatch+343
	DD	imagerel $unwind$mismatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatchIsUnwantedToken DD imagerel mismatchIsUnwantedToken
	DD	imagerel mismatchIsUnwantedToken+122
	DD	imagerel $unwind$mismatchIsUnwantedToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatchIsMissingToken DD imagerel mismatchIsMissingToken
	DD	imagerel mismatchIsMissingToken+337
	DD	imagerel $unwind$mismatchIsMissingToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reportError DD imagerel reportError
	DD	imagerel reportError+180
	DD	imagerel $unwind$reportError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$computeCSRuleFollow DD imagerel computeCSRuleFollow
	DD	imagerel computeCSRuleFollow+54
	DD	imagerel $unwind$computeCSRuleFollow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$combineFollows DD imagerel combineFollows
	DD	imagerel combineFollows+340
	DD	imagerel $unwind$combineFollows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$displayRecognitionError DD imagerel displayRecognitionError
	DD	imagerel displayRecognitionError+2028
	DD	imagerel $unwind$displayRecognitionError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recover DD imagerel recover
	DD	imagerel recover+366
	DD	imagerel $unwind$recover
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedToken DD imagerel recoverFromMismatchedToken
	DD	imagerel recoverFromMismatchedToken+705
	DD	imagerel $unwind$recoverFromMismatchedToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedSet DD imagerel recoverFromMismatchedSet
	DD	imagerel recoverFromMismatchedSet+373
	DD	imagerel $unwind$recoverFromMismatchedSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedElement DD imagerel recoverFromMismatchedElement
	DD	imagerel recoverFromMismatchedElement+425
	DD	imagerel $unwind$recoverFromMismatchedElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeUntil DD imagerel consumeUntil
	DD	imagerel consumeUntil+260
	DD	imagerel $unwind$consumeUntil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeUntilSet DD imagerel consumeUntilSet
	DD	imagerel consumeUntilSet+275
	DD	imagerel $unwind$consumeUntilSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleInvocationStack DD imagerel getRuleInvocationStack
	DD	imagerel getRuleInvocationStack+10
	DD	imagerel $unwind$getRuleInvocationStack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleInvocationStackNamed DD imagerel getRuleInvocationStackNamed
	DD	imagerel getRuleInvocationStackNamed+15
	DD	imagerel $unwind$getRuleInvocationStackNamed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStrings DD imagerel toStrings
	DD	imagerel toStrings+15
	DD	imagerel $unwind$toStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleMemoization DD imagerel getRuleMemoization
	DD	imagerel getRuleMemoization+299
	DD	imagerel $unwind$getRuleMemoization
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$alreadyParsedRule DD imagerel alreadyParsedRule
	DD	imagerel alreadyParsedRule+383
	DD	imagerel $unwind$alreadyParsedRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memoize DD imagerel memoize
	DD	imagerel memoize+468
	DD	imagerel $unwind$memoize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$synpred DD imagerel synpred
	DD	imagerel synpred+344
	DD	imagerel $unwind$synpred
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+296
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeBR DD imagerel freeBR
	DD	imagerel freeBR+317
	DD	imagerel $unwind$freeBR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCurrentInputSymbol DD imagerel getCurrentInputSymbol
	DD	imagerel getCurrentInputSymbol+67
	DD	imagerel $unwind$getCurrentInputSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getMissingSymbol DD imagerel getMissingSymbol
	DD	imagerel getMissingSymbol+534
	DD	imagerel $unwind$getMissingSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getNumberOfSyntaxErrors DD imagerel getNumberOfSyntaxErrors
	DD	imagerel getNumberOfSyntaxErrors+20
	DD	imagerel $unwind$getNumberOfSyntaxErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeIntTrie DD imagerel freeIntTrie
	DD	imagerel freeIntTrie+49
	DD	imagerel $unwind$freeIntTrie
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLMDPBIO@?$DMmissing?5?$AA@
CONST	SEGMENT
??_C@_09MLMDPBIO@?$DMmissing?5?$AA@ DB '<missing ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPre@
CONST	SEGMENT
??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPre@ DB 'Base recogni'
	DB	'zer function ''synPred'' called by unknown parser type - prov'
	DB	'ide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consume@
CONST	SEGMENT
??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consume@ DB 'Base recogniz'
	DB	'er function consumeUntilSet called by unknown parser type - p'
	DB	'rovide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alread@
CONST	SEGMENT
??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alread@ DB 'Base recogni'
	DB	'zer function ''alreadyParsedRule'' called by unknown parser t'
	DB	'ype - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consum@
CONST	SEGMENT
??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consum@ DB 'Base recogni'
	DB	'zer function ''consumeUntilSet'' called by unknown parser typ'
	DB	'e - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consum@
CONST	SEGMENT
??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consum@ DB 'Base recogni'
	DB	'zer function ''consumeUntil'' called by unknown parser type -'
	DB	' provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recover@
CONST	SEGMENT
??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recover@ DB 'Base recogniz'
	DB	'er function recoverFromMismatchedSet called by unknown parser'
	DB	' type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recover@
CONST	SEGMENT
??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recover@ DB 'Base recogniz'
	DB	'er function recoverFromMismatchedToken called by unknown pars'
	DB	'er type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recover@
CONST	SEGMENT
??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recover@ DB 'Base recogniz'
	DB	'er function recover called by unknown parser type - provide o'
	DB	'verride for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6?$AA@ DB ' : synt'
	DB	'ax not recognized...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6?$AA@ DB ' : missing el'
	DB	'ements...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was?5@
CONST	SEGMENT
??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was?5@ DB 'I could '
	DB	'not work out what I was expecting, like so many of us these d'
	DB	'ays!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5to@
CONST	SEGMENT
??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5to@ DB 'Actually '
	DB	'dude, we didn''t seem to be expecting anything here, or at le'
	DB	'ast', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expecte@
CONST	SEGMENT
??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expecte@ DB ' : une'
	DB	'xpected input...', 0aH, '  expected one of : ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicted@
CONST	SEGMENT
??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicted@ DB ' : cannot'
	DB	' match to any predicted input...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6?$AA@ DB ' : expected %'
	DB	's ...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6?$AA@ DB ' : expected <EO'
	DB	'F>', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6?$AA@ DB ' : syntax error..'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6?$AA@
CONST	SEGMENT
??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6?$AA@ DB ' : Missing %s ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6?$AA@ DB ' : Missing <EOF>'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6?$AA@ DB ' '
	DB	': Missing token (%d)...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5?$CF@
CONST	SEGMENT
??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5?$CF@ DB ' : Ex'
	DB	'traneous input - expected %s ...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5?$DM@
CONST	SEGMENT
??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5?$DM@ DB ' : Ex'
	DB	'traneous input - expected <EOF>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4?$AA@ DB ' : Extraneous i'
	DB	'nput...', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5display@
CONST	SEGMENT
??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5display@ DB 'Base recogniz'
	DB	'er function displayRecognitionError called by unknown parser '
	DB	'type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBGEJOP@?0?5near?5?$CFs?$AA@
CONST	SEGMENT
??_C@_09NBGEJOP@?0?5near?5?$CFs?$AA@ DB ', near %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5?$AA@ DB 0aH, '    near'
	DB	' %s', 0aH, '    ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO?$AA@
CONST	SEGMENT
??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO?$AA@ DB '<no text fo'
	DB	'r the token>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO?$AA@
CONST	SEGMENT
??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO?$AA@ DB ', at <EOF>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd?$AA@ DB ', at offset %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs?$AA@ DB ' : error %d : %'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@ DB '%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI?$AA@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI?$AA@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI?$AA@
CONST	SEGMENT
??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI?$AA@ DB '-end of input-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenEx@
CONST	SEGMENT
??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenEx@ DB 'org.antlr.run'
	DB	'time.MissingTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedTokenE@
CONST	SEGMENT
??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedTokenE@ DB 'org.antlr.run'
	DB	'time.UnwantedTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8mismat@
CONST	SEGMENT
??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8mismat@ DB 'Base recogniz'
	DB	'er function ''mismatch'' called by unknown parser type - prov'
	DB	'ide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8matchA@
CONST	SEGMENT
??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8matchA@ DB 'Base recogni'
	DB	'zer function ''matchAny'' called by unknown parser type - pro'
	DB	'vide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match?8@
CONST	SEGMENT
??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match?8@ DB 'Base recogn'
	DB	'izer function ''match'' called by unknown parser type - provi'
	DB	'de override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGJLDFLP@Unexpected?5node?$AA@
CONST	SEGMENT
??_C@_0BA@IGJLDFLP@Unexpected?5node?$AA@ DB 'Unexpected node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHPGECBL@?9unknown?5source?9?$AA@
CONST	SEGMENT
??_C@_0BB@DHPGECBL@?9unknown?5source?9?$AA@ DB '-unknown source-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKAIECKK@Unexpected?5token?$AA@
CONST	SEGMENT
??_C@_0BB@FKAIECKK@Unexpected?5token?$AA@ DB 'Unexpected token', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BIIJEBMB@Unexpected?5character?$AA@
CONST	SEGMENT
??_C@_0BF@BIIJEBMB@Unexpected?5character?$AA@ DB 'Unexpected character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionExc@
CONST	SEGMENT
??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionExc@ DB 'org.antlr.run'
	DB	'time.RecognitionException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3R@
CONST	SEGMENT
??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3R@ DB 'Base recogniz'
	DB	'er function antlr3RecognitionExceptionNew called by unknown p'
	DB	'arser type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedToke@
CONST	SEGMENT
??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedToke@ DB 'org.antlr.run'
	DB	'time.MismatchedTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeIntTrie DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getNumberOfSyntaxErrors DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getMissingSymbol DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCurrentInputSymbol DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeBR DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$synpred DD 022801H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memoize DD 022e01H
	DD	07010f217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alreadyParsedRule DD 022301H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleMemoization DD 022801H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStrings DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleInvocationStackNamed DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleInvocationStack DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeUntilSet DD 022301H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeUntil DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedElement DD 022301H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedSet DD 022301H
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedToken DD 022701H
	DD	0700fb213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recover DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$displayRecognitionError DD 032901H
	DD	01c0112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combineFollows DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$computeCSRuleFollow DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reportError DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatchIsMissingToken DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatchIsUnwantedToken DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatch DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchAny DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match DD 022701H
	DD	0700f9213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endBacktrack DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginBacktrack DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endResync DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$computeErrorRecoverySet DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginResync DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3MTExceptionNew DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RecognitionExceptionNew DD 022401H
	DD	07006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseRecognizerNew DD 022501H
	DD	0700e5212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT freeIntTrie
_TEXT	SEGMENT
trie$ = 48
freeIntTrie PROC					; COMDAT

; 1839 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1840 :     ((pANTLR3_INT_TRIE)trie)->free((pANTLR3_INT_TRIE)trie);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR trie$[rsp]
  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR trie$[rsp]
  00028	ff 50 30	 call	 QWORD PTR [rax+48]

; 1841 : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
freeIntTrie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getNumberOfSyntaxErrors
_TEXT	SEGMENT
recognizer$ = 16
getNumberOfSyntaxErrors PROC				; COMDAT

; 1311 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1312 : 	return	recognizer->state->errorCount;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]

; 1313 : }

  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
getNumberOfSyntaxErrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getMissingSymbol
_TEXT	SEGMENT
ts$ = 32
cts$ = 40
token$ = 48
current$ = 56
text$ = 64
tv173 = 72
recognizer$ = 96
istream$ = 104
e$ = 112
expectedTokenType$ = 120
follow$ = 128
getMissingSymbol PROC					; COMDAT

; 2167 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 2168 : 	pANTLR3_TOKEN_STREAM			ts;
; 2169 : 	pANTLR3_COMMON_TOKEN_STREAM		cts;
; 2170 : 	pANTLR3_COMMON_TOKEN			token;
; 2171 : 	pANTLR3_COMMON_TOKEN			current;
; 2172 : 	pANTLR3_STRING					text;
; 2173 : 
; 2174 : 	// Dereference the standard pointers
; 2175 : 	//
; 2176 : 	ts		= (pANTLR3_TOKEN_STREAM)istream->super;

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR istream$[rsp]
  00032	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00036	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 2177 : 	cts		= (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 44 24 28	 mov	 QWORD PTR cts$[rsp], rax

; 2178 : 	
; 2179 : 	// Work out what to use as the current symbol to make a line and offset etc
; 2180 : 	// If we are at EOF, we use the token before EOF
; 2181 : 	//
; 2182 : 	current	= ts->_LT(ts, 1);

  00049	ba 01 00 00 00	 mov	 edx, 1
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00058	ff 50 28	 call	 QWORD PTR [rax+40]
  0005b	48 89 44 24 38	 mov	 QWORD PTR current$[rsp], rax

; 2183 : 	if	(current->getType(current) == ANTLR3_TOKEN_EOF)

  00060	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00065	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  0006a	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00070	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00073	75 17		 jne	 SHORT $LN2@getMissing

; 2184 : 	{
; 2185 : 		current = ts->_LT(ts, -1);

  00075	ba ff ff ff ff	 mov	 edx, -1
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00084	ff 50 28	 call	 QWORD PTR [rax+40]
  00087	48 89 44 24 38	 mov	 QWORD PTR current$[rsp], rax
$LN2@getMissing:

; 2186 : 	}
; 2187 : 
; 2188 : 	// Create a new empty token
; 2189 : 	//
; 2190 : 	if	(recognizer->state->tokFactory == NULL)

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00091	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00095	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009a	75 1b		 jne	 SHORT $LN3@getMissing

; 2191 : 	{
; 2192 : 		// We don't yet have a token factory for making tokens
; 2193 : 		// we just need a fake one using the input stream of the current
; 2194 : 		// token.
; 2195 : 		//
; 2196 : 		recognizer->state->tokFactory = antlr3TokenFactoryNew(current->input);

  0009c	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  000a1	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a5	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000af	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b3	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN3@getMissing:

; 2197 : 	}
; 2198 : 	token	= recognizer->state->tokFactory->newToken(recognizer->state->tokFactory);

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000bc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000cd	48 89 4c 24 48	 mov	 QWORD PTR tv173[rsp], rcx
  000d2	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000d6	48 8b 44 24 48	 mov	 rax, QWORD PTR tv173[rsp]
  000db	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  000e1	48 89 44 24 30	 mov	 QWORD PTR token$[rsp], rax

; 2199 : 
; 2200 : 	// Set some of the token properties based on the current token
; 2201 : 	//
; 2202 : 	token->setLine					(token, current->getLine(current));

  000e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  000f0	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  000f6	8b d0		 mov	 edx, eax
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  000fd	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00102	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 2203 : 	token->setCharPositionInLine	(token, current->getCharPositionInLine(current));

  00108	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0010d	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  00112	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00118	8b d0		 mov	 edx, eax
  0011a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  0011f	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00124	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 2204 : 	token->setChannel				(token, ANTLR3_TOKEN_DEFAULT_CHANNEL);

  0012a	33 d2		 xor	 edx, edx
  0012c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  00131	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00136	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 2205 : 	token->setType					(token, expectedTokenType);

  0013c	8b 54 24 78	 mov	 edx, DWORD PTR expectedTokenType$[rsp]
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  00145	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  0014a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 2206 :     token->user1                    = current->user1;

  00150	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00155	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0015a	8b 49 58	 mov	 ecx, DWORD PTR [rcx+88]
  0015d	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 2207 :     token->user2                    = current->user2;

  00160	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00165	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0016a	8b 49 5c	 mov	 ecx, DWORD PTR [rcx+92]
  0016d	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 2208 :     token->user3                    = current->user3;

  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00175	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0017a	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  0017d	89 48 60	 mov	 DWORD PTR [rax+96], ecx

; 2209 :     token->custom                   = current->custom;

  00180	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00185	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0018a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0018e	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2210 :     token->lineStart                = current->lineStart;

  00192	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00197	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  0019c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001a0	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2211 :     
; 2212 : 	// Create the token text that shows it has been inserted
; 2213 : 	//
; 2214 : 	token->setText8(token, (pANTLR3_UINT8)"<missing ");

  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MLMDPBIO@?$DMmissing?5?$AA@
  001ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  001b0	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  001b5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2215 : 	text = token->getText(token);

  001bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  001c0	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  001c5	ff 50 78	 call	 QWORD PTR [rax+120]
  001c8	48 89 44 24 40	 mov	 QWORD PTR text$[rsp], rax

; 2216 : 
; 2217 : 	if	(text != NULL)

  001cd	48 83 7c 24 40
	00		 cmp	 QWORD PTR text$[rsp], 0
  001d3	74 36		 je	 SHORT $LN4@getMissing

; 2218 : 	{
; 2219 : 		text->append8(text, (const char *)recognizer->state->tokenNames[expectedTokenType]);

  001d5	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  001da	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001de	8b 4c 24 78	 mov	 ecx, DWORD PTR expectedTokenType$[rsp]
  001e2	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  001e6	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  001ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  001ef	48 8b 44 24 40	 mov	 rax, QWORD PTR text$[rsp]
  001f4	ff 50 38	 call	 QWORD PTR [rax+56]

; 2220 : 		text->append8(text, (const char *)">");

  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PPODPGHN@?$DO?$AA@
  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  00203	48 8b 44 24 40	 mov	 rax, QWORD PTR text$[rsp]
  00208	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@getMissing:

; 2221 : 	}
; 2222 : 	
; 2223 : 	// Finally return the pointer to our new token
; 2224 : 	//
; 2225 : 	return	token;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]

; 2226 : }

  00210	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00214	5f		 pop	 rdi
  00215	c3		 ret	 0
getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getCurrentInputSymbol
_TEXT	SEGMENT
recognizer$ = 48
istream$ = 56
getCurrentInputSymbol PROC				; COMDAT

; 2157 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 2158 : 	return ((pANTLR3_TOKEN_STREAM)istream->super)->_LT((pANTLR3_TOKEN_STREAM)istream->super, 1);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR istream$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	ba 01 00 00 00	 mov	 edx, 1
  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR istream$[rsp]
  00036	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003a	ff 50 28	 call	 QWORD PTR [rax+40]

; 2159 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT freeBR
_TEXT	SEGMENT
thisE$ = 32
tv145 = 40
tv139 = 48
tv135 = 56
recognizer$ = 80
freeBR	PROC						; COMDAT

; 199  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 200  :     pANTLR3_EXCEPTION thisE;
; 201  : 
; 202  : 	// Did we have a state allocated?
; 203  : 	//
; 204  : 	if	(recognizer->state != NULL)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00028	0f 84 fe 00 00
	00		 je	 $LN2@freeBR

; 205  : 	{
; 206  : 		// Free any rule memoization we set up
; 207  : 		//
; 208  : 		if	(recognizer->state->ruleMemo != NULL)

  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0003c	74 38		 je	 SHORT $LN3@freeBR

; 209  : 		{
; 210  : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00043	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0004c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00050	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00054	48 89 4c 24 28	 mov	 QWORD PTR tv145[rsp], rcx
  00059	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv145[rsp]
  00062	ff 50 30	 call	 QWORD PTR [rax+48]

; 211  : 			recognizer->state->ruleMemo = NULL;

  00065	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006e	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN3@freeBR:

; 212  : 		}
; 213  : 
; 214  : 		// Free any exception space we have left around
; 215  : 		//
; 216  : 		thisE = recognizer->state->exception;

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0007b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00083	48 89 44 24 20	 mov	 QWORD PTR thisE$[rsp], rax

; 217  : 		if	(thisE != NULL)

  00088	48 83 7c 24 20
	00		 cmp	 QWORD PTR thisE$[rsp], 0
  0008e	74 10		 je	 SHORT $LN4@freeBR

; 218  : 		{
; 219  : 			thisE->freeEx(thisE);

  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thisE$[rsp]
  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR thisE$[rsp]
  0009a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN4@freeBR:

; 220  : 		}
; 221  : 
; 222  : 		// Free any rewrite streams we have allocated
; 223  : 		//
; 224  : 		if	(recognizer->state->rStreams != NULL)

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a9	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  000b1	74 30		 je	 SHORT $LN5@freeBR

; 225  : 		{
; 226  : 			recognizer->state->rStreams->free(recognizer->state->rStreams);

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c5	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  000cc	48 89 4c 24 30	 mov	 QWORD PTR tv139[rsp], rcx
  000d1	48 8b 88 b0 00
	00 00		 mov	 rcx, QWORD PTR [rax+176]
  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR tv139[rsp]
  000dd	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
$LN5@freeBR:

; 227  : 		}
; 228  : 
; 229  : 		// Free up any token factory we created (error recovery for instance)
; 230  : 		//
; 231  : 		if	(recognizer->state->tokFactory != NULL)

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ec	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f1	74 2a		 je	 SHORT $LN6@freeBR

; 232  : 		{
; 233  : 			recognizer->state->tokFactory->close(recognizer->state->tokFactory);

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00101	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00105	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00109	48 89 4c 24 38	 mov	 QWORD PTR tv135[rsp], rcx
  0010e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00112	48 8b 44 24 38	 mov	 rax, QWORD PTR tv135[rsp]
  00117	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]
$LN6@freeBR:

; 234  : 		}
; 235  : 		// Free the shared state memory
; 236  : 		//
; 237  : 		ANTLR3_FREE(recognizer->state);

  0011d	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00122	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@freeBR:

; 238  : 	}
; 239  : 
; 240  : 	// Free the actual recognizer space
; 241  : 	//
; 242  :     ANTLR3_FREE(recognizer);

  0012c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 243  : }

  00137	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
freeBR	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT reset
_TEXT	SEGMENT
tv148 = 32
tv138 = 40
recognizer$ = 64
reset	PROC						; COMDAT

; 2121 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 2122 :     if	(recognizer->state->following != NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0002c	74 27		 je	 SHORT $LN2@reset

; 2123 :     {
; 2124 : 		recognizer->state->following->free(recognizer->state->following);

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00044	48 89 4c 24 20	 mov	 QWORD PTR tv148[rsp], rcx
  00049	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR tv148[rsp]
  00052	ff 50 10	 call	 QWORD PTR [rax+16]
$LN2@reset:

; 2125 :     }
; 2126 : 
; 2127 : 	// Reset the state flags
; 2128 : 	//
; 2129 : 	recognizer->state->errorRecovery	= ANTLR3_FALSE;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 2130 : 	recognizer->state->lastErrorIndex	= -1;

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00067	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006b	48 c7 40 28 ff
	ff ff ff	 mov	 QWORD PTR [rax+40], -1

; 2131 : 	recognizer->state->failed			= ANTLR3_FALSE;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00078	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007c	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2132 : 	recognizer->state->errorCount		= 0;

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00089	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 2133 : 	recognizer->state->backtracking		= 0;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00095	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00099	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 2134 : 	recognizer->state->following		= NULL;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a9	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2135 : 
; 2136 : 	if	(recognizer->state != NULL)

  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b6	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000bb	74 4e		 je	 SHORT $LN3@reset

; 2137 : 	{
; 2138 : 		if	(recognizer->state->ruleMemo != NULL)

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c6	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000cb	74 3e		 je	 SHORT $LN4@reset

; 2139 : 		{
; 2140 : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000db	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000df	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000e3	48 89 4c 24 28	 mov	 QWORD PTR tv138[rsp], rcx
  000e8	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  000f1	ff 50 30	 call	 QWORD PTR [rax+48]

; 2141 : 			recognizer->state->ruleMemo = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */

  000f4	b9 0f 00 00 00	 mov	 ecx, 15
  000f9	e8 00 00 00 00	 call	 antlr3IntTrieNew
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00103	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00107	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
$LN4@reset:
$LN3@reset:

; 2142 : 		}
; 2143 : 	}
; 2144 : 	
; 2145 : 
; 2146 :     // Install a new following set
; 2147 :     //
; 2148 :     recognizer->state->following   = antlr3StackNew(8);

  0010b	b9 08 00 00 00	 mov	 ecx, 8
  00110	e8 00 00 00 00	 call	 antlr3StackNew
  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0011a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0011e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2149 : 
; 2150 : }

  00122	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00126	5f		 pop	 rdi
  00127	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT synpred
_TEXT	SEGMENT
start$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
ctx$ = 104
predicate$ = 112
synpred	PROC						; COMDAT

; 2056 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 14 00 00 00	 mov	 ecx, 20
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 2057 :     ANTLR3_MARKER   start;
; 2058 :     pANTLR3_PARSER	    parser;
; 2059 :     pANTLR3_TREE_PARSER	    tparser;
; 2060 :     pANTLR3_INT_STREAM	    is;
; 2061 : 
; 2062 :     switch	(recognizer->type)

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00030	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00034	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00039	74 09		 je	 SHORT $LN4@synpred
  0003b	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  00040	74 2c		 je	 SHORT $LN5@synpred
  00042	eb 58		 jmp	 SHORT $LN6@synpred
$LN4@synpred:

; 2063 :     {
; 2064 : 		case	ANTLR3_TYPE_PARSER:
; 2065 : 
; 2066 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 2067 : 			tparser	= NULL;

  00051	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2068 : 			is	= parser->tstream->istream;

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  0005f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00063	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00067	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 2069 : 
; 2070 : 			break;

  0006c	eb 4f		 jmp	 SHORT $LN2@synpred
$LN5@synpred:

; 2071 : 
; 2072 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2073 : 
; 2074 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00076	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 2075 : 			parser	= NULL;

  0007b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2076 : 			is	= tparser->ctnstream->tnstream->istream;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  00089	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00091	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00095	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 2077 : 
; 2078 : 			break;

  0009a	eb 21		 jmp	 SHORT $LN2@synpred
$LN6@synpred:

; 2079 : 
; 2080 : 		default:
; 2081 : 		    
; 2082 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'synPred' called by unknown parser type - provide override for this function\n");

  0009c	b9 02 00 00 00	 mov	 ecx, 2
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPre@
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	e8 00 00 00 00	 call	 fprintf

; 2083 : 			return ANTLR3_FALSE;

  000b6	32 c0		 xor	 al, al
  000b8	e9 95 00 00 00	 jmp	 $LN1@synpred
$LN2@synpred:

; 2084 : 
; 2085 : 			break;
; 2086 :     }
; 2087 : 
; 2088 :     /* Begin backtracking so we can get back to where we started after trying out
; 2089 :      * the syntactic predicate.
; 2090 :      */
; 2091 :     start   = is->mark(is);

  000bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000c2	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000c7	ff 50 38	 call	 QWORD PTR [rax+56]
  000ca	48 89 44 24 20	 mov	 QWORD PTR start$[rsp], rax

; 2092 :     recognizer->state->backtracking++;

  000cf	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d8	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  000db	ff c0		 inc	 eax
  000dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000e2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e6	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 2093 : 
; 2094 :     /* Try the syntactical predicate
; 2095 :      */
; 2096 :     predicate(ctx);

  000e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctx$[rsp]
  000ee	ff 54 24 70	 call	 QWORD PTR predicate$[rsp]

; 2097 : 
; 2098 :     /* Reset
; 2099 :      */
; 2100 :     is->rewind(is, start);

  000f2	48 8b 54 24 20	 mov	 rdx, QWORD PTR start$[rsp]
  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000fc	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  00101	ff 50 48	 call	 QWORD PTR [rax+72]

; 2101 :     recognizer->state->backtracking--;

  00104	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00109	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010d	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00110	ff c8		 dec	 eax
  00112	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00117	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0011b	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 2102 : 
; 2103 :     if	(recognizer->state->failed == ANTLR3_TRUE)

  0011e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00123	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00127	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0012b	83 f8 01	 cmp	 eax, 1
  0012e	75 13		 jne	 SHORT $LN7@synpred

; 2104 :     {
; 2105 : 		/* Predicate failed
; 2106 : 		 */
; 2107 : 		recognizer->state->failed = ANTLR3_FALSE;

  00130	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00135	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00139	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2108 : 		return	ANTLR3_FALSE;

  0013d	32 c0		 xor	 al, al
  0013f	eb 11		 jmp	 SHORT $LN1@synpred

; 2109 :     }

  00141	eb 0f		 jmp	 SHORT $LN8@synpred
$LN7@synpred:

; 2110 :     else
; 2111 :     {
; 2112 : 		/* Predicate was successful
; 2113 : 		 */
; 2114 : 		recognizer->state->failed	= ANTLR3_FALSE;

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00148	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0014c	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2115 : 		return	ANTLR3_TRUE;

  00150	b0 01		 mov	 al, 1
$LN8@synpred:
$LN1@synpred:

; 2116 :     }
; 2117 : }

  00152	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00156	5f		 pop	 rdi
  00157	c3		 ret	 0
synpred	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT memoize
_TEXT	SEGMENT
ruleList$ = 48
entry$ = 56
stopIndex$ = 64
lexer$ = 72
parser$ = 80
tparser$ = 88
is$ = 96
tv65 = 104
tv91 = 112
tv135 = 120
recognizer$ = 144
ruleIndex$ = 152
ruleParseStart$ = 160
memoize	PROC						; COMDAT

; 1990 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]

; 1991 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1992 :      */
; 1993 :     pANTLR3_INT_TRIE	    ruleList;
; 1994 :     pANTLR3_TRIE_ENTRY	    entry;
; 1995 :     ANTLR3_MARKER	    stopIndex;
; 1996 :     pANTLR3_LEXER	    lexer;
; 1997 :     pANTLR3_PARSER	    parser;
; 1998 :     pANTLR3_TREE_PARSER	    tparser;
; 1999 :     pANTLR3_INT_STREAM	    is;
; 2000 : 
; 2001 :     switch	(recognizer->type)

  0002e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00036	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00039	89 44 24 68	 mov	 DWORD PTR tv65[rsp], eax
  0003d	83 7c 24 68 01	 cmp	 DWORD PTR tv65[rsp], 1
  00042	74 74		 je	 SHORT $LN6@memoize
  00044	83 7c 24 68 02	 cmp	 DWORD PTR tv65[rsp], 2
  00049	74 0c		 je	 SHORT $LN4@memoize
  0004b	83 7c 24 68 04	 cmp	 DWORD PTR tv65[rsp], 4
  00050	74 35		 je	 SHORT $LN5@memoize
  00052	e9 96 00 00 00	 jmp	 $LN7@memoize
$LN4@memoize:

; 2002 :     {
; 2003 : 		case	ANTLR3_TYPE_PARSER:
; 2004 : 
; 2005 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00057	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 50	 mov	 QWORD PTR parser$[rsp], rax

; 2006 : 			tparser	= NULL;

  00067	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2007 : 			is	= parser->tstream->istream;

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR parser$[rsp]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007d	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2008 : 
; 2009 : 			break;

  00082	e9 85 00 00 00	 jmp	 $LN2@memoize
$LN5@memoize:

; 2010 : 
; 2011 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2012 : 
; 2013 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00087	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0008f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00092	48 89 44 24 58	 mov	 QWORD PTR tparser$[rsp], rax

; 2014 : 			parser	= NULL;

  00097	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2015 : 			is	= tparser->ctnstream->tnstream->istream;

  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR tparser$[rsp]
  000a5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b1	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2016 : 
; 2017 : 			break;

  000b6	eb 54		 jmp	 SHORT $LN2@memoize
$LN6@memoize:

; 2018 : 
; 2019 : 		case	ANTLR3_TYPE_LEXER:
; 2020 : 
; 2021 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  000b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 89 44 24 48	 mov	 QWORD PTR lexer$[rsp], rax

; 2022 : 			parser	= NULL;

  000c8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2023 : 			tparser	= NULL;

  000d1	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2024 : 			is		= lexer->input->istream;

  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR lexer$[rsp]
  000df	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e6	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2025 : 			break;

  000eb	eb 1f		 jmp	 SHORT $LN2@memoize
$LN7@memoize:

; 2026 : 
; 2027 : 		default:
; 2028 : 		    
; 2029 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function consumeUntilSet called by unknown parser type - provide override for this function\n");

  000ed	b9 02 00 00 00	 mov	 ecx, 2
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consume@
  000ff	48 8b c8	 mov	 rcx, rax
  00102	e8 00 00 00 00	 call	 fprintf

; 2030 : 			return;

  00107	e9 bf 00 00 00	 jmp	 $LN1@memoize
$LN2@memoize:

; 2031 : 
; 2032 : 			break;
; 2033 :     }
; 2034 :     
; 2035 :     stopIndex	= recognizer->state->failed == ANTLR3_TRUE ? MEMO_RULE_FAILED : is->index(is) - 1;

  0010c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00114	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00118	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0011c	83 f8 01	 cmp	 eax, 1
  0011f	75 0c		 jne	 SHORT $LN10@memoize
  00121	b8 fe ff ff ff	 mov	 eax, -2
  00126	48 89 44 24 70	 mov	 QWORD PTR tv91[rsp], rax
  0012b	eb 15		 jmp	 SHORT $LN11@memoize
$LN10@memoize:
  0012d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR is$[rsp]
  00137	ff 50 40	 call	 QWORD PTR [rax+64]
  0013a	48 ff c8	 dec	 rax
  0013d	48 89 44 24 70	 mov	 QWORD PTR tv91[rsp], rax
$LN11@memoize:
  00142	48 8b 44 24 70	 mov	 rax, QWORD PTR tv91[rsp]
  00147	48 89 44 24 40	 mov	 QWORD PTR stopIndex$[rsp], rax

; 2036 : 
; 2037 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  0014c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00154	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00158	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00160	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00164	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00168	48 89 4c 24 78	 mov	 QWORD PTR tv135[rsp], rcx
  0016d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  00175	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00179	48 8b 44 24 78	 mov	 rax, QWORD PTR tv135[rsp]
  0017e	ff 50 18	 call	 QWORD PTR [rax+24]
  00181	48 89 44 24 38	 mov	 QWORD PTR entry$[rsp], rax

; 2038 : 
; 2039 :     if	(entry != NULL)

  00186	48 83 7c 24 38
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0018c	74 3d		 je	 SHORT $LN8@memoize

; 2040 :     {
; 2041 : 		ruleList = (pANTLR3_INT_TRIE)(entry->data.ptr);

  0018e	48 8b 44 24 38	 mov	 rax, QWORD PTR entry$[rsp]
  00193	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00197	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 2042 : 
; 2043 : 		/* If we don't already have this entry, append it. The memoize trie does not
; 2044 : 		 * accept duplicates so it won't add it if already there and we just ignore the
; 2045 : 		 * return code as we don't care if it is there already.
; 2046 : 		 */
; 2047 : 		ruleList->add(ruleList, ruleParseStart, ANTLR3_HASH_TYPE_INT, stopIndex, NULL, NULL);

  0019c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001a5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001ae	4c 8b 4c 24 40	 mov	 r9, QWORD PTR stopIndex$[rsp]
  001b3	45 33 c0	 xor	 r8d, r8d
  001b6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ruleParseStart$[rsp]
  001be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ruleList$[rsp]
  001c3	48 8b 44 24 30	 mov	 rax, QWORD PTR ruleList$[rsp]
  001c8	ff 50 28	 call	 QWORD PTR [rax+40]
$LN8@memoize:
$LN1@memoize:

; 2048 :     }
; 2049 : }

  001cb	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001d2	5f		 pop	 rdi
  001d3	c3		 ret	 0
memoize	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT alreadyParsedRule
_TEXT	SEGMENT
stopIndex$ = 32
lexer$ = 40
parser$ = 48
tparser$ = 56
is$ = 64
tv65 = 72
recognizer$ = 96
ruleIndex$ = 104
alreadyParsedRule PROC					; COMDAT

; 1919 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1920 :     ANTLR3_MARKER			stopIndex;
; 1921 :     pANTLR3_LEXER			lexer;
; 1922 :     pANTLR3_PARSER			parser;
; 1923 :     pANTLR3_TREE_PARSER	    tparser;
; 1924 :     pANTLR3_INT_STREAM	    is;
; 1925 : 
; 1926 :     switch	(recognizer->type)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	89 44 24 48	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 7c 24 48 01	 cmp	 DWORD PTR tv65[rsp], 1
  00034	0f 84 80 00 00
	00		 je	 $LN6@alreadyPar
  0003a	83 7c 24 48 02	 cmp	 DWORD PTR tv65[rsp], 2
  0003f	74 0c		 je	 SHORT $LN4@alreadyPar
  00041	83 7c 24 48 04	 cmp	 DWORD PTR tv65[rsp], 4
  00046	74 3b		 je	 SHORT $LN5@alreadyPar
  00048	e9 9f 00 00 00	 jmp	 $LN7@alreadyPar
$LN4@alreadyPar:

; 1927 :     {
; 1928 : 		case	ANTLR3_TYPE_PARSER:
; 1929 : 
; 1930 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1931 : 			tparser	= NULL;

  0005a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1932 : 			lexer	= NULL;

  00063	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 1933 : 			is	= parser->tstream->istream;

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  00071	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1934 : 
; 1935 : 			break;

  0007e	e9 87 00 00 00	 jmp	 $LN2@alreadyPar
$LN5@alreadyPar:

; 1936 : 
; 1937 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1938 : 
; 1939 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00083	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1940 : 			parser	= NULL;

  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1941 : 			lexer	= NULL;

  00099	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 1942 : 			is	= tparser->ctnstream->tnstream->istream;

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  000a7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ab	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000af	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b3	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1943 : 
; 1944 : 			break;

  000b8	eb 50		 jmp	 SHORT $LN2@alreadyPar
$LN6@alreadyPar:

; 1945 : 
; 1946 : 		case	ANTLR3_TYPE_LEXER:
; 1947 : 
; 1948 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  000ba	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c2	48 89 44 24 28	 mov	 QWORD PTR lexer$[rsp], rax

; 1949 : 			parser	= NULL;

  000c7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1950 : 			tparser	= NULL;

  000d0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1951 : 			is	= lexer->input->istream;

  000d9	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$[rsp]
  000de	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e5	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1952 : 			break;

  000ea	eb 1e		 jmp	 SHORT $LN2@alreadyPar
$LN7@alreadyPar:

; 1953 : 
; 1954 : 		default:
; 1955 : 		    
; 1956 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'alreadyParsedRule' called by unknown parser type - provide override for this function\n");

  000ec	b9 02 00 00 00	 mov	 ecx, 2
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alread@
  000fe	48 8b c8	 mov	 rcx, rax
  00101	e8 00 00 00 00	 call	 fprintf

; 1957 : 			return ANTLR3_FALSE;

  00106	32 c0		 xor	 al, al
  00108	eb 6f		 jmp	 SHORT $LN1@alreadyPar
$LN2@alreadyPar:

; 1958 : 
; 1959 : 			break;
; 1960 :     }
; 1961 : 
; 1962 :     /* See if we have a memo marker for this.
; 1963 :      */
; 1964 :     stopIndex	    = recognizer->getRuleMemoization(recognizer, ruleIndex, is->index(is));

  0010a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00114	ff 50 40	 call	 QWORD PTR [rax+64]
  00117	4c 8b c0	 mov	 r8, rax
  0011a	48 8b 54 24 68	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  0011f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00129	ff 90 e0 00 00
	00		 call	 QWORD PTR [rax+224]
  0012f	48 89 44 24 20	 mov	 QWORD PTR stopIndex$[rsp], rax

; 1965 : 
; 1966 :     if	(stopIndex  == MEMO_RULE_UNKNOWN)

  00134	b8 ff ff ff ff	 mov	 eax, -1
  00139	48 39 44 24 20	 cmp	 QWORD PTR stopIndex$[rsp], rax
  0013e	75 04		 jne	 SHORT $LN8@alreadyPar

; 1967 :     {
; 1968 : 		return ANTLR3_FALSE;

  00140	32 c0		 xor	 al, al
  00142	eb 35		 jmp	 SHORT $LN1@alreadyPar
$LN8@alreadyPar:

; 1969 :     }
; 1970 : 
; 1971 :     if	(stopIndex == MEMO_RULE_FAILED)

  00144	b8 fe ff ff ff	 mov	 eax, -2
  00149	48 39 44 24 20	 cmp	 QWORD PTR stopIndex$[rsp], rax
  0014e	75 0f		 jne	 SHORT $LN9@alreadyPar

; 1972 :     {
; 1973 : 		recognizer->state->failed = ANTLR3_TRUE;

  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00155	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00159	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 1974 :     }

  0015d	eb 18		 jmp	 SHORT $LN10@alreadyPar
$LN9@alreadyPar:

; 1975 :     else
; 1976 :     {
; 1977 : 		is->seek(is, stopIndex+1);

  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR stopIndex$[rsp]
  00164	48 ff c0	 inc	 rax
  00167	48 8b d0	 mov	 rdx, rax
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0016f	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00174	ff 50 60	 call	 QWORD PTR [rax+96]
$LN10@alreadyPar:

; 1978 :     }
; 1979 : 
; 1980 :     /* If here then the rule was executed for this input already
; 1981 :      */
; 1982 :     return  ANTLR3_TRUE;

  00177	b0 01		 mov	 al, 1
$LN1@alreadyPar:

; 1983 : }

  00179	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0017d	5f		 pop	 rdi
  0017e	c3		 ret	 0
alreadyParsedRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleMemoization
_TEXT	SEGMENT
ruleList$ = 48
stopIndex$ = 56
entry$ = 64
tv130 = 72
tv95 = 80
recognizer$ = 112
ruleIndex$ = 120
ruleParseStart$ = 128
getRuleMemoization PROC					; COMDAT

; 1856 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 18 00 00 00	 mov	 ecx, 24
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 1857 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1858 :      */
; 1859 :     pANTLR3_INT_TRIE	ruleList;
; 1860 :     ANTLR3_MARKER	stopIndex;
; 1861 :     pANTLR3_TRIE_ENTRY	entry;
; 1862 : 
; 1863 :     /* See if we have a list in the ruleMemos for this rule, and if not, then create one
; 1864 :      * as we will need it eventually if we are being asked for the memo here.
; 1865 :      */
; 1866 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  00028	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00031	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00036	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0003e	48 89 4c 24 48	 mov	 QWORD PTR tv130[rsp], rcx
  00043	48 8b 54 24 78	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  00048	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR tv130[rsp]
  00051	ff 50 18	 call	 QWORD PTR [rax+24]
  00054	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 1867 : 
; 1868 :     if	(entry == NULL)

  00059	48 83 7c 24 40
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0005f	75 69		 jne	 SHORT $LN2@getRuleMem

; 1869 :     {
; 1870 : 		/* Did not find it, so create a new one for it, with a bit depth based on the 
; 1871 : 		 * size of the input stream. We need the bit depth to incorporate the number if
; 1872 : 		 * bits required to represent the largest possible stop index in the input, which is the
; 1873 : 		 * last character. An int stream is free to return the largest 64 bit offset if it has
; 1874 : 		 * no idea of the size, but you should remember that this will cause the leftmost
; 1875 : 		 * bit match algorithm to run to 63 bits, which will be the whole time spent in the trie ;-)
; 1876 : 		 */
; 1877 : 		ruleList    = antlr3IntTrieNew(63);	/* Depth is theoretically 64 bits, but probably not ;-)	*/

  00061	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00066	e8 00 00 00 00	 call	 antlr3IntTrieNew
  0006b	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 1878 : 
; 1879 : 		if (ruleList != NULL)

  00070	48 83 7c 24 30
	00		 cmp	 QWORD PTR ruleList$[rsp], 0
  00076	74 4b		 je	 SHORT $LN3@getRuleMem

; 1880 : 		{
; 1881 : 			recognizer->state->ruleMemo->add(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex, ANTLR3_HASH_TYPE_STR, 0, ANTLR3_FUNC_PTR(ruleList), freeIntTrie);

  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0007d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00081	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00086	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0008a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0008e	48 89 4c 24 50	 mov	 QWORD PTR tv95[rsp], rcx
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeIntTrie
  0009a	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0009f	48 8b 54 24 30	 mov	 rdx, QWORD PTR ruleList$[rsp]
  000a4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000a9	45 33 c9	 xor	 r9d, r9d
  000ac	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b2	48 8b 54 24 78	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  000b7	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR tv95[rsp]
  000c0	ff 50 28	 call	 QWORD PTR [rax+40]
$LN3@getRuleMem:

; 1882 : 		}
; 1883 : 
; 1884 : 		/* We cannot have a stopIndex in a trie we have just created of course
; 1885 : 		 */
; 1886 : 		return	MEMO_RULE_UNKNOWN;

  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	eb 5b		 jmp	 SHORT $LN1@getRuleMem
$LN2@getRuleMem:

; 1887 :     }
; 1888 : 
; 1889 :     ruleList	= (pANTLR3_INT_TRIE) (entry->data.ptr);

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000cf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d3	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 1890 : 
; 1891 :     /* See if there is a stop index associated with the supplied start index.
; 1892 :      */
; 1893 :     stopIndex	= 0;

  000d8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR stopIndex$[rsp], 0

; 1894 : 
; 1895 :     entry = ruleList->get(ruleList, ruleParseStart);

  000e1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ruleParseStart$[rsp]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ruleList$[rsp]
  000ee	48 8b 44 24 30	 mov	 rax, QWORD PTR ruleList$[rsp]
  000f3	ff 50 18	 call	 QWORD PTR [rax+24]
  000f6	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 1896 :     if (entry != NULL)

  000fb	48 83 7c 24 40
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00101	74 0e		 je	 SHORT $LN4@getRuleMem

; 1897 :     {
; 1898 : 		stopIndex = (ANTLR3_MARKER)(entry->data.intVal);

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00108	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010c	48 89 44 24 38	 mov	 QWORD PTR stopIndex$[rsp], rax
$LN4@getRuleMem:

; 1899 :     }
; 1900 : 
; 1901 :     if	(stopIndex == 0)

  00111	48 83 7c 24 38
	00		 cmp	 QWORD PTR stopIndex$[rsp], 0
  00117	75 07		 jne	 SHORT $LN5@getRuleMem

; 1902 :     {
; 1903 : 		return MEMO_RULE_UNKNOWN;

  00119	b8 ff ff ff ff	 mov	 eax, -1
  0011e	eb 05		 jmp	 SHORT $LN1@getRuleMem
$LN5@getRuleMem:

; 1904 :     }
; 1905 : 
; 1906 :     return  stopIndex;

  00120	48 8b 44 24 38	 mov	 rax, QWORD PTR stopIndex$[rsp]
$LN1@getRuleMem:

; 1907 : }

  00125	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
getRuleMemoization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT toStrings
_TEXT	SEGMENT
recognizer$ = 16
tokens$ = 24
toStrings PROC						; COMDAT

; 1833 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 1834 :     return NULL;

  0000b	33 c0		 xor	 eax, eax

; 1835 : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
toStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleInvocationStackNamed
_TEXT	SEGMENT
recognizer$ = 16
name$ = 24
getRuleInvocationStackNamed PROC			; COMDAT

; 1825 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 1826 :     return NULL;

  0000b	33 c0		 xor	 eax, eax

; 1827 : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getRuleInvocationStackNamed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleInvocationStack
_TEXT	SEGMENT
recognizer$ = 16
getRuleInvocationStack PROC				; COMDAT

; 1819 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1820 :     return NULL;

  00006	33 c0		 xor	 eax, eax

; 1821 : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getRuleInvocationStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT consumeUntilSet
_TEXT	SEGMENT
ttype$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
set$ = 104
consumeUntilSet PROC					; COMDAT

; 1767 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1768 :     ANTLR3_UINT32	    ttype;
; 1769 :     pANTLR3_PARSER	    parser;
; 1770 :     pANTLR3_TREE_PARSER	    tparser;
; 1771 :     pANTLR3_INT_STREAM	    is;
; 1772 : 
; 1773 :     switch	(recognizer->type)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00034	74 09		 je	 SHORT $LN6@consumeUnt
  00036	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003b	74 2c		 je	 SHORT $LN7@consumeUnt
  0003d	eb 58		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1774 :     {
; 1775 : 		case	ANTLR3_TYPE_PARSER:
; 1776 : 
; 1777 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1778 : 			tparser	= NULL;

  0004c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1779 : 			is	= parser->tstream->istream;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1780 : 
; 1781 : 			break;

  00067	eb 4a		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1782 : 
; 1783 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1784 : 
; 1785 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00069	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1786 : 			parser	= NULL;

  00076	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1787 : 			is	= tparser->ctnstream->tnstream->istream;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  00084	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00088	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1788 : 
; 1789 : 			break;

  00095	eb 1c		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1790 : 
; 1791 : 		default:
; 1792 : 		    
; 1793 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntilSet' called by unknown parser type - provide override for this function\n");

  00097	b9 02 00 00 00	 mov	 ecx, 2
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consum@
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 fprintf

; 1794 : 			return;

  000b1	eb 5a		 jmp	 SHORT $LN1@consumeUnt
$LN2@consumeUnt:

; 1795 : 
; 1796 : 			break;
; 1797 :     }
; 1798 : 
; 1799 :     // What do have at the moment?
; 1800 :     //
; 1801 :     ttype	= is->_LA(is, 1);

  000b3	ba 01 00 00 00	 mov	 edx, 1
  000b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000bd	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000c2	ff 50 30	 call	 QWORD PTR [rax+48]
  000c5	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax
$LN4@consumeUnt:

; 1802 : 
; 1803 :     // Start eating tokens until we get to one we want.
; 1804 :     //
; 1805 :     while   (ttype != ANTLR3_TOKEN_EOF && set->isMember(set, ttype) == ANTLR3_FALSE)

  000c9	83 7c 24 20 ff	 cmp	 DWORD PTR ttype$[rsp], -1 ; ffffffffH
  000ce	74 3d		 je	 SHORT $LN5@consumeUnt
  000d0	8b 54 24 20	 mov	 edx, DWORD PTR ttype$[rsp]
  000d4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR set$[rsp]
  000d9	48 8b 44 24 68	 mov	 rax, QWORD PTR set$[rsp]
  000de	ff 50 48	 call	 QWORD PTR [rax+72]
  000e1	0f b6 c0	 movzx	 eax, al
  000e4	85 c0		 test	 eax, eax
  000e6	75 25		 jne	 SHORT $LN5@consumeUnt

; 1806 :     {
; 1807 : 		is->consume(is);

  000e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000f2	ff 50 28	 call	 QWORD PTR [rax+40]

; 1808 : 		ttype	= is->_LA(is, 1);

  000f5	ba 01 00 00 00	 mov	 edx, 1
  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000ff	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  00104	ff 50 30	 call	 QWORD PTR [rax+48]
  00107	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax

; 1809 :     }

  0010b	eb bc		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:
$LN1@consumeUnt:

; 1810 : }

  0010d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
consumeUntilSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT consumeUntil
_TEXT	SEGMENT
ttype$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
tokenType$ = 104
consumeUntil PROC					; COMDAT

; 1717 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1718 :     ANTLR3_UINT32			ttype;
; 1719 :     pANTLR3_PARSER			parser;
; 1720 :     pANTLR3_TREE_PARSER	    tparser;
; 1721 :     pANTLR3_INT_STREAM	    is;
; 1722 : 
; 1723 :     switch	(recognizer->type)

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00027	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002a	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0002e	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00033	74 09		 je	 SHORT $LN6@consumeUnt
  00035	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003a	74 2c		 je	 SHORT $LN7@consumeUnt
  0003c	eb 58		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1724 :     {
; 1725 : 		case	ANTLR3_TYPE_PARSER:
; 1726 : 
; 1727 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1728 : 			tparser	= NULL;

  0004b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1729 : 			is	= parser->tstream->istream;

  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00061	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1730 : 
; 1731 : 			break;

  00066	eb 4a		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1732 : 
; 1733 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1734 : 
; 1735 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00070	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1736 : 			parser	= NULL;

  00075	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1737 : 			is	= tparser->ctnstream->tnstream->istream;

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  00083	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008f	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1738 : 
; 1739 : 			break;

  00094	eb 1c		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1740 : 
; 1741 : 		default:
; 1742 : 		    
; 1743 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntil' called by unknown parser type - provide override for this function\n");

  00096	b9 02 00 00 00	 mov	 ecx, 2
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consum@
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 fprintf

; 1744 : 			return;

  000b0	eb 4c		 jmp	 SHORT $LN1@consumeUnt
$LN2@consumeUnt:

; 1745 : 
; 1746 : 			break;
; 1747 :     }
; 1748 : 
; 1749 :     // What do have at the moment?
; 1750 :     //
; 1751 :     ttype	= is->_LA(is, 1);

  000b2	ba 01 00 00 00	 mov	 edx, 1
  000b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000c1	ff 50 30	 call	 QWORD PTR [rax+48]
  000c4	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax
$LN4@consumeUnt:

; 1752 : 
; 1753 :     // Start eating tokens until we get to the one we want.
; 1754 :     //
; 1755 :     while   (ttype != ANTLR3_TOKEN_EOF && ttype != tokenType)

  000c8	83 7c 24 20 ff	 cmp	 DWORD PTR ttype$[rsp], -1 ; ffffffffH
  000cd	74 2f		 je	 SHORT $LN5@consumeUnt
  000cf	8b 44 24 68	 mov	 eax, DWORD PTR tokenType$[rsp]
  000d3	39 44 24 20	 cmp	 DWORD PTR ttype$[rsp], eax
  000d7	74 25		 je	 SHORT $LN5@consumeUnt

; 1756 :     {
; 1757 : 		is->consume(is);

  000d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000e3	ff 50 28	 call	 QWORD PTR [rax+40]

; 1758 : 		ttype	= is->_LA(is, 1);

  000e6	ba 01 00 00 00	 mov	 edx, 1
  000eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000f5	ff 50 30	 call	 QWORD PTR [rax+48]
  000f8	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax

; 1759 :     }

  000fc	eb ca		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:
$LN1@consumeUnt:

; 1760 : }

  000fe	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
consumeUntil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedElement
_TEXT	SEGMENT
viableToksFollowingRule$ = 32
follow$ = 40
parser$ = 48
tparser$ = 56
is$ = 64
tv65 = 72
recognizer$ = 96
followBits$ = 104
recoverFromMismatchedElement PROC			; COMDAT

; 1620 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1621 :     pANTLR3_BITSET	    viableToksFollowingRule;
; 1622 :     pANTLR3_BITSET	    follow;
; 1623 :     pANTLR3_PARSER	    parser;
; 1624 :     pANTLR3_TREE_PARSER	    tparser;
; 1625 :     pANTLR3_INT_STREAM	    is;
; 1626 : 
; 1627 :     switch	(recognizer->type)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	89 44 24 48	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 7c 24 48 02	 cmp	 DWORD PTR tv65[rsp], 2
  00034	74 09		 je	 SHORT $LN4@recoverFro
  00036	83 7c 24 48 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003b	74 2c		 je	 SHORT $LN5@recoverFro
  0003d	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1628 :     {
; 1629 :     case	ANTLR3_TYPE_PARSER:
; 1630 : 
; 1631 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1632 : 		tparser	= NULL;

  0004c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1633 : 		is	= parser->tstream->istream;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1634 : 
; 1635 : 	break;

  00067	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1636 : 
; 1637 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1638 : 
; 1639 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00069	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1640 : 		parser	= NULL;

  00076	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1641 : 		is	= tparser->ctnstream->tnstream->istream;

  0007f	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00084	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00088	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1642 : 
; 1643 : 	break;

  00095	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1644 : 
; 1645 :     default:
; 1646 : 	    
; 1647 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  00097	b9 02 00 00 00	 mov	 ecx, 2
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recover@
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 fprintf

; 1648 : 		return ANTLR3_FALSE;

  000b1	32 c0		 xor	 al, al
  000b3	e9 eb 00 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1649 : 
; 1650 : 	break;
; 1651 :     }
; 1652 : 
; 1653 :     follow	= antlr3BitsetLoad(followBits);

  000b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR followBits$[rsp]
  000bd	e8 00 00 00 00	 call	 antlr3BitsetLoad
  000c2	48 89 44 24 28	 mov	 QWORD PTR follow$[rsp], rax

; 1654 : 
; 1655 :     if	(follow == NULL)

  000c7	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  000cd	75 07		 jne	 SHORT $LN7@recoverFro

; 1656 :     {
; 1657 : 		/* The follow set is NULL, which means we don't know what can come 
; 1658 : 		 * next, so we "hit and hope" by just signifying that we cannot
; 1659 : 		 * recover, which will just cause the next token to be consumed,
; 1660 : 		 * which might dig us out.
; 1661 : 		 */
; 1662 : 		return	ANTLR3_FALSE;

  000cf	32 c0		 xor	 al, al
  000d1	e9 cd 00 00 00	 jmp	 $LN1@recoverFro
$LN7@recoverFro:

; 1663 :     }
; 1664 : 
; 1665 :     /* We have a bitmap for the follow set, hence we can compute 
; 1666 :      * what can follow this grammar element reference.
; 1667 :      */
; 1668 :     if	(follow->isMember(follow, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_TRUE)

  000d6	ba 01 00 00 00	 mov	 edx, 1
  000db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  000e5	ff 50 48	 call	 QWORD PTR [rax+72]
  000e8	0f b6 c0	 movzx	 eax, al
  000eb	83 f8 01	 cmp	 eax, 1
  000ee	75 34		 jne	 SHORT $LN8@recoverFro

; 1669 :     {
; 1670 : 		/* First we need to know which of the available tokens are viable
; 1671 : 		 * to follow this reference.
; 1672 : 		 */
; 1673 : 		viableToksFollowingRule	= recognizer->computeCSRuleFollow(recognizer);

  000f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000f5	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fa	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00100	48 89 44 24 20	 mov	 QWORD PTR viableToksFollowingRule$[rsp], rax

; 1674 : 
; 1675 : 		/* Remove the EOR token, which we do not wish to compute with
; 1676 : 		 */
; 1677 : 		follow->remove(follow, ANTLR3_EOR_TOKEN_TYPE);

  00105	ba 01 00 00 00	 mov	 edx, 1
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  00114	ff 50 58	 call	 QWORD PTR [rax+88]

; 1678 : 		viableToksFollowingRule->free(viableToksFollowingRule);

  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR viableToksFollowingRule$[rsp]
  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR viableToksFollowingRule$[rsp]
  00121	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@recoverFro:

; 1679 : 		/* We now have the computed set of what can follow the current token
; 1680 : 		 */
; 1681 :     }
; 1682 : 
; 1683 :     /* We can now see if the current token works with the set of tokens
; 1684 :      * that could follow the current grammar reference. If it looks like it
; 1685 :      * is consistent, then we can "insert" that token by not throwing
; 1686 :      * an exception and assuming that we saw it. 
; 1687 :      */
; 1688 :     if	( follow->isMember(follow, is->_LA(is, 1)) == ANTLR3_TRUE)

  00124	ba 01 00 00 00	 mov	 edx, 1
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0012e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00133	ff 50 30	 call	 QWORD PTR [rax+48]
  00136	8b d0		 mov	 edx, eax
  00138	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  0013d	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  00142	ff 50 48	 call	 QWORD PTR [rax+72]
  00145	0f b6 c0	 movzx	 eax, al
  00148	83 f8 01	 cmp	 eax, 1
  0014b	75 3f		 jne	 SHORT $LN9@recoverFro

; 1689 :     {
; 1690 : 		/* report the error, but don't cause any rules to abort and stuff
; 1691 : 		 */
; 1692 : 		recognizer->reportError(recognizer);

  0014d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00152	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00157	ff 50 48	 call	 QWORD PTR [rax+72]

; 1693 : 		if	(follow != NULL)

  0015a	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  00160	74 0d		 je	 SHORT $LN10@recoverFro

; 1694 : 		{
; 1695 : 			follow->free(follow);

  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  0016c	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@recoverFro:

; 1696 : 		}
; 1697 : 		recognizer->state->error			= ANTLR3_FALSE;

  0016f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00174	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00178	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1698 : 		recognizer->state->failed			= ANTLR3_FALSE;

  0017b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00180	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00184	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 1699 : 		return ANTLR3_TRUE;	/* Success in recovery	*/

  00188	b0 01		 mov	 al, 1
  0018a	eb 17		 jmp	 SHORT $LN1@recoverFro
$LN9@recoverFro:

; 1700 :     }
; 1701 : 
; 1702 :     if	(follow != NULL)

  0018c	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  00192	74 0d		 je	 SHORT $LN11@recoverFro

; 1703 :     {
; 1704 : 		follow->free(follow);

  00194	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  00199	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  0019e	ff 50 70	 call	 QWORD PTR [rax+112]
$LN11@recoverFro:

; 1705 :     }
; 1706 : 
; 1707 :     /* We could not find anything viable to do, so this is going to 
; 1708 :      * cause an exception.
; 1709 :      */
; 1710 :     return  ANTLR3_FALSE;

  001a1	32 c0		 xor	 al, al
$LN1@recoverFro:

; 1711 : }

  001a3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001a7	5f		 pop	 rdi
  001a8	c3		 ret	 0
recoverFromMismatchedElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedSet
_TEXT	SEGMENT
parser$ = 48
tparser$ = 56
is$ = 64
matchedSymbol$ = 72
tv65 = 80
recognizer$ = 112
follow$ = 120
recoverFromMismatchedSet PROC				; COMDAT

; 1556 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 1557 :     pANTLR3_PARSER			parser;
; 1558 :     pANTLR3_TREE_PARSER	    tparser;
; 1559 :     pANTLR3_INT_STREAM	    is;
; 1560 : 	pANTLR3_COMMON_TOKEN	matchedSymbol;
; 1561 : 
; 1562 :     switch	(recognizer->type)

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	89 44 24 50	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 7c 24 50 02	 cmp	 DWORD PTR tv65[rsp], 2
  00034	74 09		 je	 SHORT $LN4@recoverFro
  00036	83 7c 24 50 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003b	74 2c		 je	 SHORT $LN5@recoverFro
  0003d	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1563 :     {
; 1564 :     case	ANTLR3_TYPE_PARSER:
; 1565 : 
; 1566 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0003f	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1567 : 		tparser	= NULL;

  0004c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1568 : 		is	= parser->tstream->istream;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1569 : 
; 1570 : 	break;

  00067	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1571 : 
; 1572 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1573 : 
; 1574 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1575 : 		parser	= NULL;

  00076	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1576 : 		is	= tparser->ctnstream->tnstream->istream;

  0007f	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00084	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00088	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1577 : 
; 1578 : 	break;

  00095	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1579 : 
; 1580 :     default:
; 1581 : 	    
; 1582 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedSet called by unknown parser type - provide override for this function\n");

  00097	b9 02 00 00 00	 mov	 ecx, 2
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recover@
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 fprintf

; 1583 : 		return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 b7 00 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1584 : 
; 1585 : 	break;
; 1586 :     }
; 1587 : 
; 1588 : 	if	(recognizer->mismatchIsMissingToken(recognizer, is, follow) == ANTLR3_TRUE)

  000b8	4c 8b 44 24 78	 mov	 r8, QWORD PTR follow$[rsp]
  000bd	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c7	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000cc	ff 50 38	 call	 QWORD PTR [rax+56]
  000cf	0f b6 c0	 movzx	 eax, al
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	75 7d		 jne	 SHORT $LN7@recoverFro

; 1589 : 	{
; 1590 : 		// We can fake the missing token and proceed
; 1591 : 		//
; 1592 : 		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ANTLR3_TOKEN_INVALID, follow);

  000d7	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000dc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR follow$[rsp]
  000e5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ea	45 33 c9	 xor	 r9d, r9d
  000ed	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000f1	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00100	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00106	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1593 : 		recognizer->state->exception->type	= ANTLR3_MISSING_TOKEN_EXCEPTION;

  0010b	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00110	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00114	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00118	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 1594 : 		recognizer->state->exception->token	= matchedSymbol;

  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00123	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00127	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0012b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR matchedSymbol$[rsp]
  00130	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1595 : 
; 1596 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1597 : 		// token in the exception.
; 1598 : 		//
; 1599 : 		recognizer->reportError(recognizer);

  00134	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00139	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0013e	ff 50 48	 call	 QWORD PTR [rax+72]

; 1600 : 
; 1601 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  00141	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00146	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0014a	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1602 : 
; 1603 : 		return	matchedSymbol;

  0014d	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  00152	eb 1b		 jmp	 SHORT $LN1@recoverFro
$LN7@recoverFro:

; 1604 : 	}
; 1605 : 
; 1606 :     // TODO - Single token deletion like in recoverFromMismatchedToken()
; 1607 :     //
; 1608 :     recognizer->state->error	= ANTLR3_TRUE;

  00154	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00159	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0015d	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1609 : 	recognizer->state->failed	= ANTLR3_TRUE;

  00160	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00165	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00169	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 1610 : 	return NULL;

  0016d	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1611 : }

  0016f	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00173	5f		 pop	 rdi
  00174	c3		 ret	 0
recoverFromMismatchedSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedToken
_TEXT	SEGMENT
parser$ = 48
tparser$ = 56
is$ = 64
matchedSymbol$ = 72
tv65 = 80
recognizer$ = 112
ttype$ = 120
follow$ = 128
recoverFromMismatchedToken PROC				; COMDAT

; 1433 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 18 00 00 00	 mov	 ecx, 24
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 1434 : 	pANTLR3_PARSER			  parser;
; 1435 : 	pANTLR3_TREE_PARSER	      tparser;
; 1436 : 	pANTLR3_INT_STREAM	      is;
; 1437 : 	void					* matchedSymbol;
; 1438 : 
; 1439 : 
; 1440 : 
; 1441 : 	switch	(recognizer->type)

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002f	89 44 24 50	 mov	 DWORD PTR tv65[rsp], eax
  00033	83 7c 24 50 02	 cmp	 DWORD PTR tv65[rsp], 2
  00038	74 09		 je	 SHORT $LN4@recoverFro
  0003a	83 7c 24 50 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003f	74 2c		 je	 SHORT $LN5@recoverFro
  00041	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1442 : 	{
; 1443 : 	case	ANTLR3_TYPE_PARSER:
; 1444 : 
; 1445 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00043	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1446 : 		tparser	= NULL;

  00050	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1447 : 		is	= parser->tstream->istream;

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00066	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1448 : 
; 1449 : 		break;

  0006b	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1450 : 
; 1451 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1452 : 
; 1453 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0006d	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1454 : 		parser	= NULL;

  0007a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1455 : 		is	= tparser->ctnstream->tnstream->istream;

  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00094	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1456 : 
; 1457 : 		break;

  00099	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1458 : 
; 1459 : 	default:
; 1460 : 
; 1461 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedToken called by unknown parser type - provide override for this function\n");

  0009b	b9 02 00 00 00	 mov	 ecx, 2
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recover@
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	e8 00 00 00 00	 call	 fprintf

; 1462 : 		return NULL;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 ff 01 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1463 : 
; 1464 : 		break;
; 1465 : 	}
; 1466 : 
; 1467 : 	// Create an exception if we need one
; 1468 : 	//
; 1469 : 	if	(recognizer->state->exception == NULL)

  000bc	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c5	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000ca	75 0a		 jne	 SHORT $LN7@recoverFro

; 1470 : 	{
; 1471 : 		antlr3RecognitionExceptionNew(recognizer);

  000cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000d1	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew
$LN7@recoverFro:

; 1472 : 	}
; 1473 : 
; 1474 : 	// If the next token after the one we are looking at in the input stream
; 1475 : 	// is what we are looking for then we remove the one we have discovered
; 1476 : 	// from the stream by consuming it, then consume this next one along too as
; 1477 : 	// if nothing had happened.
; 1478 : 	//
; 1479 : 	if	( recognizer->mismatchIsUnwantedToken(recognizer, is, ttype) == ANTLR3_TRUE)

  000d6	44 8b 44 24 78	 mov	 r8d, DWORD PTR ttype$[rsp]
  000db	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000e5	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ea	ff 50 30	 call	 QWORD PTR [rax+48]
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	83 f8 01	 cmp	 eax, 1
  000f3	0f 85 e4 00 00
	00		 jne	 $LN8@recoverFro

; 1480 : 	{
; 1481 : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000f9	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fe	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00102	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00106	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 1482 : 		recognizer->state->exception->message	= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  0010c	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00111	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00115	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedTokenE@
  00120	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1483 : 
; 1484 : 		// Call resync hook (for debuggers and so on)
; 1485 : 		//
; 1486 : 		if	(recognizer->debugger != NULL)

  00124	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00129	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0012e	74 18		 je	 SHORT $LN9@recoverFro

; 1487 : 		{
; 1488 : 			recognizer->debugger->beginResync(recognizer->debugger);

  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00135	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00139	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0013e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00142	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
$LN9@recoverFro:

; 1489 : 		}
; 1490 : 
; 1491 : 		// "delete" the extra token
; 1492 : 		//
; 1493 : 		recognizer->beginResync(recognizer);

  00148	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0014d	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00152	ff 50 68	 call	 QWORD PTR [rax+104]

; 1494 : 		is->consume(is);

  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0015a	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0015f	ff 50 28	 call	 QWORD PTR [rax+40]

; 1495 : 		recognizer->endResync(recognizer);

  00162	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00167	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0016c	ff 50 70	 call	 QWORD PTR [rax+112]

; 1496 : 		// End resync hook 
; 1497 : 		//
; 1498 : 		if	(recognizer->debugger != NULL)

  0016f	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00174	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00179	74 18		 je	 SHORT $LN10@recoverFro

; 1499 : 		{
; 1500 : 			recognizer->debugger->endResync(recognizer->debugger);

  0017b	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00180	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00189	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0018d	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
$LN10@recoverFro:

; 1501 : 		}
; 1502 : 
; 1503 : 		// Print out the error after we consume so that ANTLRWorks sees the
; 1504 : 		// token in the exception.
; 1505 : 		//
; 1506 : 		recognizer->reportError(recognizer);

  00193	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00198	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0019d	ff 50 48	 call	 QWORD PTR [rax+72]

; 1507 : 
; 1508 : 		// Return the token we are actually matching
; 1509 : 		//
; 1510 : 		matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  001a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  001a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  001aa	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  001af	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  001b5	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1511 : 
; 1512 : 		// Consume the token that the rule actually expected to get as if everything
; 1513 : 		// was hunky dory.
; 1514 : 		//
; 1515 : 		is->consume(is);

  001ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  001bf	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  001c4	ff 50 28	 call	 QWORD PTR [rax+40]

; 1516 : 
; 1517 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  001c7	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  001cc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001d0	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1518 : 
; 1519 : 		return	matchedSymbol;

  001d3	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  001d8	e9 de 00 00 00	 jmp	 $LN1@recoverFro
$LN8@recoverFro:

; 1520 : 	}
; 1521 : 
; 1522 : 	// Single token deletion (Unwanted above) did not work
; 1523 : 	// so we see if we can insert a token instead by calculating which
; 1524 : 	// token would be missing
; 1525 : 	//
; 1526 : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  001dd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR follow$[rsp]
  001e5	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  001ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  001ef	e8 00 00 00 00	 call	 mismatchIsMissingToken
  001f4	0f b6 c0	 movzx	 eax, al
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 ae 00 00
	00		 je	 $LN11@recoverFro

; 1527 : 	{
; 1528 : 		// We can fake the missing token and proceed
; 1529 : 		//
; 1530 : 		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ttype, follow);

  001ff	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00204	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00208	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR follow$[rsp]
  00210	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00215	44 8b 4c 24 78	 mov	 r9d, DWORD PTR ttype$[rsp]
  0021a	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0021e	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  00223	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00228	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0022d	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00233	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1531 : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  00238	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0023d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00241	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00245	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 1532 : 		recognizer->state->exception->message	= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  0024b	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00250	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00254	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenEx@
  0025f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1533 : 		recognizer->state->exception->token		= matchedSymbol;

  00263	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00268	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0026c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00270	48 8b 4c 24 48	 mov	 rcx, QWORD PTR matchedSymbol$[rsp]
  00275	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1534 : 		recognizer->state->exception->expecting	= ttype;

  00279	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0027e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00282	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00286	8b 4c 24 78	 mov	 ecx, DWORD PTR ttype$[rsp]
  0028a	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 1535 : 
; 1536 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1537 : 		// token in the exception.
; 1538 : 		//
; 1539 : 		recognizer->reportError(recognizer);

  0028d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00292	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00297	ff 50 48	 call	 QWORD PTR [rax+72]

; 1540 : 
; 1541 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  0029a	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0029f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002a3	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1542 : 
; 1543 : 		return	matchedSymbol;

  002a6	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  002ab	eb 0e		 jmp	 SHORT $LN1@recoverFro
$LN11@recoverFro:

; 1544 : 	}
; 1545 : 
; 1546 : 
; 1547 : 	// Neither deleting nor inserting tokens allows recovery
; 1548 : 	// must just report the exception.
; 1549 : 	//
; 1550 : 	recognizer->state->error	    = ANTLR3_TRUE;

  002ad	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  002b2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002b6	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1551 : 	return NULL;

  002b9	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1552 : }

  002bb	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002bf	5f		 pop	 rdi
  002c0	c3		 ret	 0
recoverFromMismatchedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recover
_TEXT	SEGMENT
followSet$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
tv143 = 72
recognizer$ = 96
recover	PROC						; COMDAT

; 1321 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1322 :     // Used to compute the follow set of tokens
; 1323 :     //
; 1324 :     pANTLR3_BITSET			followSet;
; 1325 :     pANTLR3_PARSER			parser;
; 1326 :     pANTLR3_TREE_PARSER	    tparser;
; 1327 :     pANTLR3_INT_STREAM	    is;
; 1328 : 
; 1329 :     switch	(recognizer->type)

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0002a	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002f	74 09		 je	 SHORT $LN4@recover
  00031	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  00036	74 2c		 je	 SHORT $LN5@recover
  00038	eb 58		 jmp	 SHORT $LN6@recover
$LN4@recover:

; 1330 :     {
; 1331 : 		case	ANTLR3_TYPE_PARSER:
; 1332 : 
; 1333 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1334 : 		tparser	= NULL;

  00047	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1335 : 		is		= parser->tstream->istream;

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  00055	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1336 : 
; 1337 : 	break;

  00062	eb 4d		 jmp	 SHORT $LN2@recover
$LN5@recover:

; 1338 : 
; 1339 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1340 : 
; 1341 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1342 : 		parser	= NULL;

  00071	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1343 : 		is		= tparser->ctnstream->tnstream->istream;

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1344 : 
; 1345 : 	break;

  00090	eb 1f		 jmp	 SHORT $LN2@recover
$LN6@recover:

; 1346 : 
; 1347 :     default:
; 1348 : 	    
; 1349 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recover@
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 fprintf

; 1350 : 		return;

  000ac	e9 b7 00 00 00	 jmp	 $LN1@recover
$LN2@recover:

; 1351 : 
; 1352 : 	break;
; 1353 :     }
; 1354 : 
; 1355 : 	// Are we about to repeat the same error?
; 1356 : 	//
; 1357 :     if	(recognizer->state->lastErrorIndex == is->index(is))

  000b1	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ba	48 89 44 24 48	 mov	 QWORD PTR tv143[rsp], rax
  000bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR is$[rsp]
  000c9	ff 52 40	 call	 QWORD PTR [rdx+64]
  000cc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv143[rsp]
  000d1	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000d5	75 0d		 jne	 SHORT $LN7@recover

; 1358 :     {
; 1359 : 		// The last error was at the same token index point. This must be a case
; 1360 : 		// where LT(1) is in the recovery token set so nothing is
; 1361 : 		// consumed. Consume a single token so at least to prevent
; 1362 : 		// an infinite loop; this is a failsafe.
; 1363 : 		//
; 1364 : 		is->consume(is);

  000d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000dc	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000e1	ff 50 28	 call	 QWORD PTR [rax+40]
$LN7@recover:

; 1365 :     }
; 1366 : 
; 1367 :     // Record error index position
; 1368 :     //
; 1369 :     recognizer->state->lastErrorIndex	 = is->index(is);

  000e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000e9	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000ee	ff 50 40	 call	 QWORD PTR [rax+64]
  000f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000f6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000fa	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1370 :     
; 1371 :     // Work out the follows set for error recovery
; 1372 :     //
; 1373 :     followSet	= recognizer->computeErrorRecoverySet(recognizer);

  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00108	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0010e	48 89 44 24 20	 mov	 QWORD PTR followSet$[rsp], rax

; 1374 : 
; 1375 :     // Call resync hook (for debuggers and so on)
; 1376 :     //
; 1377 :     recognizer->beginResync(recognizer);

  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011d	ff 50 68	 call	 QWORD PTR [rax+104]

; 1378 : 
; 1379 :     // Consume tokens until we have resynced to something in the follows set
; 1380 :     //
; 1381 :     recognizer->consumeUntilSet(recognizer, followSet);

  00120	48 8b 54 24 20	 mov	 rdx, QWORD PTR followSet$[rsp]
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0012f	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]

; 1382 : 
; 1383 :     // End resync hook 
; 1384 :     //
; 1385 :     recognizer->endResync(recognizer);

  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0013a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0013f	ff 50 70	 call	 QWORD PTR [rax+112]

; 1386 : 
; 1387 :     // Destroy the temporary bitset we produced.
; 1388 :     //
; 1389 :     followSet->free(followSet);

  00142	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  0014c	ff 50 70	 call	 QWORD PTR [rax+112]

; 1390 : 
; 1391 :     // Reset the inError flag so we don't re-report the exception
; 1392 :     //
; 1393 :     recognizer->state->error	= ANTLR3_FALSE;

  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00154	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00158	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1394 :     recognizer->state->failed	= ANTLR3_FALSE;

  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00160	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00164	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0
$LN1@recover:

; 1395 : }

  00168	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
recover	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT displayRecognitionError
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
ttext$ = 56
ftext$ = 64
ex$ = 72
theToken$ = 80
theBaseTree$ = 88
theCommonTree$ = 96
count$1 = 104
bit$2 = 108
size$3 = 112
numbits$4 = 116
errBits$5 = 120
tv353 = 128
tv351 = 136
tv349 = 144
tv143 = 152
tv344 = 160
tv171 = 168
tv194 = 176
tv213 = 180
tv227 = 184
tv249 = 192
tv273 = 200
tv312 = 208
tv307 = 216
recognizer$ = 240
tokenNames$ = 248
displayRecognitionError PROC				; COMDAT

; 1009 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]

; 1010 : 	pANTLR3_PARSER			parser;
; 1011 : 	pANTLR3_TREE_PARSER	    tparser;
; 1012 : 	pANTLR3_INT_STREAM	    is;
; 1013 : 	pANTLR3_STRING			ttext;
; 1014 : 	pANTLR3_STRING			ftext;
; 1015 : 	pANTLR3_EXCEPTION	    ex;
; 1016 : 	pANTLR3_COMMON_TOKEN    theToken;
; 1017 : 	pANTLR3_BASE_TREE	    theBaseTree;
; 1018 : 	pANTLR3_COMMON_TREE	    theCommonTree;
; 1019 : 
; 1020 : 	// Retrieve some info for easy reading.
; 1021 : 	//
; 1022 : 	ex	    =		recognizer->state->exception;

  00029	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	48 89 44 24 48	 mov	 QWORD PTR ex$[rsp], rax

; 1023 : 	ttext   =		NULL;

  0003e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ttext$[rsp], 0

; 1024 : 
; 1025 : 	// See if there is a 'filename' we can use
; 1026 : 	//
; 1027 : 	if	(ex->streamName == NULL)

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  0004c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00051	75 46		 jne	 SHORT $LN9@displayRec

; 1028 : 	{
; 1029 : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00058	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0005c	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  0005f	75 1c		 jne	 SHORT $LN11@displayRec

; 1030 : 		{
; 1031 : 			ANTLR3_FPRINTF(stderr, "-end of input-(");

  00061	b9 02 00 00 00	 mov	 ecx, 2
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI?$AA@
  00073	48 8b c8	 mov	 rcx, rax
  00076	e8 00 00 00 00	 call	 fprintf

; 1032 : 		}

  0007b	eb 1a		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:

; 1033 : 		else
; 1034 : 		{
; 1035 : 			ANTLR3_FPRINTF(stderr, "-unknown source-(");

  0007d	b9 02 00 00 00	 mov	 ecx, 2
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 fprintf
$LN12@displayRec:

; 1036 : 		}
; 1037 : 	}

  00097	eb 40		 jmp	 SHORT $LN10@displayRec
$LN9@displayRec:

; 1038 : 	else
; 1039 : 	{
; 1040 : 		ftext = ex->streamName->to8(ex->streamName);

  00099	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  0009e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ex$[rsp]
  000a7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000ab	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  000b1	48 89 44 24 40	 mov	 QWORD PTR ftext$[rsp], rax

; 1041 : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  000b6	b9 02 00 00 00	 mov	 ecx, 2
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ftext$[rsp]
  000c6	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ECLNAHEM@?$CFs?$CI?$AA@
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	e8 00 00 00 00	 call	 fprintf
$LN10@displayRec:

; 1042 : 	}
; 1043 : 
; 1044 : 	// Next comes the line number
; 1045 : 	//
; 1046 : 
; 1047 : 	ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000d9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv353[rsp], rax
  000f1	b9 02 00 00 00	 mov	 ecx, 2
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv353[rsp]
  00104	44 8b 41 54	 mov	 r8d, DWORD PTR [rcx+84]
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 fprintf

; 1048 : 	ANTLR3_FPRINTF(stderr, " : error %d : %s", 

  00117	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00123	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00127	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv351[rsp], rax
  0012f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00137	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0013b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0013f	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv349[rsp], rcx
  00147	b9 02 00 00 00	 mov	 ecx, 2
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00152	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv351[rsp]
  0015a	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0015e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv349[rsp]
  00166	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs?$AA@
  00170	48 8b c8	 mov	 rcx, rax
  00173	e8 00 00 00 00	 call	 fprintf

; 1049 : 										recognizer->state->exception->type,
; 1050 : 					(pANTLR3_UINT8)	   (recognizer->state->exception->message));
; 1051 : 
; 1052 : 
; 1053 : 	// How we determine the next piece is dependent on which thing raised the
; 1054 : 	// error.
; 1055 : 	//
; 1056 : 	switch	(recognizer->type)

  00178	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00180	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00183	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv143[rsp], eax
  0018a	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR tv143[rsp], 2
  00192	74 13		 je	 SHORT $LN13@displayRec
  00194	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR tv143[rsp], 4
  0019c	0f 84 1b 01 00
	00		 je	 $LN17@displayRec
  001a2	e9 03 02 00 00	 jmp	 $LN20@displayRec
$LN13@displayRec:

; 1057 : 	{
; 1058 : 	case	ANTLR3_TYPE_PARSER:
; 1059 : 
; 1060 : 		// Prepare the knowledge we know we have
; 1061 : 		//
; 1062 : 		parser	    = (pANTLR3_PARSER) (recognizer->super);

  001a7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 1063 : 		tparser	    = NULL;

  001b7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1064 : 		is			= parser->tstream->istream;

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  001c5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001cd	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 1065 : 		theToken    = (pANTLR3_COMMON_TOKEN)(recognizer->state->exception->token);

  001d2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  001da	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001de	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001e2	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001e6	48 89 44 24 50	 mov	 QWORD PTR theToken$[rsp], rax

; 1066 : 		ttext	    = theToken->toString(theToken);

  001eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR theToken$[rsp]
  001f0	48 8b 44 24 50	 mov	 rax, QWORD PTR theToken$[rsp]
  001f5	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  001fb	48 89 44 24 38	 mov	 QWORD PTR ttext$[rsp], rax

; 1067 : 
; 1068 : 		ANTLR3_FPRINTF(stderr, ", at offset %d", recognizer->state->exception->charPositionInLine);

  00200	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00208	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0020c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00210	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv344[rsp], rax
  00218	b9 02 00 00 00	 mov	 ecx, 2
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00223	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv344[rsp]
  0022b	44 8b 41 58	 mov	 r8d, DWORD PTR [rcx+88]
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd?$AA@
  00236	48 8b c8	 mov	 rcx, rax
  00239	e8 00 00 00 00	 call	 fprintf

; 1069 : 		if  (theToken != NULL)

  0023e	48 83 7c 24 50
	00		 cmp	 QWORD PTR theToken$[rsp], 0
  00244	74 72		 je	 SHORT $LN14@displayRec

; 1070 : 		{
; 1071 : 			if (theToken->type == ANTLR3_TOKEN_EOF)

  00246	48 8b 44 24 50	 mov	 rax, QWORD PTR theToken$[rsp]
  0024b	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  0024e	75 1c		 jne	 SHORT $LN15@displayRec

; 1072 : 			{
; 1073 : 				ANTLR3_FPRINTF(stderr, ", at <EOF>");

  00250	b9 02 00 00 00	 mov	 ecx, 2
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO?$AA@
  00262	48 8b c8	 mov	 rcx, rax
  00265	e8 00 00 00 00	 call	 fprintf

; 1074 : 			}

  0026a	eb 4c		 jmp	 SHORT $LN16@displayRec
$LN15@displayRec:

; 1075 : 			else
; 1076 : 			{
; 1077 : 				// Guard against null text in a token
; 1078 : 				//
; 1079 : 				ANTLR3_FPRINTF(stderr, "\n    near %s\n    ", ttext == NULL ? (pANTLR3_UINT8)"<no text for the token>" : ttext->chars);

  0026c	48 83 7c 24 38
	00		 cmp	 QWORD PTR ttext$[rsp], 0
  00272	75 11		 jne	 SHORT $LN45@displayRec
  00274	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO?$AA@
  0027b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  00283	eb 11		 jmp	 SHORT $LN46@displayRec
$LN45@displayRec:
  00285	48 8b 44 24 38	 mov	 rax, QWORD PTR ttext$[rsp]
  0028a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0028e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN46@displayRec:
  00296	b9 02 00 00 00	 mov	 ecx, 2
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR tv171[rsp]
  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5?$AA@
  002b0	48 8b c8	 mov	 rcx, rax
  002b3	e8 00 00 00 00	 call	 fprintf
$LN16@displayRec:
$LN14@displayRec:

; 1080 : 			}
; 1081 : 		}
; 1082 : 		break;

  002b8	e9 0c 01 00 00	 jmp	 $LN2@displayRec
$LN17@displayRec:

; 1083 : 
; 1084 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1085 : 
; 1086 : 		tparser		= (pANTLR3_TREE_PARSER) (recognizer->super);

  002bd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  002c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c8	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 1087 : 		parser		= NULL;

  002cd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1088 : 		is			= tparser->ctnstream->tnstream->istream;

  002d6	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  002db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002df	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002e3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002e7	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 1089 : 		theBaseTree	= (pANTLR3_BASE_TREE)(recognizer->state->exception->token);

  002ec	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  002f4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002f8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002fc	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00300	48 89 44 24 58	 mov	 QWORD PTR theBaseTree$[rsp], rax

; 1090 : 		ttext		= theBaseTree->toStringTree(theBaseTree);

  00305	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  0030a	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  0030f	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00315	48 89 44 24 38	 mov	 QWORD PTR ttext$[rsp], rax

; 1091 : 
; 1092 : 		if  (theBaseTree != NULL)

  0031a	48 83 7c 24 58
	00		 cmp	 QWORD PTR theBaseTree$[rsp], 0
  00320	0f 84 82 00 00
	00		 je	 $LN18@displayRec

; 1093 : 		{
; 1094 : 			theCommonTree	= (pANTLR3_COMMON_TREE)	    theBaseTree->super;

  00326	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  0032b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032e	48 89 44 24 60	 mov	 QWORD PTR theCommonTree$[rsp], rax

; 1095 : 
; 1096 : 			if	(theCommonTree != NULL)

  00333	48 83 7c 24 60
	00		 cmp	 QWORD PTR theCommonTree$[rsp], 0
  00339	74 12		 je	 SHORT $LN19@displayRec

; 1097 : 			{
; 1098 : 				theToken	= (pANTLR3_COMMON_TOKEN)    theBaseTree->getToken(theBaseTree);

  0033b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  00340	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  00345	ff 50 28	 call	 QWORD PTR [rax+40]
  00348	48 89 44 24 50	 mov	 QWORD PTR theToken$[rsp], rax
$LN19@displayRec:

; 1099 : 			}
; 1100 : 			ANTLR3_FPRINTF(stderr, ", at offset %d", theBaseTree->getCharPositionInLine(theBaseTree));

  0034d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  00352	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  00357	ff 50 68	 call	 QWORD PTR [rax+104]
  0035a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00361	b9 02 00 00 00	 mov	 ecx, 2
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00373	44 8b c1	 mov	 r8d, ecx
  00376	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd?$AA@
  0037d	48 8b c8	 mov	 rcx, rax
  00380	e8 00 00 00 00	 call	 fprintf

; 1101 : 			ANTLR3_FPRINTF(stderr, ", near %s", ttext->chars);

  00385	b9 02 00 00 00	 mov	 ecx, 2
  0038a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00390	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttext$[rsp]
  00395	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NBGEJOP@?0?5near?5?$CFs?$AA@
  003a0	48 8b c8	 mov	 rcx, rax
  003a3	e8 00 00 00 00	 call	 fprintf
$LN18@displayRec:

; 1102 : 		}
; 1103 : 		break;

  003a8	eb 1f		 jmp	 SHORT $LN2@displayRec
$LN20@displayRec:

; 1104 : 
; 1105 : 	default:
; 1106 : 
; 1107 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function displayRecognitionError called by unknown parser type - provide override for this function\n");

  003aa	b9 02 00 00 00	 mov	 ecx, 2
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5display@
  003bc	48 8b c8	 mov	 rcx, rax
  003bf	e8 00 00 00 00	 call	 fprintf

; 1108 : 		return;

  003c4	e9 f0 03 00 00	 jmp	 $LN1@displayRec
$LN2@displayRec:

; 1109 : 		break;
; 1110 : 	}
; 1111 : 
; 1112 : 	// Although this function should generally be provided by the implementation, this one
; 1113 : 	// should be as helpful as possible for grammar developers and serve as an example
; 1114 : 	// of what you can do with each exception type. In general, when you make up your
; 1115 : 	// 'real' handler, you should debug the routine with all possible errors you expect
; 1116 : 	// which will then let you be as specific as possible about all circumstances.
; 1117 : 	//
; 1118 : 	// Note that in the general case, errors thrown by tree parsers indicate a problem
; 1119 : 	// with the output of the parser or with the tree grammar itself. The job of the parser
; 1120 : 	// is to produce a perfect (in traversal terms) syntactically correct tree, so errors
; 1121 : 	// at that stage should really be semantic errors that your own code determines and handles
; 1122 : 	// in whatever way is appropriate.
; 1123 : 	//
; 1124 : 	switch  (ex->type)

  003c9	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  003ce	8b 00		 mov	 eax, DWORD PTR [rax]
  003d0	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  003d7	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  003de	ff c8		 dec	 eax
  003e0	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  003e7	83 bc 24 b4 00
	00 00 09	 cmp	 DWORD PTR tv213[rsp], 9
  003ef	0f 87 aa 03 00
	00		 ja	 $LN43@displayRec
  003f5	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  003fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00403	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN49@displayRec[rcx+rax*4]
  0040a	48 03 c1	 add	 rax, rcx
  0040d	ff e0		 jmp	 rax
$LN21@displayRec:

; 1125 : 	{
; 1126 : 	case	ANTLR3_UNWANTED_TOKEN_EXCEPTION:
; 1127 : 
; 1128 : 		// Indicates that the recognizer was fed a token which seesm to be
; 1129 : 		// spurious input. We can detect this when the token that follows
; 1130 : 		// this unwanted token would normally be part of the syntactically
; 1131 : 		// correct stream. Then we can see that the token we are looking at
; 1132 : 		// is just something that should not be there and throw this exception.
; 1133 : 		//
; 1134 : 		if	(tokenNames == NULL)

  0040f	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  00418	75 1c		 jne	 SHORT $LN22@displayRec

; 1135 : 		{
; 1136 : 			ANTLR3_FPRINTF(stderr, " : Extraneous input...");

  0041a	b9 02 00 00 00	 mov	 ecx, 2
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00425	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4?$AA@
  0042c	48 8b c8	 mov	 rcx, rax
  0042f	e8 00 00 00 00	 call	 fprintf

; 1137 : 		}

  00434	eb 65		 jmp	 SHORT $LN23@displayRec
$LN22@displayRec:

; 1138 : 		else
; 1139 : 		{
; 1140 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  00436	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  0043b	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  0043f	75 1c		 jne	 SHORT $LN24@displayRec

; 1141 : 			{
; 1142 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected <EOF>\n");

  00441	b9 02 00 00 00	 mov	 ecx, 2
  00446	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5?$DM@
  00453	48 8b c8	 mov	 rcx, rax
  00456	e8 00 00 00 00	 call	 fprintf

; 1143 : 			}

  0045b	eb 3e		 jmp	 SHORT $LN25@displayRec
$LN24@displayRec:

; 1144 : 			else
; 1145 : 			{
; 1146 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected %s ...\n", tokenNames[ex->expecting]);

  0045d	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00462	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00465	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  0046d	b9 02 00 00 00	 mov	 ecx, 2
  00472	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00478	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  00480	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv227[rsp]
  00488	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  0048c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5?$CF@
  00493	48 8b c8	 mov	 rcx, rax
  00496	e8 00 00 00 00	 call	 fprintf
$LN25@displayRec:
$LN23@displayRec:

; 1147 : 			}
; 1148 : 		}
; 1149 : 		break;

  0049b	e9 19 03 00 00	 jmp	 $LN4@displayRec
$LN26@displayRec:

; 1150 : 
; 1151 : 	case	ANTLR3_MISSING_TOKEN_EXCEPTION:
; 1152 : 
; 1153 : 		// Indicates that the recognizer detected that the token we just
; 1154 : 		// hit would be valid syntactically if preceeded by a particular 
; 1155 : 		// token. Perhaps a missing ';' at line end or a missing ',' in an
; 1156 : 		// expression list, and such like.
; 1157 : 		//
; 1158 : 		if	(tokenNames == NULL)

  004a0	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  004a9	75 25		 jne	 SHORT $LN27@displayRec

; 1159 : 		{
; 1160 : 			ANTLR3_FPRINTF(stderr, " : Missing token (%d)...\n", ex->expecting);

  004ab	b9 02 00 00 00	 mov	 ecx, 2
  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ex$[rsp]
  004bb	44 8b 41 38	 mov	 r8d, DWORD PTR [rcx+56]
  004bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6?$AA@
  004c6	48 8b c8	 mov	 rcx, rax
  004c9	e8 00 00 00 00	 call	 fprintf

; 1161 : 		}

  004ce	eb 65		 jmp	 SHORT $LN28@displayRec
$LN27@displayRec:

; 1162 : 		else
; 1163 : 		{
; 1164 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  004d0	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  004d5	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  004d9	75 1c		 jne	 SHORT $LN29@displayRec

; 1165 : 			{
; 1166 : 				ANTLR3_FPRINTF(stderr, " : Missing <EOF>\n");

  004db	b9 02 00 00 00	 mov	 ecx, 2
  004e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6?$AA@
  004ed	48 8b c8	 mov	 rcx, rax
  004f0	e8 00 00 00 00	 call	 fprintf

; 1167 : 			}

  004f5	eb 3e		 jmp	 SHORT $LN30@displayRec
$LN29@displayRec:

; 1168 : 			else
; 1169 : 			{
; 1170 : 				ANTLR3_FPRINTF(stderr, " : Missing %s \n", tokenNames[ex->expecting]);

  004f7	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  004fc	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  004ff	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  00507	b9 02 00 00 00	 mov	 ecx, 2
  0050c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00512	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  0051a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv249[rsp]
  00522	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  00526	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6?$AA@
  0052d	48 8b c8	 mov	 rcx, rax
  00530	e8 00 00 00 00	 call	 fprintf
$LN30@displayRec:
$LN28@displayRec:

; 1171 : 			}
; 1172 : 		}
; 1173 : 		break;

  00535	e9 7f 02 00 00	 jmp	 $LN4@displayRec
$LN31@displayRec:

; 1174 : 
; 1175 : 	case	ANTLR3_RECOGNITION_EXCEPTION:
; 1176 : 
; 1177 : 		// Indicates that the recognizer received a token
; 1178 : 		// in the input that was not predicted. This is the basic exception type 
; 1179 : 		// from which all others are derived. So we assume it was a syntax error.
; 1180 : 		// You may get this if there are not more tokens and more are needed
; 1181 : 		// to complete a parse for instance.
; 1182 : 		//
; 1183 : 		ANTLR3_FPRINTF(stderr, " : syntax error...\n");    

  0053a	b9 02 00 00 00	 mov	 ecx, 2
  0053f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00545	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6?$AA@
  0054c	48 8b c8	 mov	 rcx, rax
  0054f	e8 00 00 00 00	 call	 fprintf

; 1184 : 		break;

  00554	e9 60 02 00 00	 jmp	 $LN4@displayRec
$LN32@displayRec:

; 1185 : 
; 1186 : 	case    ANTLR3_MISMATCHED_TOKEN_EXCEPTION:
; 1187 : 
; 1188 : 		// We were expecting to see one thing and got another. This is the
; 1189 : 		// most common error if we coudl not detect a missing or unwanted token.
; 1190 : 		// Here you can spend your efforts to
; 1191 : 		// derive more useful error messages based on the expected
; 1192 : 		// token set and the last token and so on. The error following
; 1193 : 		// bitmaps do a good job of reducing the set that we were looking
; 1194 : 		// for down to something small. Knowing what you are parsing may be
; 1195 : 		// able to allow you to be even more specific about an error.
; 1196 : 		//
; 1197 : 		if	(tokenNames == NULL)

  00559	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  00562	75 1c		 jne	 SHORT $LN33@displayRec

; 1198 : 		{
; 1199 : 			ANTLR3_FPRINTF(stderr, " : syntax error...\n");

  00564	b9 02 00 00 00	 mov	 ecx, 2
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0056f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6?$AA@
  00576	48 8b c8	 mov	 rcx, rax
  00579	e8 00 00 00 00	 call	 fprintf

; 1200 : 		}

  0057e	eb 65		 jmp	 SHORT $LN34@displayRec
$LN33@displayRec:

; 1201 : 		else
; 1202 : 		{
; 1203 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  00580	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00585	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  00589	75 1c		 jne	 SHORT $LN35@displayRec

; 1204 : 			{
; 1205 : 				ANTLR3_FPRINTF(stderr, " : expected <EOF>\n");

  0058b	b9 02 00 00 00	 mov	 ecx, 2
  00590	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00596	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6?$AA@
  0059d	48 8b c8	 mov	 rcx, rax
  005a0	e8 00 00 00 00	 call	 fprintf

; 1206 : 			}

  005a5	eb 3e		 jmp	 SHORT $LN36@displayRec
$LN35@displayRec:

; 1207 : 			else
; 1208 : 			{
; 1209 : 				ANTLR3_FPRINTF(stderr, " : expected %s ...\n", tokenNames[ex->expecting]);

  005a7	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  005ac	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  005af	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  005b7	b9 02 00 00 00	 mov	 ecx, 2
  005bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  005ca	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv273[rsp]
  005d2	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  005d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6?$AA@
  005dd	48 8b c8	 mov	 rcx, rax
  005e0	e8 00 00 00 00	 call	 fprintf
$LN36@displayRec:
$LN34@displayRec:

; 1210 : 			}
; 1211 : 		}
; 1212 : 		break;

  005e5	e9 cf 01 00 00	 jmp	 $LN4@displayRec
$LN37@displayRec:

; 1213 : 
; 1214 : 	case	ANTLR3_NO_VIABLE_ALT_EXCEPTION:
; 1215 : 
; 1216 : 		// We could not pick any alt decision from the input given
; 1217 : 		// so god knows what happened - however when you examine your grammar,
; 1218 : 		// you should. It means that at the point where the current token occurred
; 1219 : 		// that the DFA indicates nowhere to go from here.
; 1220 : 		//
; 1221 : 		ANTLR3_FPRINTF(stderr, " : cannot match to any predicted input...\n");

  005ea	b9 02 00 00 00	 mov	 ecx, 2
  005ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicted@
  005fc	48 8b c8	 mov	 rcx, rax
  005ff	e8 00 00 00 00	 call	 fprintf

; 1222 : 
; 1223 : 		break;

  00604	e9 b0 01 00 00	 jmp	 $LN4@displayRec
$LN38@displayRec:

; 1224 : 
; 1225 : 	case	ANTLR3_MISMATCHED_SET_EXCEPTION:
; 1226 : 
; 1227 : 		{
; 1228 : 			ANTLR3_UINT32	  count;
; 1229 : 			ANTLR3_UINT32	  bit;
; 1230 : 			ANTLR3_UINT32	  size;
; 1231 : 			ANTLR3_UINT32	  numbits;
; 1232 : 			pANTLR3_BITSET	  errBits;
; 1233 : 
; 1234 : 			// This means we were able to deal with one of a set of
; 1235 : 			// possible tokens at this point, but we did not see any
; 1236 : 			// member of that set.
; 1237 : 			//
; 1238 : 			ANTLR3_FPRINTF(stderr, " : unexpected input...\n  expected one of : ");

  00609	b9 02 00 00 00	 mov	 ecx, 2
  0060e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00614	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expecte@
  0061b	48 8b c8	 mov	 rcx, rax
  0061e	e8 00 00 00 00	 call	 fprintf

; 1239 : 
; 1240 : 			// What tokens could we have accepted at this point in the
; 1241 : 			// parse?
; 1242 : 			//
; 1243 : 			count   = 0;

  00623	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR count$1[rsp], 0

; 1244 : 			errBits = antlr3BitsetLoad		(ex->expectingSet);

  0062b	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00630	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00634	e8 00 00 00 00	 call	 antlr3BitsetLoad
  00639	48 89 44 24 78	 mov	 QWORD PTR errBits$5[rsp], rax

; 1245 : 			numbits = errBits->numBits		(errBits);

  0063e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR errBits$5[rsp]
  00643	48 8b 44 24 78	 mov	 rax, QWORD PTR errBits$5[rsp]
  00648	ff 50 50	 call	 QWORD PTR [rax+80]
  0064b	89 44 24 74	 mov	 DWORD PTR numbits$4[rsp], eax

; 1246 : 			size    = errBits->size			(errBits);

  0064f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR errBits$5[rsp]
  00654	48 8b 44 24 78	 mov	 rax, QWORD PTR errBits$5[rsp]
  00659	ff 50 28	 call	 QWORD PTR [rax+40]
  0065c	89 44 24 70	 mov	 DWORD PTR size$3[rsp], eax

; 1247 : 
; 1248 : 			if  (size > 0)

  00660	83 7c 24 70 00	 cmp	 DWORD PTR size$3[rsp], 0
  00665	0f 86 e2 00 00
	00		 jbe	 $LN39@displayRec

; 1249 : 			{
; 1250 : 				// However many tokens we could have dealt with here, it is usually
; 1251 : 				// not useful to print ALL of the set here. I arbitrarily chose 8
; 1252 : 				// here, but you should do whatever makes sense for you of course.
; 1253 : 				// No token number 0, so look for bit 1 and on.
; 1254 : 				//
; 1255 : 				for	(bit = 1; bit < numbits && count < 8 && count < size; bit++)

  0066b	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR bit$2[rsp], 1
  00673	eb 0a		 jmp	 SHORT $LN8@displayRec
$LN6@displayRec:
  00675	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  00679	ff c0		 inc	 eax
  0067b	89 44 24 6c	 mov	 DWORD PTR bit$2[rsp], eax
$LN8@displayRec:
  0067f	8b 44 24 74	 mov	 eax, DWORD PTR numbits$4[rsp]
  00683	39 44 24 6c	 cmp	 DWORD PTR bit$2[rsp], eax
  00687	0f 83 a4 00 00
	00		 jae	 $LN7@displayRec
  0068d	83 7c 24 68 08	 cmp	 DWORD PTR count$1[rsp], 8
  00692	0f 83 99 00 00
	00		 jae	 $LN7@displayRec
  00698	8b 44 24 70	 mov	 eax, DWORD PTR size$3[rsp]
  0069c	39 44 24 68	 cmp	 DWORD PTR count$1[rsp], eax
  006a0	0f 83 8b 00 00
	00		 jae	 $LN7@displayRec

; 1256 : 				{
; 1257 : 					// TODO: This doesn;t look right - should be asking if the bit is set!!
; 1258 : 					//
; 1259 : 					if  (tokenNames[bit])

  006a6	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  006aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  006b2	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  006b7	74 73		 je	 SHORT $LN41@displayRec

; 1260 : 					{
; 1261 : 						ANTLR3_FPRINTF(stderr, "%s%s", count > 0 ? ", " : "", tokenNames[bit]); 

  006b9	83 7c 24 68 00	 cmp	 DWORD PTR count$1[rsp], 0
  006be	76 11		 jbe	 SHORT $LN47@displayRec
  006c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
  006c7	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
  006cf	eb 0f		 jmp	 SHORT $LN48@displayRec
$LN47@displayRec:
  006d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  006d8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
$LN48@displayRec:
  006e0	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  006e4	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv307[rsp], rax
  006ec	b9 02 00 00 00	 mov	 ecx, 2
  006f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f7	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  006ff	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv307[rsp]
  00707	4c 8b 0c d1	 mov	 r9, QWORD PTR [rcx+rdx*8]
  0070b	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR tv312[rsp]
  00713	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0071a	48 8b c8	 mov	 rcx, rax
  0071d	e8 00 00 00 00	 call	 fprintf

; 1262 : 						count++;

  00722	8b 44 24 68	 mov	 eax, DWORD PTR count$1[rsp]
  00726	ff c0		 inc	 eax
  00728	89 44 24 68	 mov	 DWORD PTR count$1[rsp], eax
$LN41@displayRec:

; 1263 : 					}
; 1264 : 				}

  0072c	e9 44 ff ff ff	 jmp	 $LN6@displayRec
$LN7@displayRec:

; 1265 : 				ANTLR3_FPRINTF(stderr, "\n");

  00731	b9 02 00 00 00	 mov	 ecx, 2
  00736	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0073c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00743	48 8b c8	 mov	 rcx, rax
  00746	e8 00 00 00 00	 call	 fprintf

; 1266 : 			}

  0074b	eb 34		 jmp	 SHORT $LN40@displayRec
$LN39@displayRec:

; 1267 : 			else
; 1268 : 			{
; 1269 : 				ANTLR3_FPRINTF(stderr, "Actually dude, we didn't seem to be expecting anything here, or at least\n");

  0074d	b9 02 00 00 00	 mov	 ecx, 2
  00752	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00758	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5to@
  0075f	48 8b c8	 mov	 rcx, rax
  00762	e8 00 00 00 00	 call	 fprintf

; 1270 : 				ANTLR3_FPRINTF(stderr, "I could not work out what I was expecting, like so many of us these days!\n");

  00767	b9 02 00 00 00	 mov	 ecx, 2
  0076c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00772	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was?5@
  00779	48 8b c8	 mov	 rcx, rax
  0077c	e8 00 00 00 00	 call	 fprintf
$LN40@displayRec:

; 1271 : 			}
; 1272 : 		}
; 1273 : 		break;

  00781	eb 36		 jmp	 SHORT $LN4@displayRec
$LN42@displayRec:

; 1274 : 
; 1275 : 	case	ANTLR3_EARLY_EXIT_EXCEPTION:
; 1276 : 
; 1277 : 		// We entered a loop requiring a number of token sequences
; 1278 : 		// but found a token that ended that sequence earlier than
; 1279 : 		// we should have done.
; 1280 : 		//
; 1281 : 		ANTLR3_FPRINTF(stderr, " : missing elements...\n");

  00783	b9 02 00 00 00	 mov	 ecx, 2
  00788	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0078e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6?$AA@
  00795	48 8b c8	 mov	 rcx, rax
  00798	e8 00 00 00 00	 call	 fprintf

; 1282 : 		break;

  0079d	eb 1a		 jmp	 SHORT $LN4@displayRec
$LN43@displayRec:

; 1283 : 
; 1284 : 	default:
; 1285 : 
; 1286 : 		// We don't handle any other exceptions here, but you can
; 1287 : 		// if you wish. If we get an exception that hits this point
; 1288 : 		// then we are just going to report what we know about the
; 1289 : 		// token.
; 1290 : 		//
; 1291 : 		ANTLR3_FPRINTF(stderr, " : syntax not recognized...\n");

  0079f	b9 02 00 00 00	 mov	 ecx, 2
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6?$AA@
  007b1	48 8b c8	 mov	 rcx, rax
  007b4	e8 00 00 00 00	 call	 fprintf
$LN4@displayRec:
$LN1@displayRec:

; 1292 : 		break;
; 1293 : 	}
; 1294 : 
; 1295 : 	// Here you have the token that was in error which if this is
; 1296 : 	// the standard implementation will tell you the line and offset
; 1297 : 	// and also record the address of the start of the line in the
; 1298 : 	// input stream. You could therefore print the source line and so on.
; 1299 : 	// Generally though, I would expect that your lexer/parser will keep
; 1300 : 	// its own map of lines and source pointers or whatever as there
; 1301 : 	// are a lot of specific things you need to know about the input
; 1302 : 	// to do something like that.
; 1303 : 	// Here is where you do it though :-).
; 1304 : 	//
; 1305 : }

  007b9	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  007c0	5f		 pop	 rdi
  007c1	c3		 ret	 0
  007c2	66 90		 npad	 2
$LN49@displayRec:
  007c4	00 00 00 00	 DD	 $LN31@displayRec
  007c8	00 00 00 00	 DD	 $LN32@displayRec
  007cc	00 00 00 00	 DD	 $LN37@displayRec
  007d0	00 00 00 00	 DD	 $LN38@displayRec
  007d4	00 00 00 00	 DD	 $LN42@displayRec
  007d8	00 00 00 00	 DD	 $LN43@displayRec
  007dc	00 00 00 00	 DD	 $LN43@displayRec
  007e0	00 00 00 00	 DD	 $LN43@displayRec
  007e4	00 00 00 00	 DD	 $LN21@displayRec
  007e8	00 00 00 00	 DD	 $LN26@displayRec
displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT combineFollows
_TEXT	SEGMENT
followSet$ = 32
localFollowSet$ = 40
top$ = 48
i$ = 52
tv143 = 56
tv140 = 64
recognizer$ = 96
exact$ = 104
combineFollows PROC					; COMDAT

; 948  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 949  :     pANTLR3_BITSET	followSet;
; 950  :     pANTLR3_BITSET	localFollowSet;
; 951  :     ANTLR3_UINT32	top;
; 952  :     ANTLR3_UINT32	i;
; 953  : 
; 954  :     top	= recognizer->state->following->size(recognizer->state->following);

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00030	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00034	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00038	48 89 4c 24 38	 mov	 QWORD PTR tv143[rsp], rcx
  0003d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00041	48 8b 44 24 38	 mov	 rax, QWORD PTR tv143[rsp]
  00046	ff 50 30	 call	 QWORD PTR [rax+48]
  00049	89 44 24 30	 mov	 DWORD PTR top$[rsp], eax

; 955  : 
; 956  :     followSet	    = antlr3BitsetNew(0);

  0004d	33 c9		 xor	 ecx, ecx
  0004f	e8 00 00 00 00	 call	 antlr3BitsetNew
  00054	48 89 44 24 20	 mov	 QWORD PTR followSet$[rsp], rax

; 957  : 	localFollowSet	= NULL;

  00059	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR localFollowSet$[rsp], 0

; 958  : 
; 959  :     for (i = top; i>0; i--)

  00062	8b 44 24 30	 mov	 eax, DWORD PTR top$[rsp]
  00066	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  0006a	eb 0a		 jmp	 SHORT $LN4@combineFol
$LN2@combineFol:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00070	ff c8		 dec	 eax
  00072	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@combineFol:
  00076	83 7c 24 34 00	 cmp	 DWORD PTR i$[rsp], 0
  0007b	0f 86 b3 00 00
	00		 jbe	 $LN3@combineFol

; 960  :     {
; 961  : 		localFollowSet = antlr3BitsetLoad((pANTLR3_BITSET_LIST) recognizer->state->following->get(recognizer->state->following, i-1));

  00081	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00085	ff c8		 dec	 eax
  00087	8b c0		 mov	 eax, eax
  00089	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0008e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00092	48 8b 54 24 60	 mov	 rdx, QWORD PTR recognizer$[rsp]
  00097	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0009b	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0009f	48 89 54 24 40	 mov	 QWORD PTR tv140[rsp], rdx
  000a4	8b d0		 mov	 edx, eax
  000a6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR tv140[rsp]
  000af	ff 50 20	 call	 QWORD PTR [rax+32]
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 antlr3BitsetLoad
  000ba	48 89 44 24 28	 mov	 QWORD PTR localFollowSet$[rsp], rax

; 962  : 
; 963  : 		if  (localFollowSet != NULL)

  000bf	48 83 7c 24 28
	00		 cmp	 QWORD PTR localFollowSet$[rsp], 0
  000c5	74 68		 je	 SHORT $LN5@combineFol

; 964  : 		{
; 965  : 			followSet->borInPlace(followSet, localFollowSet);

  000c7	48 8b 54 24 28	 mov	 rdx, QWORD PTR localFollowSet$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  000d6	ff 50 20	 call	 QWORD PTR [rax+32]

; 966  : 
; 967  : 			if	(exact == ANTLR3_TRUE)

  000d9	0f b6 44 24 68	 movzx	 eax, BYTE PTR exact$[rsp]
  000de	83 f8 01	 cmp	 eax, 1
  000e1	75 36		 jne	 SHORT $LN6@combineFol

; 968  : 			{
; 969  : 				if	(localFollowSet->isMember(localFollowSet, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_FALSE)

  000e3	ba 01 00 00 00	 mov	 edx, 1
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  000f2	ff 50 48	 call	 QWORD PTR [rax+72]
  000f5	0f b6 c0	 movzx	 eax, al
  000f8	85 c0		 test	 eax, eax
  000fa	75 1b		 jne	 SHORT $LN7@combineFol

; 970  : 				{
; 971  : 					// Only leave EOR in the set if at top (start rule); this lets us know
; 972  : 					// if we have to include the follow(start rule); I.E., EOF
; 973  : 					//
; 974  : 					if	(i>1)

  000fc	83 7c 24 34 01	 cmp	 DWORD PTR i$[rsp], 1
  00101	76 12		 jbe	 SHORT $LN9@combineFol

; 975  : 					{
; 976  : 						followSet->remove(followSet, ANTLR3_EOR_TOKEN_TYPE);

  00103	ba 01 00 00 00	 mov	 edx, 1
  00108	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  00112	ff 50 58	 call	 QWORD PTR [rax+88]
$LN9@combineFol:

; 977  : 					}
; 978  : 				}

  00115	eb 02		 jmp	 SHORT $LN8@combineFol
$LN7@combineFol:

; 979  : 				else
; 980  : 				{
; 981  : 					break;	// Cannot see End Of Rule from here, just drop out

  00117	eb 1b		 jmp	 SHORT $LN3@combineFol
$LN8@combineFol:
$LN6@combineFol:

; 982  : 				}
; 983  : 			}
; 984  : 			localFollowSet->free(localFollowSet);

  00119	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  0011e	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  00123	ff 50 70	 call	 QWORD PTR [rax+112]

; 985  : 			localFollowSet = NULL;

  00126	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR localFollowSet$[rsp], 0
$LN5@combineFol:

; 986  : 		}
; 987  :     }

  0012f	e9 38 ff ff ff	 jmp	 $LN2@combineFol
$LN3@combineFol:

; 988  : 
; 989  : 	if	(localFollowSet != NULL)

  00134	48 83 7c 24 28
	00		 cmp	 QWORD PTR localFollowSet$[rsp], 0
  0013a	74 0d		 je	 SHORT $LN10@combineFol

; 990  : 	{
; 991  : 		localFollowSet->free(localFollowSet);

  0013c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  00146	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@combineFol:

; 992  : 	}
; 993  :     return  followSet;

  00149	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]

; 994  : }

  0014e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
combineFollows ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT computeCSRuleFollow
_TEXT	SEGMENT
recognizer$ = 48
computeCSRuleFollow PROC				; COMDAT

; 940  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 941  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 942  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
computeCSRuleFollow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT reportError
_TEXT	SEGMENT
tv129 = 32
recognizer$ = 64
reportError PROC					; COMDAT

; 722  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 723  :     	// Invoke the debugger event if there is a debugger listening to us
; 724  : 	//
; 725  : 	if	(recognizer->debugger != NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 2f		 je	 SHORT $LN2@reportErro

; 726  : 	{
; 727  : 		recognizer->debugger->recognitionException(recognizer->debugger, recognizer->state->exception);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00038	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR tv129[rsp], rcx
  00041	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0004a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv129[rsp]
  00053	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
$LN2@reportErro:

; 728  : 	}
; 729  : 
; 730  :     if	(recognizer->state->errorRecovery == ANTLR3_TRUE)

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00066	83 f8 01	 cmp	 eax, 1
  00069	75 02		 jne	 SHORT $LN3@reportErro

; 731  :     {
; 732  : 		// Already in error recovery so don't display another error while doing so
; 733  : 		//
; 734  : 		return;

  0006b	eb 41		 jmp	 SHORT $LN1@reportErro
$LN3@reportErro:

; 735  :     }
; 736  : 
; 737  :     // Signal we are in error recovery now
; 738  :     //
; 739  :     recognizer->state->errorRecovery = ANTLR3_TRUE;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00072	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00076	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1

; 740  : 	
; 741  : 	// Indicate this recognizer had an error while processing.
; 742  : 	//
; 743  : 	recognizer->state->errorCount++;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00086	ff c0		 inc	 eax
  00088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0008d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00091	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 744  : 
; 745  : 	// Call the error display routine
; 746  : 	//
; 747  :     recognizer->displayRecognitionError(recognizer, recognizer->state->tokenNames);

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00099	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009d	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ab	ff 50 50	 call	 QWORD PTR [rax+80]
$LN1@reportErro:

; 748  : }

  000ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatchIsMissingToken
_TEXT	SEGMENT
retcode$ = 32
followClone$ = 40
viableTokensFollowingThisRule$ = 48
recognizer$ = 80
is$ = 88
follow$ = 96
mismatchIsMissingToken PROC				; COMDAT

; 553  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 554  : 	ANTLR3_BOOLEAN	retcode;
; 555  : 	pANTLR3_BITSET	followClone;
; 556  : 	pANTLR3_BITSET	viableTokensFollowingThisRule;
; 557  : 
; 558  : 	if	(follow == NULL)

  00028	48 83 7c 24 60
	00		 cmp	 QWORD PTR follow$[rsp], 0
  0002e	75 07		 jne	 SHORT $LN2@mismatchIs

; 559  : 	{
; 560  : 		// There is no information about the tokens that can follow the last one
; 561  : 		// hence we must say that the current one we found is not a member of the 
; 562  : 		// follow set and does not indicate a missing token. We will just consume this
; 563  : 		// single token and see if the parser works it out from there.
; 564  : 		//
; 565  : 		return	ANTLR3_FALSE;

  00030	32 c0		 xor	 al, al
  00032	e9 14 01 00 00	 jmp	 $LN1@mismatchIs
$LN2@mismatchIs:

; 566  : 	}
; 567  : 
; 568  : 	followClone						= NULL;

  00037	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR followClone$[rsp], 0

; 569  : 	viableTokensFollowingThisRule	= NULL;

  00040	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR viableTokensFollowingThisRule$[rsp], 0

; 570  : 
; 571  : 	// The C bitset maps are laid down at compile time by the
; 572  : 	// C code generation. Hence we cannot remove things from them
; 573  : 	// and so on. So, in order to remove EOR (if we need to) then
; 574  : 	// we clone the static bitset.
; 575  : 	//
; 576  : 	followClone = antlr3BitsetLoad(follow);

  00049	48 8b 4c 24 60	 mov	 rcx, QWORD PTR follow$[rsp]
  0004e	e8 00 00 00 00	 call	 antlr3BitsetLoad
  00053	48 89 44 24 28	 mov	 QWORD PTR followClone$[rsp], rax

; 577  : 	if	(followClone == NULL)

  00058	48 83 7c 24 28
	00		 cmp	 QWORD PTR followClone$[rsp], 0
  0005e	75 07		 jne	 SHORT $LN3@mismatchIs

; 578  : 	{
; 579  : 		return ANTLR3_FALSE;

  00060	32 c0		 xor	 al, al
  00062	e9 e4 00 00 00	 jmp	 $LN1@mismatchIs
$LN3@mismatchIs:

; 580  : 	}
; 581  : 
; 582  : 	// Compute what can follow this grammar reference
; 583  : 	//
; 584  : 	if	(followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE))

  00067	ba 01 00 00 00	 mov	 edx, 1
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  00076	ff 50 48	 call	 QWORD PTR [rax+72]
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	74 4f		 je	 SHORT $LN4@mismatchIs

; 585  : 	{
; 586  : 		// EOR can follow, but if we are not the start symbol, we
; 587  : 		// need to remove it.
; 588  : 		//
; 589  : 		if	(recognizer->state->following->vector->count >= 0)

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00089	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00094	72 12		 jb	 SHORT $LN5@mismatchIs

; 590  : 		{
; 591  : 			followClone->remove(followClone, ANTLR3_EOR_TOKEN_TYPE);

  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000a5	ff 50 58	 call	 QWORD PTR [rax+88]
$LN5@mismatchIs:

; 592  : 		}
; 593  : 
; 594  : 		// Now compute the visiable tokens that can follow this rule, according to context
; 595  : 		// and make them part of the follow set.
; 596  : 		//
; 597  : 		viableTokensFollowingThisRule = recognizer->computeCSRuleFollow(recognizer);

  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b2	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000b8	48 89 44 24 30	 mov	 QWORD PTR viableTokensFollowingThisRule$[rsp], rax

; 598  : 		followClone->borInPlace(followClone, viableTokensFollowingThisRule);

  000bd	48 8b 54 24 30	 mov	 rdx, QWORD PTR viableTokensFollowingThisRule$[rsp]
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000cc	ff 50 20	 call	 QWORD PTR [rax+32]
$LN4@mismatchIs:

; 599  : 	}
; 600  : 
; 601  : 	/// if current token is consistent with what could come after set
; 602  : 	/// then we know we're missing a token; error recovery is free to
; 603  : 	/// "insert" the missing token
; 604  : 	///
; 605  : 	/// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
; 606  : 	/// in follow set to indicate that the fall of the start symbol is
; 607  : 	/// in the set (EOF can follow).
; 608  : 	///
; 609  : 	if	(		followClone->isMember(followClone, is->_LA(is, 1))
; 610  : 			||	followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE)

  000cf	ba 01 00 00 00	 mov	 edx, 1
  000d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR is$[rsp]
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR is$[rsp]
  000de	ff 50 30	 call	 QWORD PTR [rax+48]
  000e1	8b d0		 mov	 edx, eax
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000ed	ff 50 48	 call	 QWORD PTR [rax+72]
  000f0	0f b6 c0	 movzx	 eax, al
  000f3	85 c0		 test	 eax, eax
  000f5	75 19		 jne	 SHORT $LN8@mismatchIs
  000f7	ba 01 00 00 00	 mov	 edx, 1
  000fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  00101	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  00106	ff 50 48	 call	 QWORD PTR [rax+72]
  00109	0f b6 c0	 movzx	 eax, al
  0010c	85 c0		 test	 eax, eax
  0010e	74 07		 je	 SHORT $LN6@mismatchIs
$LN8@mismatchIs:

; 611  : 		)
; 612  : 	{
; 613  : 		retcode = ANTLR3_TRUE;

  00110	c6 44 24 20 01	 mov	 BYTE PTR retcode$[rsp], 1

; 614  : 	}

  00115	eb 05		 jmp	 SHORT $LN7@mismatchIs
$LN6@mismatchIs:

; 615  : 	else
; 616  : 	{
; 617  : 		retcode	= ANTLR3_FALSE;

  00117	c6 44 24 20 00	 mov	 BYTE PTR retcode$[rsp], 0
$LN7@mismatchIs:

; 618  : 	}
; 619  : 
; 620  : 	if	(viableTokensFollowingThisRule != NULL)

  0011c	48 83 7c 24 30
	00		 cmp	 QWORD PTR viableTokensFollowingThisRule$[rsp], 0
  00122	74 0d		 je	 SHORT $LN9@mismatchIs

; 621  : 	{
; 622  : 		viableTokensFollowingThisRule->free(viableTokensFollowingThisRule);

  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR viableTokensFollowingThisRule$[rsp]
  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR viableTokensFollowingThisRule$[rsp]
  0012e	ff 50 70	 call	 QWORD PTR [rax+112]
$LN9@mismatchIs:

; 623  : 	}
; 624  : 	if	(followClone != NULL)

  00131	48 83 7c 24 28
	00		 cmp	 QWORD PTR followClone$[rsp], 0
  00137	74 0d		 je	 SHORT $LN10@mismatchIs

; 625  : 	{
; 626  : 		followClone->free(followClone);

  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  0013e	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  00143	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@mismatchIs:

; 627  : 	}
; 628  : 
; 629  : 	return retcode;

  00146	0f b6 44 24 20	 movzx	 eax, BYTE PTR retcode$[rsp]
$LN1@mismatchIs:

; 630  : 
; 631  : }

  0014b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0014f	5f		 pop	 rdi
  00150	c3		 ret	 0
mismatchIsMissingToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatchIsUnwantedToken
_TEXT	SEGMENT
nextt$ = 32
recognizer$ = 64
is$ = 72
ttype$ = 80
mismatchIsUnwantedToken PROC				; COMDAT

; 530  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 531  : 	ANTLR3_UINT32 nextt;
; 532  : 
; 533  : 	nextt = is->_LA(is, 2);

  00028	ba 02 00 00 00	 mov	 edx, 2
  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  00037	ff 50 30	 call	 QWORD PTR [rax+48]
  0003a	89 44 24 20	 mov	 DWORD PTR nextt$[rsp], eax

; 534  : 
; 535  : 	if	(nextt == ttype)

  0003e	8b 44 24 50	 mov	 eax, DWORD PTR ttype$[rsp]
  00042	39 44 24 20	 cmp	 DWORD PTR nextt$[rsp], eax
  00046	75 2a		 jne	 SHORT $LN2@mismatchIs

; 536  : 	{
; 537  : 		if	(recognizer->state->exception != NULL)

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0004d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00051	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00056	74 14		 je	 SHORT $LN4@mismatchIs

; 538  : 		{
; 539  : 			recognizer->state->exception->expecting = nextt;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00061	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00065	8b 4c 24 20	 mov	 ecx, DWORD PTR nextt$[rsp]
  00069	89 48 38	 mov	 DWORD PTR [rax+56], ecx
$LN4@mismatchIs:

; 540  : 		}
; 541  : 		return ANTLR3_TRUE;		// This token is unknown, but the next one is the one we wanted

  0006c	b0 01		 mov	 al, 1
  0006e	eb 04		 jmp	 SHORT $LN1@mismatchIs

; 542  : 	}

  00070	eb 02		 jmp	 SHORT $LN3@mismatchIs
$LN2@mismatchIs:

; 543  : 	else
; 544  : 	{
; 545  : 		return ANTLR3_FALSE;	// Neither this token, nor the one following is the one we wanted

  00072	32 c0		 xor	 al, al
$LN3@mismatchIs:
$LN1@mismatchIs:

; 546  : 	}
; 547  : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
mismatchIsUnwantedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatch
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
tv69 = 56
recognizer$ = 80
ttype$ = 88
follow$ = 96
mismatch PROC						; COMDAT

; 643  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 644  :     pANTLR3_PARSER	    parser;
; 645  :     pANTLR3_TREE_PARSER	    tparser;
; 646  :     pANTLR3_INT_STREAM	    is;
; 647  : 
; 648  :     // Install a mismatched token exception in the exception stack
; 649  :     //
; 650  :     antlr3MTExceptionNew(recognizer);

  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0002c	e8 00 00 00 00	 call	 antlr3MTExceptionNew

; 651  :     recognizer->state->exception->expecting    = ttype;

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00036	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003e	8b 4c 24 58	 mov	 ecx, DWORD PTR ttype$[rsp]
  00042	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 652  : 
; 653  :     switch	(recognizer->type)

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0004a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004d	89 44 24 38	 mov	 DWORD PTR tv69[rsp], eax
  00051	83 7c 24 38 02	 cmp	 DWORD PTR tv69[rsp], 2
  00056	74 02		 je	 SHORT $LN4@mismatch
  00058	eb 2a		 jmp	 SHORT $LN5@mismatch
$LN4@mismatch:

; 654  :     {
; 655  : 		case	ANTLR3_TYPE_PARSER:
; 656  : 
; 657  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 658  : 			tparser	= NULL;

  00067	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 659  : 			is	= parser->tstream->istream;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007d	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 660  : 
; 661  : 			break;

  00082	eb 1f		 jmp	 SHORT $LN2@mismatch
$LN5@mismatch:

; 662  : 
; 663  : 		default:
; 664  : 		    
; 665  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'mismatch' called by unknown parser type - provide override for this function\n");

  00084	b9 02 00 00 00	 mov	 ecx, 2
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8mismat@
  00096	48 8b c8	 mov	 rcx, rax
  00099	e8 00 00 00 00	 call	 fprintf

; 666  : 			return;

  0009e	e9 ae 00 00 00	 jmp	 $LN1@mismatch
$LN2@mismatch:

; 667  : 
; 668  : 			break;
; 669  :     }
; 670  : 
; 671  : 	if	(mismatchIsUnwantedToken(recognizer, is, ttype))

  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR ttype$[rsp]
  000a8	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000b2	e8 00 00 00 00	 call	 mismatchIsUnwantedToken
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	85 c0		 test	 eax, eax
  000bc	74 37		 je	 SHORT $LN6@mismatch

; 672  : 	{
; 673  : 		// Create a basic recognition exception structure
; 674  : 		//
; 675  : 	    antlr3RecognitionExceptionNew(recognizer);

  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c3	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 676  : 		
; 677  : 		// Now update it to indicate this is an unwanted token exception
; 678  : 		//
; 679  : 		recognizer->state->exception->name		= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000cd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedTokenE@
  000dc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 680  : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000e0	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ed	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 681  : 
; 682  : 		return;

  000f3	eb 5c		 jmp	 SHORT $LN1@mismatch
$LN6@mismatch:

; 683  : 	}
; 684  : 	
; 685  : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  000f5	4c 8b 44 24 60	 mov	 r8, QWORD PTR follow$[rsp]
  000fa	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00104	e8 00 00 00 00	 call	 mismatchIsMissingToken
  00109	0f b6 c0	 movzx	 eax, al
  0010c	85 c0		 test	 eax, eax
  0010e	74 37		 je	 SHORT $LN7@mismatch

; 686  : 	{
; 687  : 		// Create a basic recognition exception structure
; 688  : 		//
; 689  : 	    antlr3RecognitionExceptionNew(recognizer);

  00110	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00115	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 690  : 		
; 691  : 		// Now update it to indicate this is an unwanted token exception
; 692  : 		//
; 693  : 		recognizer->state->exception->name		= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00123	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenEx@
  0012e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 694  : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00137	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013f	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 695  : 
; 696  : 		return;

  00145	eb 0a		 jmp	 SHORT $LN1@mismatch
$LN7@mismatch:

; 697  : 	}
; 698  : 
; 699  : 	// Just a mismatched token is all we can dtermine
; 700  : 	//
; 701  : 	antlr3MTExceptionNew(recognizer);

  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0014c	e8 00 00 00 00	 call	 antlr3MTExceptionNew
$LN1@mismatch:

; 702  : 
; 703  : 	return;
; 704  : }

  00151	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00155	5f		 pop	 rdi
  00156	c3		 ret	 0
mismatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT matchAny
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
tv65 = 56
recognizer$ = 80
matchAny PROC						; COMDAT

; 490  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 491  :     pANTLR3_PARSER	    parser;
; 492  :     pANTLR3_TREE_PARSER	    tparser;
; 493  :     pANTLR3_INT_STREAM	    is;
; 494  : 
; 495  :     switch	(recognizer->type)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	89 44 24 38	 mov	 DWORD PTR tv65[rsp], eax
  0002a	83 7c 24 38 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002f	74 09		 je	 SHORT $LN4@matchAny
  00031	83 7c 24 38 04	 cmp	 DWORD PTR tv65[rsp], 4
  00036	74 2c		 je	 SHORT $LN5@matchAny
  00038	eb 58		 jmp	 SHORT $LN6@matchAny
$LN4@matchAny:

; 496  :     {
; 497  : 		case	ANTLR3_TYPE_PARSER:
; 498  : 
; 499  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0003a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 500  : 			tparser	= NULL;

  00047	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 501  : 			is	= parser->tstream->istream;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  00055	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 502  : 
; 503  : 			break;

  00062	eb 4a		 jmp	 SHORT $LN2@matchAny
$LN5@matchAny:

; 504  : 
; 505  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 506  : 
; 507  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 508  : 			parser	= NULL;

  00071	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 509  : 			is	= tparser->ctnstream->tnstream->istream;

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 510  : 
; 511  : 			break;

  00090	eb 1c		 jmp	 SHORT $LN2@matchAny
$LN6@matchAny:

; 512  : 
; 513  : 		default:
; 514  : 		    
; 515  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'matchAny' called by unknown parser type - provide override for this function\n");

  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8matchA@
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 fprintf

; 516  : 			return;

  000ac	eb 27		 jmp	 SHORT $LN1@matchAny
$LN2@matchAny:

; 517  : 
; 518  : 		break;
; 519  :     }
; 520  :     recognizer->state->errorRecovery	= ANTLR3_FALSE;

  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b7	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 521  :     recognizer->state->failed		    = ANTLR3_FALSE;

  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c4	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 522  :     is->consume(is);

  000c8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000d2	ff 50 28	 call	 QWORD PTR [rax+40]
$LN1@matchAny:

; 523  : 
; 524  :     return;
; 525  : }

  000d5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT match
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
matchedSymbol$ = 56
tv65 = 64
recognizer$ = 96
ttype$ = 104
follow$ = 112
match	PROC						; COMDAT

; 417  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 14 00 00 00	 mov	 ecx, 20
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 418  :     pANTLR3_PARSER			parser;
; 419  :     pANTLR3_TREE_PARSER	    tparser;
; 420  :     pANTLR3_INT_STREAM	    is;
; 421  : 	void					* matchedSymbol;
; 422  : 
; 423  :     switch	(recognizer->type)

  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002f	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00033	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00038	74 09		 je	 SHORT $LN4@match
  0003a	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0003f	74 2c		 je	 SHORT $LN5@match
  00041	eb 58		 jmp	 SHORT $LN6@match
$LN4@match:

; 424  :     {
; 425  : 		case	ANTLR3_TYPE_PARSER:
; 426  : 
; 427  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 428  : 			tparser	= NULL;

  00050	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 429  : 			is	= parser->tstream->istream;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00066	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 430  : 
; 431  : 			break;

  0006b	eb 4f		 jmp	 SHORT $LN2@match
$LN5@match:

; 432  : 
; 433  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 434  : 
; 435  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 436  : 			parser	= NULL;

  0007a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 437  : 			is	= tparser->ctnstream->tnstream->istream;

  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00094	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 438  : 
; 439  : 			break;

  00099	eb 21		 jmp	 SHORT $LN2@match
$LN6@match:

; 440  : 
; 441  : 		default:
; 442  : 		    
; 443  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'match' called by unknown parser type - provide override for this function\n");

  0009b	b9 02 00 00 00	 mov	 ecx, 2
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match?8@
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	e8 00 00 00 00	 call	 fprintf

; 444  : 			return ANTLR3_FALSE;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 a6 00 00 00	 jmp	 $LN1@match
$LN2@match:

; 445  : 
; 446  : 			break;
; 447  :     }
; 448  : 
; 449  : 	// Pick up the current input token/node for assignment to labels
; 450  : 	//
; 451  : 	matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  000bc	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  000c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000cb	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  000d1	48 89 44 24 38	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 452  : 
; 453  :     if	(is->_LA(is, 1) == ttype)

  000d6	ba 01 00 00 00	 mov	 edx, 1
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000e5	ff 50 30	 call	 QWORD PTR [rax+48]
  000e8	3b 44 24 68	 cmp	 eax, DWORD PTR ttype$[rsp]
  000ec	75 2e		 jne	 SHORT $LN7@match

; 454  :     {
; 455  : 		// The token was the one we were told to expect
; 456  : 		//
; 457  : 		is->consume(is);									// Consume that token from the stream

  000ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000f8	ff 50 28	 call	 QWORD PTR [rax+40]

; 458  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;	// Not in error recovery now (if we were)

  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00100	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00104	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 459  : 		recognizer->state->failed			= ANTLR3_FALSE;	// The match was a success

  00108	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00111	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 460  : 		return matchedSymbol;								// We are done

  00115	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  0011a	eb 46		 jmp	 SHORT $LN1@match
$LN7@match:

; 461  :     }
; 462  : 
; 463  :     // We did not find the expected token type, if we are backtracking then
; 464  :     // we just set the failed flag and return.
; 465  :     //
; 466  :     if	(recognizer->state->backtracking > 0)

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00121	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00125	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00129	7e 14		 jle	 SHORT $LN8@match

; 467  :     {
; 468  : 		// Backtracking is going on
; 469  : 		//
; 470  : 		recognizer->state->failed  = ANTLR3_TRUE;

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00130	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00134	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 471  : 		return matchedSymbol;

  00138	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  0013d	eb 23		 jmp	 SHORT $LN1@match
$LN8@match:

; 472  : 	}
; 473  : 
; 474  :     // We did not find the expected token and there is no backtracking
; 475  :     // going on, so we mismatch, which creates an exception in the recognizer exception
; 476  :     // stack.
; 477  :     //
; 478  : 	matchedSymbol = recognizer->recoverFromMismatchedToken(recognizer, ttype, follow);

  0013f	4c 8b 44 24 70	 mov	 r8, QWORD PTR follow$[rsp]
  00144	8b 54 24 68	 mov	 edx, DWORD PTR ttype$[rsp]
  00148	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0014d	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00152	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00158	48 89 44 24 38	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 479  :     return matchedSymbol;

  0015d	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
$LN1@match:

; 480  : }

  00162	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00166	5f		 pop	 rdi
  00167	c3		 ret	 0
match	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT endBacktrack
_TEXT	SEGMENT
recognizer$ = 48
level$ = 56
successful$ = 64
endBacktrack PROC					; COMDAT

; 761  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 762  : 	if	(recognizer->debugger != NULL)

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00031	74 22		 je	 SHORT $LN2@endBacktra

; 763  : 	{
; 764  : 		recognizer->debugger->endBacktrack(recognizer->debugger, level, successful);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00038	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003c	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR successful$[rsp]
  00042	8b 54 24 38	 mov	 edx, DWORD PTR level$[rsp]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0004b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004f	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
$LN2@endBacktra:

; 765  : 	}
; 766  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT beginBacktrack
_TEXT	SEGMENT
recognizer$ = 48
level$ = 56
beginBacktrack PROC					; COMDAT

; 752  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 753  : 	if	(recognizer->debugger != NULL)

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00027	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0002c	74 1c		 je	 SHORT $LN2@beginBackt

; 754  : 	{
; 755  : 		recognizer->debugger->beginBacktrack(recognizer->debugger, level);

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00033	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00037	8b 54 24 38	 mov	 edx, DWORD PTR level$[rsp]
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00040	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00044	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
$LN2@beginBackt:

; 756  : 	}
; 757  : }

  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT endResync
_TEXT	SEGMENT
recognizer$ = 48
endResync PROC						; COMDAT

; 778  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 779  : 	if	(recognizer->debugger != NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 18		 je	 SHORT $LN2@endResync

; 780  : 	{
; 781  : 		recognizer->debugger->endResync(recognizer->debugger);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00038	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003c	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
$LN2@endResync:

; 782  : 	}
; 783  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT computeErrorRecoverySet
_TEXT	SEGMENT
recognizer$ = 48
computeErrorRecoverySet PROC				; COMDAT

; 880  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 881  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 882  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
computeErrorRecoverySet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT beginResync
_TEXT	SEGMENT
recognizer$ = 48
beginResync PROC					; COMDAT

; 769  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 770  : 	if	(recognizer->debugger != NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 18		 je	 SHORT $LN2@beginResyn

; 771  : 	{
; 772  : 		recognizer->debugger->beginResync(recognizer->debugger);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00038	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003c	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
$LN2@beginResyn:

; 773  : 	}
; 774  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3MTExceptionNew
_TEXT	SEGMENT
recognizer$ = 48
antlr3MTExceptionNew PROC				; COMDAT

; 255  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 256  :     /* Create a basic recognition exception structure
; 257  :      */
; 258  :     antlr3RecognitionExceptionNew(recognizer);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00023	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 259  : 
; 260  :     /* Now update it to indicate this is a Mismatched token exception
; 261  :      */
; 262  :     recognizer->state->exception->name		= ANTLR3_MISMATCHED_EX_NAME;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00031	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedToke@
  0003c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 263  :     recognizer->state->exception->type		= ANTLR3_MISMATCHED_TOKEN_EXCEPTION;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 264  : 
; 265  :     return;
; 266  : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
antlr3MTExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3RecognitionExceptionNew
_TEXT	SEGMENT
ex$ = 32
lexer$ = 40
parser$ = 48
tparser$ = 56
ins$ = 64
is$ = 72
cts$ = 80
tns$ = 88
tnode$1 = 96
tv65 = 104
tv92 = 108
tv253 = 112
tv243 = 120
recognizer$ = 144
antlr3RecognitionExceptionNew PROC			; COMDAT

; 270  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]

; 271  : 	pANTLR3_EXCEPTION				ex;
; 272  : 	pANTLR3_LEXER					lexer;
; 273  : 	pANTLR3_PARSER					parser;
; 274  : 	pANTLR3_TREE_PARSER				tparser;
; 275  : 
; 276  : 	pANTLR3_INPUT_STREAM			ins;
; 277  : 	pANTLR3_INT_STREAM				is;
; 278  : 	pANTLR3_COMMON_TOKEN_STREAM	    cts;
; 279  : 	pANTLR3_TREE_NODE_STREAM	    tns;
; 280  : 
; 281  : 	ins	    = NULL;

  00024	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR ins$[rsp], 0

; 282  : 	cts	    = NULL;

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cts$[rsp], 0

; 283  : 	tns	    = NULL;

  00036	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tns$[rsp], 0

; 284  : 	is	    = NULL;

  0003f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR is$[rsp], 0

; 285  : 	lexer   = NULL;

  00048	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 286  : 	parser  = NULL;

  00051	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 287  : 	tparser = NULL;

  0005a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 288  : 
; 289  : 	switch	(recognizer->type)

  00063	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006e	89 44 24 68	 mov	 DWORD PTR tv65[rsp], eax
  00072	83 7c 24 68 01	 cmp	 DWORD PTR tv65[rsp], 1
  00077	74 13		 je	 SHORT $LN6@antlr3Reco
  00079	83 7c 24 68 02	 cmp	 DWORD PTR tv65[rsp], 2
  0007e	74 3c		 je	 SHORT $LN7@antlr3Reco
  00080	83 7c 24 68 04	 cmp	 DWORD PTR tv65[rsp], 4
  00085	74 6b		 je	 SHORT $LN8@antlr3Reco
  00087	e9 98 00 00 00	 jmp	 $LN9@antlr3Reco
$LN6@antlr3Reco:

; 290  : 	{
; 291  : 	case	ANTLR3_TYPE_LEXER:
; 292  : 
; 293  : 		lexer	= (pANTLR3_LEXER) (recognizer->super);

  0008c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	48 89 44 24 28	 mov	 QWORD PTR lexer$[rsp], rax

; 294  : 		ins	= lexer->input;

  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$[rsp]
  000a1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a5	48 89 44 24 40	 mov	 QWORD PTR ins$[rsp], rax

; 295  : 		is	= ins->istream;

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 296  : 
; 297  : 		break;

  000b7	e9 87 00 00 00	 jmp	 $LN2@antlr3Reco
$LN7@antlr3Reco:

; 298  : 
; 299  : 	case	ANTLR3_TYPE_PARSER:
; 300  : 
; 301  : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  000bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c7	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 302  : 		cts	= (pANTLR3_COMMON_TOKEN_STREAM)(parser->tstream->super);

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  000d1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d9	48 89 44 24 50	 mov	 QWORD PTR cts$[rsp], rax

; 303  : 		is	= parser->tstream->istream;

  000de	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  000e3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000eb	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 304  : 
; 305  : 		break;

  000f0	eb 51		 jmp	 SHORT $LN2@antlr3Reco
$LN8@antlr3Reco:

; 306  : 
; 307  : 	case	ANTLR3_TYPE_TREE_PARSER:
; 308  : 
; 309  : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  000f2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fd	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 310  : 		tns	= tparser->ctnstream->tnstream;

  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0010f	48 89 44 24 58	 mov	 QWORD PTR tns$[rsp], rax

; 311  : 		is	= tns->istream;

  00114	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  00119	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011d	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 312  : 
; 313  : 		break;

  00122	eb 1f		 jmp	 SHORT $LN2@antlr3Reco
$LN9@antlr3Reco:

; 314  : 
; 315  : 	default:
; 316  : 
; 317  : 		ANTLR3_FPRINTF(stderr, "Base recognizer function antlr3RecognitionExceptionNew called by unknown parser type - provide override for this function\n");

  00124	b9 02 00 00 00	 mov	 ecx, 2
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3R@
  00136	48 8b c8	 mov	 rcx, rax
  00139	e8 00 00 00 00	 call	 fprintf

; 318  : 		return;

  0013e	e9 0e 03 00 00	 jmp	 $LN1@antlr3Reco
$LN2@antlr3Reco:

; 319  : 
; 320  : 		break;
; 321  : 	}
; 322  : 
; 323  : 	/* Create a basic exception structure
; 324  : 	 */
; 325  : 	ex = antlr3ExceptionNew(ANTLR3_RECOGNITION_EXCEPTION,

  00143	45 33 c9	 xor	 r9d, r9d
  00146	45 33 c0	 xor	 r8d, r8d
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionExc@
  00150	b9 01 00 00 00	 mov	 ecx, 1
  00155	e8 00 00 00 00	 call	 antlr3ExceptionNew
  0015a	48 89 44 24 20	 mov	 QWORD PTR ex$[rsp], rax

; 326  : 		(void *)ANTLR3_RECOGNITION_EX_NAME,
; 327  : 		NULL,
; 328  : 		ANTLR3_FALSE);
; 329  : 
; 330  : 	/* Rest of information depends on the base type of the 
; 331  : 	 * input stream.
; 332  : 	 */
; 333  : 	switch  (is->type & ANTLR3_INPUT_MASK)

  0015f	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  00164	8b 00		 mov	 eax, DWORD PTR [rax]
  00166	83 e0 07	 and	 eax, 7
  00169	89 44 24 6c	 mov	 DWORD PTR tv92[rsp], eax
  0016d	83 7c 24 6c 01	 cmp	 DWORD PTR tv92[rsp], 1
  00172	74 1b		 je	 SHORT $LN10@antlr3Reco
  00174	83 7c 24 6c 02	 cmp	 DWORD PTR tv92[rsp], 2
  00179	0f 84 97 00 00
	00		 je	 $LN11@antlr3Reco
  0017f	83 7c 24 6c 04	 cmp	 DWORD PTR tv92[rsp], 4
  00184	0f 84 67 01 00
	00		 je	 $LN14@antlr3Reco
  0018a	e9 77 02 00 00	 jmp	 $LN4@antlr3Reco
$LN10@antlr3Reco:

; 334  : 	{
; 335  : 	case    ANTLR3_CHARSTREAM:
; 336  : 
; 337  : 		ex->c			= is->_LA		    	(is, 1);					/* Current input character			*/

  0018f	ba 01 00 00 00	 mov	 edx, 1
  00194	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  00199	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  0019e	ff 50 30	 call	 QWORD PTR [rax+48]
  001a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001a6	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 338  : 		ex->line		= ins->getLine			(ins);						/* Line number comes from stream		*/

  001a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  001ae	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  001b3	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  001b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001be	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 339  : 		ex->charPositionInLine	= ins->getCharPositionInLine	(ins);	    /* Line offset also comes from the stream   */

  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  001c6	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  001cb	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001d6	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 340  : 		ex->index		= is->index			(is);

  001d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  001de	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  001e3	ff 50 40	 call	 QWORD PTR [rax+64]
  001e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001eb	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 341  : 		ex->streamName		= ins->fileName;

  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  001f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  001f9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 342  : 		ex->message		= "Unexpected character";

  00201	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BIIJEBMB@Unexpected?5character?$AA@
  0020d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 343  : 		break;

  00211	e9 f0 01 00 00	 jmp	 $LN4@antlr3Reco
$LN11@antlr3Reco:

; 344  : 
; 345  : 	case    ANTLR3_TOKENSTREAM:
; 346  : 
; 347  : 		ex->token		= cts->tstream->_LT						(cts->tstream, 1);	    /* Current input token			    */

  00216	48 8b 44 24 50	 mov	 rax, QWORD PTR cts$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	ba 01 00 00 00	 mov	 edx, 1
  00223	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cts$[rsp]
  00228	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0022b	ff 50 28	 call	 QWORD PTR [rax+40]
  0022e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00233	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 348  : 		ex->line		= ((pANTLR3_COMMON_TOKEN)(ex->token))->getLine			(ex->token);

  00237	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0023c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00245	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00249	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  0024f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00254	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 349  : 		ex->charPositionInLine	= ((pANTLR3_COMMON_TOKEN)(ex->token))->getCharPositionInLine	(ex->token);

  00257	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0025c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00260	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00265	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00269	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  0026f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00274	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 350  : 		ex->index		= cts->tstream->istream->index					(cts->tstream->istream);

  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR cts$[rsp]
  0027c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0027f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cts$[rsp]
  00284	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00287	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0028b	48 89 4c 24 70	 mov	 QWORD PTR tv253[rsp], rcx
  00290	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00294	48 8b 44 24 70	 mov	 rax, QWORD PTR tv253[rsp]
  00299	ff 50 40	 call	 QWORD PTR [rax+64]
  0029c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  002a1	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 351  : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  002a5	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002aa	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002ae	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  002b1	75 0f		 jne	 SHORT $LN12@antlr3Reco

; 352  : 		{
; 353  : 			ex->streamName		= NULL;

  002b3	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002b8	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 354  : 		}

  002c0	eb 1a		 jmp	 SHORT $LN13@antlr3Reco
$LN12@antlr3Reco:

; 355  : 		else
; 356  : 		{
; 357  : 			ex->streamName		= ((pANTLR3_COMMON_TOKEN)(ex->token))->input->fileName;

  002c2	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002c7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002cb	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  002d4	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002d8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN13@antlr3Reco:

; 358  : 		}
; 359  : 		ex->message		= "Unexpected token";

  002dc	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FKAIECKK@Unexpected?5token?$AA@
  002e8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 360  : 		break;

  002ec	e9 15 01 00 00	 jmp	 $LN4@antlr3Reco
$LN14@antlr3Reco:

; 361  : 
; 362  : 	case    ANTLR3_COMMONTREENODE:
; 363  : 
; 364  : 		ex->token		= tns->_LT						    (tns, 1);	    /* Current input tree node			    */

  002f1	ba 01 00 00 00	 mov	 edx, 1
  002f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tns$[rsp]
  002fb	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  00300	ff 50 10	 call	 QWORD PTR [rax+16]
  00303	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00308	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 365  : 		ex->line		= ((pANTLR3_BASE_TREE)(ex->token))->getLine		    (ex->token);

  0030c	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00311	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00315	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0031a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0031e	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00324	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00329	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 366  : 		ex->charPositionInLine	= ((pANTLR3_BASE_TREE)(ex->token))->getCharPositionInLine   (ex->token);

  0032c	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00331	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00335	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0033a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0033e	ff 50 68	 call	 QWORD PTR [rax+104]
  00341	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00346	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 367  : 		ex->index		= tns->istream->index					    (tns->istream);

  00349	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  0034e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00352	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tns$[rsp]
  00357	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0035b	ff 50 40	 call	 QWORD PTR [rax+64]
  0035e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00363	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 368  : 
; 369  : 		// Are you ready for this? Deep breath now...
; 370  : 		//
; 371  : 		{
; 372  : 			pANTLR3_COMMON_TREE tnode;
; 373  : 
; 374  : 			tnode		= ((pANTLR3_COMMON_TREE)(((pANTLR3_BASE_TREE)(ex->token))->super));

  00367	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0036c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00370	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00373	48 89 44 24 60	 mov	 QWORD PTR tnode$1[rsp], rax

; 375  : 
; 376  : 			if	(tnode->token    == NULL)

  00378	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  0037d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00382	75 39		 jne	 SHORT $LN15@antlr3Reco

; 377  : 			{
; 378  : 				ex->streamName = ((pANTLR3_BASE_TREE)(ex->token))->strFactory->newStr(((pANTLR3_BASE_TREE)(ex->token))->strFactory, (pANTLR3_UINT8)"-unknown source-");

  00384	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00389	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0038d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00392	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00396	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0039a	48 89 4c 24 78	 mov	 QWORD PTR tv243[rsp], rcx
  0039f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DHPGECBL@?9unknown?5source?9?$AA@
  003a6	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  003aa	48 8b 44 24 78	 mov	 rax, QWORD PTR tv243[rsp]
  003af	ff 50 30	 call	 QWORD PTR [rax+48]
  003b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  003b7	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 379  : 			}

  003bb	eb 39		 jmp	 SHORT $LN16@antlr3Reco
$LN15@antlr3Reco:

; 380  : 			else
; 381  : 			{
; 382  : 				if	(tnode->token->input == NULL)

  003bd	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  003c2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003c6	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  003cb	75 0f		 jne	 SHORT $LN17@antlr3Reco

; 383  : 				{
; 384  : 					ex->streamName		= NULL;

  003cd	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  003d2	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 385  : 				}

  003da	eb 1a		 jmp	 SHORT $LN18@antlr3Reco
$LN17@antlr3Reco:

; 386  : 				else
; 387  : 				{
; 388  : 					ex->streamName		= tnode->token->input->fileName;

  003dc	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  003e1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003e5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  003ee	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  003f2	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN18@antlr3Reco:
$LN16@antlr3Reco:

; 389  : 				}
; 390  : 			}
; 391  : 			ex->message		= "Unexpected node";

  003f6	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@IGJLDFLP@Unexpected?5node?$AA@
  00402	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN4@antlr3Reco:

; 392  : 		}
; 393  : 		break;
; 394  : 	}
; 395  : 
; 396  : 	ex->input						= is;

  00406	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0040b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  00410	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 397  : 	ex->nextException				= recognizer->state->exception;	/* So we don't leak the memory */

  00414	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0041c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00420	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00425	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00429	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 398  : 	recognizer->state->exception	= ex;

  0042d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00435	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00439	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0043e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 399  : 	recognizer->state->error	    = ANTLR3_TRUE;	    /* Exception is outstanding	*/

  00442	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0044a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0044e	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN1@antlr3Reco:

; 400  : 
; 401  : 	return;
; 402  : }

  00451	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00458	5f		 pop	 rdi
  00459	c3		 ret	 0
antlr3RecognitionExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3BaseRecognizerNew
_TEXT	SEGMENT
recognizer$ = 32
type$ = 64
sizeHint$ = 72
state$ = 80
antlr3BaseRecognizerNew PROC				; COMDAT

; 85   : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 0c 00 00 00	 mov	 ecx, 12
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 86   :     pANTLR3_BASE_RECOGNIZER recognizer;
; 87   : 
; 88   :     // Allocate memory for the structure
; 89   :     //
; 90   :     recognizer	    = (pANTLR3_BASE_RECOGNIZER) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BASE_RECOGNIZER));

  00025	b9 28 01 00 00	 mov	 ecx, 296		; 00000128H
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00030	48 89 44 24 20	 mov	 QWORD PTR recognizer$[rsp], rax

; 91   : 
; 92   :     if	(recognizer == NULL)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR recognizer$[rsp], 0
  0003b	75 07		 jne	 SHORT $LN2@antlr3Base

; 93   :     {
; 94   : 		// Allocation failed
; 95   : 		//
; 96   : 		return	NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 bb 03 00 00	 jmp	 $LN1@antlr3Base
$LN2@antlr3Base:

; 97   :     }
; 98   : 
; 99   : 	
; 100  : 	// If we have been supplied with a pre-existing recognizer state
; 101  : 	// then we just install it, otherwise we must create one from scratch
; 102  : 	//
; 103  : 	if	(state == NULL)

  00044	48 83 7c 24 50
	00		 cmp	 QWORD PTR state$[rsp], 0
  0004a	0f 85 34 01 00
	00		 jne	 $LN3@antlr3Base

; 104  : 	{
; 105  : 		recognizer->state = (pANTLR3_RECOGNIZER_SHARED_STATE) ANTLR3_CALLOC(1, (size_t)sizeof(ANTLR3_RECOGNIZER_SHARED_STATE));

  00050	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00065	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 106  : 
; 107  : 		if	(recognizer->state == NULL)

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00073	75 12		 jne	 SHORT $LN5@antlr3Base

; 108  : 		{
; 109  : 			ANTLR3_FREE(recognizer);

  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 110  : 			return	NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 78 03 00 00	 jmp	 $LN1@antlr3Base
$LN5@antlr3Base:

; 111  : 		}
; 112  : 
; 113  : 		// Initialize any new recognizer state
; 114  : 		//
; 115  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0008c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00090	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 116  : 		recognizer->state->lastErrorIndex	= -1;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00099	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009d	48 c7 40 28 ff
	ff ff ff	 mov	 QWORD PTR [rax+40], -1

; 117  : 		recognizer->state->failed		= ANTLR3_FALSE;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000aa	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ae	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 118  : 		recognizer->state->errorCount		= 0;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000bb	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 119  : 		recognizer->state->backtracking		= 0;

  000c2	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cb	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 120  : 		recognizer->state->following		= NULL;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000db	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 121  : 		recognizer->state->ruleMemo		= NULL;

  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ec	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 122  : 		recognizer->state->tokenNames		= NULL;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fd	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 123  : 		recognizer->state->sizeHint             = sizeHint;

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010e	8b 4c 24 48	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  00112	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 124  : 		recognizer->state->tokSource		= NULL;

  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0011e	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 125  :                 recognizer->state->tokFactory           = NULL;

  00126	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0012b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012f	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 126  : 
; 127  : 		// Rather than check to see if we must initialize
; 128  : 		// the stack every time we are asked for an new rewrite stream
; 129  : 		// we just always create an empty stack and then just
; 130  : 		// free it when the base recognizer is freed.
; 131  : 		//
; 132  : 		recognizer->state->rStreams		= antlr3VectorNew(0);  // We don't know the size.

  00137	33 c9		 xor	 ecx, ecx
  00139	e8 00 00 00 00	 call	 antlr3VectorNew
  0013e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00143	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00147	48 89 81 b0 00
	00 00		 mov	 QWORD PTR [rcx+176], rax

; 133  : 
; 134  : 		if	(recognizer->state->rStreams == NULL)

  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00153	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00157	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0015f	75 21		 jne	 SHORT $LN6@antlr3Base

; 135  : 		{
; 136  : 			// Out of memory
; 137  : 			//
; 138  : 			ANTLR3_FREE(recognizer->state);

  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00166	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 139  : 			ANTLR3_FREE(recognizer);

  00170	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 140  : 			return	NULL;

  0017b	33 c0		 xor	 eax, eax
  0017d	e9 7d 02 00 00	 jmp	 $LN1@antlr3Base
$LN6@antlr3Base:

; 141  : 		}
; 142  : 	}

  00182	eb 0e		 jmp	 SHORT $LN4@antlr3Base
$LN3@antlr3Base:

; 143  : 	else
; 144  : 	{
; 145  : 		// Install the one we were given, and do not reset it here
; 146  : 		// as it will either already have been initialized or will
; 147  : 		// be in a state that needs to be preserved.
; 148  : 		//
; 149  : 		recognizer->state = state;

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00189	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0018e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN4@antlr3Base:

; 150  : 	}
; 151  : 		
; 152  :     // Install the BR API
; 153  :     //
; 154  :     recognizer->alreadyParsedRule           = alreadyParsedRule;

  00192	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:alreadyParsedRule
  0019e	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 155  :     recognizer->beginResync                 = beginResync;

  001a5	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginResync
  001b1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 156  :     recognizer->combineFollows              = combineFollows;

  001b5	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:combineFollows
  001c1	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 157  :     recognizer->beginBacktrack              = beginBacktrack;

  001c8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginBacktrack
  001d4	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 158  :     recognizer->endBacktrack                = endBacktrack;

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endBacktrack
  001e4	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 159  :     recognizer->computeCSRuleFollow         = computeCSRuleFollow;

  001eb	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:computeCSRuleFollow
  001f7	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 160  :     recognizer->computeErrorRecoverySet     = computeErrorRecoverySet;

  001fe	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:computeErrorRecoverySet
  0020a	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 161  :     recognizer->consumeUntil                = consumeUntil;

  00211	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeUntil
  0021d	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 162  :     recognizer->consumeUntilSet             = consumeUntilSet;

  00224	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeUntilSet
  00230	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 163  :     recognizer->displayRecognitionError     = displayRecognitionError;

  00237	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:displayRecognitionError
  00243	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 164  :     recognizer->endResync                   = endResync;

  00247	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endResync
  00253	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 165  :     recognizer->exConstruct                 = antlr3MTExceptionNew;

  00257	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3MTExceptionNew
  00263	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 166  :     recognizer->getRuleInvocationStack      = getRuleInvocationStack;

  0026a	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleInvocationStack
  00276	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 167  :     recognizer->getRuleInvocationStackNamed = getRuleInvocationStackNamed;

  0027d	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleInvocationStackNamed
  00289	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 168  :     recognizer->getRuleMemoization          = getRuleMemoization;

  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleMemoization
  0029c	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 169  :     recognizer->match                       = match;

  002a3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:match
  002af	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 170  :     recognizer->matchAny                    = matchAny;

  002b3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchAny
  002bf	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 171  :     recognizer->memoize                     = memoize;

  002c3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:memoize
  002cf	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 172  :     recognizer->mismatch                    = mismatch;

  002d6	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatch
  002e2	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 173  :     recognizer->mismatchIsUnwantedToken     = mismatchIsUnwantedToken;

  002e6	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatchIsUnwantedToken
  002f2	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 174  :     recognizer->mismatchIsMissingToken      = mismatchIsMissingToken;

  002f6	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatchIsMissingToken
  00302	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 175  :     recognizer->recover                     = recover;

  00306	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0030b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recover
  00312	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 176  :     recognizer->recoverFromMismatchedElement= recoverFromMismatchedElement;

  00316	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedElement
  00322	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 177  :     recognizer->recoverFromMismatchedSet    = recoverFromMismatchedSet;

  00329	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedSet
  00335	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 178  :     recognizer->recoverFromMismatchedToken  = recoverFromMismatchedToken;

  0033c	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedToken
  00348	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 179  :     recognizer->getNumberOfSyntaxErrors     = getNumberOfSyntaxErrors;

  0034f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getNumberOfSyntaxErrors
  0035b	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 180  :     recognizer->reportError                 = reportError;

  0035f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reportError
  0036b	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 181  :     recognizer->reset                       = reset;

  0036f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  0037b	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 182  :     recognizer->synpred                     = synpred;

  00382	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:synpred
  0038e	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 183  :     recognizer->toStrings                   = toStrings;

  00395	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStrings
  003a1	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 184  :     recognizer->getCurrentInputSymbol       = getCurrentInputSymbol;

  003a8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCurrentInputSymbol
  003b4	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 185  :     recognizer->getMissingSymbol            = getMissingSymbol;

  003bb	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getMissingSymbol
  003c7	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 186  :     recognizer->debugger                    = NULL;

  003ce	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003d3	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 187  : 
; 188  :     recognizer->free = freeBR;

  003db	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeBR
  003e7	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 189  : 
; 190  :     /* Initialize variables
; 191  :      */
; 192  :     recognizer->type			= type;

  003ee	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003f3	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  003f7	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 193  : 
; 194  : 
; 195  :     return  recognizer;

  003fa	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
$LN1@antlr3Base:

; 196  : }

  003ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00403	5f		 pop	 rdi
  00404	c3		 ret	 0
antlr3BaseRecognizerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00049	e8 00 00 00 00	 call	 _vfprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 838  : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
