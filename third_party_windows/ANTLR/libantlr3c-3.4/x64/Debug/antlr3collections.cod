; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
bitIndex DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
bitMask	DQ	0000000000000001H
	DQ	0000000000000002H
	DQ	0000000000000004H
	DQ	0000000000000008H
	DQ	0000000000000010H
	DQ	0000000000000020H
	DQ	0000000000000040H
	DQ	0000000000000080H
	DQ	0000000000000100H
	DQ	0000000000000200H
	DQ	0000000000000400H
	DQ	0000000000000800H
	DQ	0000000000001000H
	DQ	0000000000002000H
	DQ	0000000000004000H
	DQ	0000000000008000H
	DQ	0000000000010000H
	DQ	0000000000020000H
	DQ	0000000000040000H
	DQ	0000000000080000H
	DQ	0000000000100000H
	DQ	0000000000200000H
	DQ	0000000000400000H
	DQ	0000000000800000H
	DQ	0000000001000000H
	DQ	0000000002000000H
	DQ	0000000004000000H
	DQ	0000000008000000H
	DQ	0000000010000000H
	DQ	0000000020000000H
	DQ	0000000040000000H
	DQ	0000000080000000H
	DQ	0000000100000000H
	DQ	0000000200000000H
	DQ	0000000400000000H
	DQ	0000000800000000H
	DQ	0000001000000000H
	DQ	0000002000000000H
	DQ	0000004000000000H
	DQ	0000008000000000H
	DQ	0000010000000000H
	DQ	0000020000000000H
	DQ	0000040000000000H
	DQ	0000080000000000H
	DQ	0000100000000000H
	DQ	0000200000000000H
	DQ	0000400000000000H
	DQ	0000800000000000H
	DQ	0001000000000000H
	DQ	0002000000000000H
	DQ	0004000000000000H
	DQ	0008000000000000H
	DQ	0010000000000000H
	DQ	0020000000000000H
	DQ	0040000000000000H
	DQ	0080000000000000H
	DQ	0100000000000000H
	DQ	0200000000000000H
	DQ	0400000000000000H
	DQ	0800000000000000H
	DQ	1000000000000000H
	DQ	2000000000000000H
	DQ	4000000000000000H
	DQ	8000000000000000H
_DATA	ENDS
PUBLIC	antlr3IntTrieNew
PUBLIC	antlr3HashTableNew
PUBLIC	antlr3Hash
PUBLIC	antlr3EnumNew
PUBLIC	antlr3ListNew
PUBLIC	antlr3VectorFactoryNew
PUBLIC	antlr3VectorNew
PUBLIC	antlr3StackNew
PUBLIC	antlr3SetVectorApi
PUBLIC	antlr3TopoNew
EXTRN	memcpy:PROC
EXTRN	__imp_memmove:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	antlr3BitsetNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3IntTrieNew DD imagerel $LN5
	DD	imagerel $LN5+264
	DD	imagerel $unwind$antlr3IntTrieNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashTableNew DD imagerel $LN8
	DD	imagerel $LN8+383
	DD	imagerel $unwind$antlr3HashTableNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Hash DD imagerel $LN6
	DD	imagerel $LN6+161
	DD	imagerel $unwind$antlr3Hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNew DD imagerel $LN5
	DD	imagerel $LN5+175
	DD	imagerel $unwind$antlr3EnumNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListNew DD imagerel $LN5
	DD	imagerel $LN5+220
	DD	imagerel $unwind$antlr3ListNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorFactoryNew DD imagerel $LN4
	DD	imagerel $LN4+217
	DD	imagerel $unwind$antlr3VectorFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorNew DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$antlr3VectorNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackNew DD imagerel $LN5
	DD	imagerel $LN5+217
	DD	imagerel $unwind$antlr3StackNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3SetVectorApi DD imagerel $LN8
	DD	imagerel $LN8+353
	DD	imagerel $unwind$antlr3SetVectorApi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TopoNew DD imagerel $LN4
	DD	imagerel $LN4+211
	DD	imagerel $unwind$antlr3TopoNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashDelete DD imagerel antlr3HashDelete
	DD	imagerel antlr3HashDelete+122
	DD	imagerel $unwind$antlr3HashDelete
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashGet DD imagerel antlr3HashGet
	DD	imagerel antlr3HashGet+176
	DD	imagerel $unwind$antlr3HashGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashRemove DD imagerel antlr3HashRemove
	DD	imagerel antlr3HashRemove+282
	DD	imagerel $unwind$antlr3HashRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashPut DD imagerel antlr3HashPut
	DD	imagerel antlr3HashPut+365
	DD	imagerel $unwind$antlr3HashPut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashDeleteI DD imagerel antlr3HashDeleteI
	DD	imagerel antlr3HashDeleteI+122
	DD	imagerel $unwind$antlr3HashDeleteI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashGetI DD imagerel antlr3HashGetI
	DD	imagerel antlr3HashGetI+162
	DD	imagerel $unwind$antlr3HashGetI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashRemoveI DD imagerel antlr3HashRemoveI
	DD	imagerel antlr3HashRemoveI+219
	DD	imagerel $unwind$antlr3HashRemoveI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashPutI DD imagerel antlr3HashPutI
	DD	imagerel antlr3HashPutI+314
	DD	imagerel $unwind$antlr3HashPutI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashFree DD imagerel antlr3HashFree
	DD	imagerel antlr3HashFree+290
	DD	imagerel $unwind$antlr3HashFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashSize DD imagerel antlr3HashSize
	DD	imagerel antlr3HashSize+16
	DD	imagerel $unwind$antlr3HashSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNext DD imagerel antlr3EnumNext
	DD	imagerel antlr3EnumNext+124
	DD	imagerel $unwind$antlr3EnumNext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumFree DD imagerel antlr3EnumFree
	DD	imagerel antlr3EnumFree+47
	DD	imagerel $unwind$antlr3EnumFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListFree DD imagerel antlr3ListFree
	DD	imagerel antlr3ListFree+66
	DD	imagerel $unwind$antlr3ListFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListDelete DD imagerel antlr3ListDelete
	DD	imagerel antlr3ListDelete+65
	DD	imagerel $unwind$antlr3ListDelete
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListGet DD imagerel antlr3ListGet
	DD	imagerel antlr3ListGet+65
	DD	imagerel $unwind$antlr3ListGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListPut DD imagerel antlr3ListPut
	DD	imagerel antlr3ListPut+85
	DD	imagerel $unwind$antlr3ListPut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListAdd DD imagerel antlr3ListAdd
	DD	imagerel antlr3ListAdd+102
	DD	imagerel $unwind$antlr3ListAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListRemove DD imagerel antlr3ListRemove
	DD	imagerel antlr3ListRemove+93
	DD	imagerel $unwind$antlr3ListRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListSize DD imagerel antlr3ListSize
	DD	imagerel antlr3ListSize+55
	DD	imagerel $unwind$antlr3ListSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackFree DD imagerel antlr3StackFree
	DD	imagerel antlr3StackFree+94
	DD	imagerel $unwind$antlr3StackFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPop DD imagerel antlr3StackPop
	DD	imagerel antlr3StackPop+148
	DD	imagerel $unwind$antlr3StackPop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackGet DD imagerel antlr3StackGet
	DD	imagerel antlr3StackGet+67
	DD	imagerel $unwind$antlr3StackGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPush DD imagerel antlr3StackPush
	DD	imagerel antlr3StackPush+92
	DD	imagerel $unwind$antlr3StackPush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackSize DD imagerel antlr3StackSize
	DD	imagerel antlr3StackSize+19
	DD	imagerel $unwind$antlr3StackSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPeek DD imagerel antlr3StackPeek
	DD	imagerel antlr3StackPeek+17
	DD	imagerel $unwind$antlr3StackPeek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorFree DD imagerel antlr3VectorFree
	DD	imagerel antlr3VectorFree+256
	DD	imagerel $unwind$antlr3VectorFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorDel DD imagerel antlr3VectorDel
	DD	imagerel antlr3VectorDel+293
	DD	imagerel $unwind$antlr3VectorDel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorGet DD imagerel antlr3VectorGet
	DD	imagerel antlr3VectorGet+52
	DD	imagerel $unwind$antlr3VectorGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antrl3VectorRemove DD imagerel antrl3VectorRemove
	DD	imagerel antrl3VectorRemove+260
	DD	imagerel $unwind$antrl3VectorRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorClear DD imagerel antlr3VectorClear
	DD	imagerel antlr3VectorClear+201
	DD	imagerel $unwind$antlr3VectorClear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorAdd DD imagerel antlr3VectorAdd
	DD	imagerel antlr3VectorAdd+164
	DD	imagerel $unwind$antlr3VectorAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSet DD imagerel antlr3VectorSet
	DD	imagerel antlr3VectorSet+252
	DD	imagerel $unwind$antlr3VectorSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSize DD imagerel antlr3VectorSize
	DD	imagerel antlr3VectorSize+16
	DD	imagerel $unwind$antlr3VectorSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSwap DD imagerel antlr3VectorSwap
	DD	imagerel antlr3VectorSwap+270
	DD	imagerel $unwind$antlr3VectorSwap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPool DD imagerel newPool
	DD	imagerel newPool+140
	DD	imagerel $unwind$newPool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeVectorFactory DD imagerel closeVectorFactory
	DD	imagerel closeVectorFactory+570
	DD	imagerel $unwind$closeVectorFactory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newVector DD imagerel newVector
	DD	imagerel newVector+248
	DD	imagerel $unwind$newVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$returnVector DD imagerel returnVector
	DD	imagerel returnVector+92
	DD	imagerel $unwind$returnVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieGet DD imagerel intTrieGet
	DD	imagerel intTrieGet+205
	DD	imagerel $unwind$intTrieGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieDel DD imagerel intTrieDel
	DD	imagerel intTrieDel+65
	DD	imagerel $unwind$intTrieDel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieAdd DD imagerel intTrieAdd
	DD	imagerel intTrieAdd+1434
	DD	imagerel $unwind$intTrieAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieFree DD imagerel intTrieFree
	DD	imagerel intTrieFree+60
	DD	imagerel $unwind$intTrieFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addEdge DD imagerel addEdge
	DD	imagerel addEdge+391
	DD	imagerel $unwind$addEdge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortToArray DD imagerel sortToArray
	DD	imagerel sortToArray+269
	DD	imagerel $unwind$sortToArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortVector DD imagerel sortVector
	DD	imagerel sortVector+378
	DD	imagerel $unwind$sortVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeTopo DD imagerel freeTopo
	DD	imagerel freeTopo+275
	DD	imagerel $unwind$freeTopo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNextEntry DD imagerel antlr3EnumNextEntry
	DD	imagerel antlr3EnumNextEntry+203
	DD	imagerel $unwind$antlr3EnumNextEntry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorResize DD imagerel antlr3VectorResize
	DD	imagerel antlr3VectorResize+213
	DD	imagerel $unwind$antlr3VectorResize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeIntNode DD imagerel freeIntNode
	DD	imagerel freeIntNode+213
	DD	imagerel $unwind$freeIntNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DFS DD	imagerel DFS
	DD	imagerel DFS+568
	DD	imagerel $unwind$DFS
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DFS DD	022201H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeIntNode DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorResize DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNextEntry DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeTopo DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortVector DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortToArray DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addEdge DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieAdd DD 022d01H
	DD	07015b219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieDel DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieGet DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$returnVector DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newVector DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeVectorFactory DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPool DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSwap DD 022701H
	DD	0700f1213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSet DD 022c01H
	DD	070143218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorAdd DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorClear DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antrl3VectorRemove DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorGet DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorDel DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorFree DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPeek DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPush DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackGet DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPop DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListSize DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListRemove DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListAdd DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListPut DD 022d01H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListGet DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListDelete DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNext DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashFree DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashPutI DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashRemoveI DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashGetI DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashDeleteI DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashPut DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashRemove DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashGet DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashDelete DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TopoNew DD 021501H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3SetVectorApi DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorFactoryNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNew DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Hash DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashTableNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3IntTrieNew DD 021c01H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT DFS
_TEXT	SEGMENT
edges$ = 32
i$1 = 40
l$2 = 44
numBits$3 = 48
i$4 = 52
range$5 = 56
topo$ = 80
node$ = 88
DFS	PROC						; COMDAT

; 2416 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 2417 :     pANTLR3_BITSET edges;
; 2418 : 
; 2419 :     // Guard against a revisit and check for cycles
; 2420 :     //
; 2421 :     if  (topo->hasCycle == ANTLR3_TRUE)

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00027	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 05		 jne	 SHORT $LN11@DFS

; 2422 :     {
; 2423 :         return; // We don't do anything else if we found a cycle

  00030	e9 fd 01 00 00	 jmp	 $LN1@DFS
$LN11@DFS:

; 2424 :     }
; 2425 : 
; 2426 :     if  (topo->visited->isMember(topo->visited, node))

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0003a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003e	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00047	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0004b	ff 50 48	 call	 QWORD PTR [rax+72]
  0004e	0f b6 c0	 movzx	 eax, al
  00051	85 c0		 test	 eax, eax
  00053	0f 84 b7 00 00
	00		 je	 $LN12@DFS

; 2427 :     {
; 2428 :         // Check to see if we found a cycle. To do this we search the
; 2429 :         // current cycle stack and see if we find this node already in the stack.
; 2430 :         //
; 2431 :         ANTLR3_UINT32   i;
; 2432 : 
; 2433 :         for (i=0; i<topo->cycleMark; i++)

  00059	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00061	eb 0a		 jmp	 SHORT $LN4@DFS
$LN2@DFS:
  00063	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00067	ff c0		 inc	 eax
  00069	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
$LN4@DFS:
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00072	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00075	39 44 24 28	 cmp	 DWORD PTR i$1[rsp], eax
  00079	0f 83 8c 00 00
	00		 jae	 $LN3@DFS

; 2434 :         {
; 2435 :             if  (topo->cycle[i] == node)

  0007f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00088	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0008c	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00090	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00093	75 71		 jne	 SHORT $LN13@DFS

; 2436 :             {
; 2437 :                 // Stop! We found a cycle in the input, so rejig the cycle
; 2438 :                 // stack so that it only contains the cycle and set the cycle flag
; 2439 :                 // which will tell the caller what happened
; 2440 :                 //
; 2441 :                 ANTLR3_UINT32 l;
; 2442 : 
; 2443 :                 for (l = i; l < topo->cycleMark; l++)

  00095	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00099	89 44 24 2c	 mov	 DWORD PTR l$2[rsp], eax
  0009d	eb 0a		 jmp	 SHORT $LN7@DFS
$LN5@DFS:
  0009f	8b 44 24 2c	 mov	 eax, DWORD PTR l$2[rsp]
  000a3	ff c0		 inc	 eax
  000a5	89 44 24 2c	 mov	 DWORD PTR l$2[rsp], eax
$LN7@DFS:
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000ae	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000b1	39 44 24 2c	 cmp	 DWORD PTR l$2[rsp], eax
  000b5	73 30		 jae	 SHORT $LN6@DFS

; 2444 :                 {
; 2445 :                     topo->cycle[l - i] = topo->cycle[l];    // Move to zero base in the cycle list

  000b7	8b 44 24 2c	 mov	 eax, DWORD PTR l$2[rsp]
  000bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000c0	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c4	8b 54 24 28	 mov	 edx, DWORD PTR i$1[rsp]
  000c8	44 8b 44 24 2c	 mov	 r8d, DWORD PTR l$2[rsp]
  000cd	44 2b c2	 sub	 r8d, edx
  000d0	41 8b d0	 mov	 edx, r8d
  000d3	8b d2		 mov	 edx, edx
  000d5	4c 8b 44 24 50	 mov	 r8, QWORD PTR topo$[rsp]
  000da	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  000de	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000e1	41 89 04 90	 mov	 DWORD PTR [r8+rdx*4], eax

; 2446 :                 }

  000e5	eb b8		 jmp	 SHORT $LN5@DFS
$LN6@DFS:

; 2447 : 
; 2448 :                 // Recalculate the limit
; 2449 :                 //
; 2450 :                 topo->cycleMark -= i;

  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000ec	8b 4c 24 28	 mov	 ecx, DWORD PTR i$1[rsp]
  000f0	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000f3	2b c1		 sub	 eax, ecx
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000fa	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 2451 : 
; 2452 :                 // Signal disaster
; 2453 :                 //
; 2454 :                 topo->hasCycle = ANTLR3_TRUE;

  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00102	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
$LN13@DFS:

; 2455 :             }
; 2456 :         }

  00106	e9 58 ff ff ff	 jmp	 $LN2@DFS
$LN3@DFS:

; 2457 :         return;

  0010b	e9 22 01 00 00	 jmp	 $LN1@DFS
$LN12@DFS:

; 2458 :     }
; 2459 : 
; 2460 :     // So far, no cycles have been found and we have not visited this node yet,
; 2461 :     // so this node needs to go into the cycle stack before we continue
; 2462 :     // then we will take it out of the stack once we have descended all its
; 2463 :     // dependencies.
; 2464 :     //
; 2465 :     topo->cycle[topo->cycleMark++] = node;

  00110	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00115	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0011d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00121	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00125	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00128	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0012d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00130	ff c0		 inc	 eax
  00132	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00137	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 2466 : 
; 2467 :     // First flag that we have visited this node
; 2468 :     //
; 2469 :     topo->visited->add(topo->visited, node);

  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0013f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00143	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0014c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00150	ff 50 30	 call	 QWORD PTR [rax+48]

; 2470 : 
; 2471 :     // Now, if this node has edges, then we want to ensure we visit
; 2472 :     // them all before we drop through and add this node into the sorted
; 2473 :     // list.
; 2474 :     //
; 2475 :     edges = *((topo->edges) + node);

  00153	8b 44 24 58	 mov	 eax, DWORD PTR node$[rsp]
  00157	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0015c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0015f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00163	48 89 44 24 20	 mov	 QWORD PTR edges$[rsp], rax

; 2476 :     if  (edges != NULL)

  00168	48 83 7c 24 20
	00		 cmp	 QWORD PTR edges$[rsp], 0
  0016e	74 79		 je	 SHORT $LN14@DFS

; 2477 :     {
; 2478 :         // We have some edges, so visit each of the edge nodes
; 2479 :         // that have not already been visited.
; 2480 :         //
; 2481 :         ANTLR3_UINT32   numBits;	    // How many bits are in the set
; 2482 :         ANTLR3_UINT32   i;
; 2483 :         ANTLR3_UINT32   range;
; 2484 : 
; 2485 :         numBits = edges->numBits(edges);

  00170	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  00175	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  0017a	ff 50 50	 call	 QWORD PTR [rax+80]
  0017d	89 44 24 30	 mov	 DWORD PTR numBits$3[rsp], eax

; 2486 :         range   = edges->size(edges);   // Number of set bits

  00181	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  0018b	ff 50 28	 call	 QWORD PTR [rax+40]
  0018e	89 44 24 38	 mov	 DWORD PTR range$5[rsp], eax

; 2487 : 
; 2488 :         // Stop if we exahust the bit list or have checked the
; 2489 :         // number of edges that this node refers to (so we don't
; 2490 :         // check bits at the end that cannot possibly be set).
; 2491 :         //
; 2492 :         for (i=0; i<= numBits && range > 0; i++)

  00192	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  0019a	eb 0a		 jmp	 SHORT $LN10@DFS
$LN8@DFS:
  0019c	8b 44 24 34	 mov	 eax, DWORD PTR i$4[rsp]
  001a0	ff c0		 inc	 eax
  001a2	89 44 24 34	 mov	 DWORD PTR i$4[rsp], eax
$LN10@DFS:
  001a6	8b 44 24 30	 mov	 eax, DWORD PTR numBits$3[rsp]
  001aa	39 44 24 34	 cmp	 DWORD PTR i$4[rsp], eax
  001ae	77 39		 ja	 SHORT $LN9@DFS
  001b0	83 7c 24 38 00	 cmp	 DWORD PTR range$5[rsp], 0
  001b5	76 32		 jbe	 SHORT $LN9@DFS

; 2493 :         {
; 2494 :             if  (edges->isMember(edges, i))

  001b7	8b 54 24 34	 mov	 edx, DWORD PTR i$4[rsp]
  001bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  001c5	ff 50 48	 call	 QWORD PTR [rax+72]
  001c8	0f b6 c0	 movzx	 eax, al
  001cb	85 c0		 test	 eax, eax
  001cd	74 18		 je	 SHORT $LN15@DFS

; 2495 :             {
; 2496 :                 range--;        // About to check another one

  001cf	8b 44 24 38	 mov	 eax, DWORD PTR range$5[rsp]
  001d3	ff c8		 dec	 eax
  001d5	89 44 24 38	 mov	 DWORD PTR range$5[rsp], eax

; 2497 : 
; 2498 :                 // Found an edge, make sure we visit and descend it
; 2499 :                 //
; 2500 :                 DFS(topo, i);

  001d9	8b 54 24 34	 mov	 edx, DWORD PTR i$4[rsp]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  001e2	e8 00 00 00 00	 call	 DFS
$LN15@DFS:

; 2501 :             }
; 2502 :         }

  001e7	eb b3		 jmp	 SHORT $LN8@DFS
$LN9@DFS:
$LN14@DFS:

; 2503 :     }
; 2504 : 
; 2505 :     // At this point we will have visited all the dependencies
; 2506 :     // of this node and they will be ordered (even if there are cycles)
; 2507 :     // So we just add the node into the sorted list at the
; 2508 :     // current index position.
; 2509 :     //
; 2510 :     topo->sorted[topo->limit++] = node;

  001e9	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  001ee	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  001f6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001fa	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  001fe	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00201	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00206	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00209	ff c0		 inc	 eax
  0020b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00210	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 2511 : 
; 2512 :     // Remove this node from the cycle list if we have not detected a cycle
; 2513 :     //
; 2514 :     if  (topo->hasCycle == ANTLR3_FALSE)

  00213	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00218	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0021c	85 c0		 test	 eax, eax
  0021e	75 12		 jne	 SHORT $LN16@DFS

; 2515 :     {
; 2516 :         topo->cycleMark--;

  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00225	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00228	ff c8		 dec	 eax
  0022a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0022f	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN16@DFS:
$LN1@DFS:

; 2517 :     }
; 2518 : 
; 2519 :     return;
; 2520 : }

  00232	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00236	5f		 pop	 rdi
  00237	c3		 ret	 0
DFS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT freeIntNode
_TEXT	SEGMENT
thisEntry$ = 32
nextEntry$ = 40
node$ = 64
freeIntNode PROC					; COMDAT

; 2191 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 2192 :     pANTLR3_TRIE_ENTRY	thisEntry;
; 2193 :     pANTLR3_TRIE_ENTRY	nextEntry;
; 2194 : 
; 2195 :     /* If this node has a left pointer that is not a back pointer
; 2196 :      * then recursively call to free this
; 2197 :      */
; 2198 :     if (node->bitNum > node->leftN->bitNum)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  0002c	8b 00		 mov	 eax, DWORD PTR [rax]
  0002e	39 01		 cmp	 DWORD PTR [rcx], eax
  00030	76 0e		 jbe	 SHORT $LN4@freeIntNod

; 2199 :     {
; 2200 : 	/* We have a left node that needs descending, so do it.
; 2201 : 	 */
; 2202 : 	freeIntNode(node->leftN);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00037	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0003b	e8 00 00 00 00	 call	 freeIntNode
$LN4@freeIntNod:

; 2203 :     }
; 2204 : 
; 2205 :     /* The left nodes from here should now be dealt with, so 
; 2206 :      * we need to descend any right nodes that are not back pointers
; 2207 :      */
; 2208 :     if (node->bitNum > node->rightN->bitNum)

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00045	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  0004e	8b 00		 mov	 eax, DWORD PTR [rax]
  00050	39 01		 cmp	 DWORD PTR [rcx], eax
  00052	76 0e		 jbe	 SHORT $LN5@freeIntNod

; 2209 :     {
; 2210 : 	/* There are some right nodes to descend and deal with.
; 2211 : 	 */
; 2212 : 	freeIntNode(node->rightN);

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00059	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0005d	e8 00 00 00 00	 call	 freeIntNode
$LN5@freeIntNod:

; 2213 :     }
; 2214 : 
; 2215 :     /* Now all the children are dealt with, we can destroy
; 2216 :      * this node too
; 2217 :      */
; 2218 :     thisEntry	= node->buckets;

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00067	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006b	48 89 44 24 20	 mov	 QWORD PTR thisEntry$[rsp], rax
$LN2@freeIntNod:

; 2219 : 
; 2220 :     while (thisEntry != NULL)

  00070	48 83 7c 24 20
	00		 cmp	 QWORD PTR thisEntry$[rsp], 0
  00076	74 4c		 je	 SHORT $LN3@freeIntNod

; 2221 :     {
; 2222 : 	nextEntry   = thisEntry->next;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  0007d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00081	48 89 44 24 28	 mov	 QWORD PTR nextEntry$[rsp], rax

; 2223 : 
; 2224 : 	/* Do we need to call a custom free pointer for this string entry?
; 2225 : 	 */
; 2226 : 	if (thisEntry->type == ANTLR3_HASH_TYPE_STR && thisEntry->freeptr != NULL)

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  0008b	83 38 01	 cmp	 DWORD PTR [rax], 1
  0008e	75 1d		 jne	 SHORT $LN6@freeIntNod
  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  00095	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0009a	74 11		 je	 SHORT $LN6@freeIntNod

; 2227 : 	{
; 2228 : 	    thisEntry->freeptr(thisEntry->data.ptr);

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  000a1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  000aa	ff 50 08	 call	 QWORD PTR [rax+8]
$LN6@freeIntNod:

; 2229 : 	}
; 2230 : 
; 2231 : 	/* Now free the data for this bucket entry
; 2232 : 	 */
; 2233 : 	ANTLR3_FREE(thisEntry);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thisEntry$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2234 : 	thisEntry = nextEntry;	    /* See if there are any more to free    */

  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR nextEntry$[rsp]
  000bd	48 89 44 24 20	 mov	 QWORD PTR thisEntry$[rsp], rax

; 2235 :     }

  000c2	eb ac		 jmp	 SHORT $LN2@freeIntNod
$LN3@freeIntNod:

; 2236 : 
; 2237 :     /* The bucket entry is now gone, so we can free the memory for
; 2238 :      * the entry itself.
; 2239 :      */
; 2240 :     ANTLR3_FREE(node);

  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2241 : 
; 2242 :     /* And that should be it for everything under this node and itself
; 2243 :      */
; 2244 : }

  000cf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
freeIntNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorResize
_TEXT	SEGMENT
newSize$ = 32
vector$ = 64
hint$ = 72
antlr3VectorResize PROC					; COMDAT

; 1290 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1291 : 	ANTLR3_UINT32	newSize;
; 1292 : 
; 1293 : 	// Need to resize the element pointers. We double the allocation
; 1294 : 	// we already have unless asked for a specific increase.
; 1295 :     //
; 1296 :     if (hint == 0 || hint < vector->elementsSize)

  00022	83 7c 24 48 00	 cmp	 DWORD PTR hint$[rsp], 0
  00027	74 11		 je	 SHORT $LN4@antlr3Vect
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0002e	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00034	39 44 24 48	 cmp	 DWORD PTR hint$[rsp], eax
  00038	73 13		 jae	 SHORT $LN2@antlr3Vect
$LN4@antlr3Vect:

; 1297 :     {
; 1298 :         newSize = vector->elementsSize * 2;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0003f	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00045	d1 e0		 shl	 eax, 1
  00047	89 44 24 20	 mov	 DWORD PTR newSize$[rsp], eax

; 1299 :     }

  0004b	eb 0a		 jmp	 SHORT $LN3@antlr3Vect
$LN2@antlr3Vect:

; 1300 :     else
; 1301 :     {
; 1302 :         newSize = hint * 2;

  0004d	8b 44 24 48	 mov	 eax, DWORD PTR hint$[rsp]
  00051	d1 e0		 shl	 eax, 1
  00053	89 44 24 20	 mov	 DWORD PTR newSize$[rsp], eax
$LN3@antlr3Vect:

; 1303 :     }
; 1304 : 
; 1305 :     // Now we know how many we need, so we see if we have just expanded
; 1306 :     // past the built in vector elements or were already past that
; 1307 :     //
; 1308 :     if  (vector->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0005c	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  00063	76 23		 jbe	 SHORT $LN5@antlr3Vect

; 1309 :     {
; 1310 :         // We were already larger than the internal size, so we just
; 1311 :         // use realloc so that the pointers are copied for us
; 1312 :         //
; 1313 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_REALLOC(vector->elements, (sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));

  00065	8b 44 24 20	 mov	 eax, DWORD PTR newSize$[rsp]
  00069	48 6b c0 10	 imul	 rax, rax, 16
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00083	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1314 :     }

  00086	eb 38		 jmp	 SHORT $LN6@antlr3Vect
$LN5@antlr3Vect:

; 1315 :     else
; 1316 :     {
; 1317 :         // The current size was less than or equal to the internal array size and as we always start
; 1318 :         // with a size that is at least the maximum internal size, then we must need to allocate new memory
; 1319 :         // for external pointers. We don't want to take the time to calculate if a requested element
; 1320 :         // is part of the internal or external entries, so we copy the internal ones to the new space
; 1321 :         //
; 1322 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_MALLOC((sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));

  00088	8b 44 24 20	 mov	 eax, DWORD PTR newSize$[rsp]
  0008c	48 6b c0 10	 imul	 rax, rax, 16
  00090	48 8b c8	 mov	 rcx, rax
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0009e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1323 :         ANTLR3_MEMCPY(vector->elements, vector->internal, ANTLR3_VECTOR_INTERNAL_SIZE * sizeof(ANTLR3_VECTOR_ELEMENT));

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a6	48 83 c0 10	 add	 rax, 16
  000aa	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000b8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bb	e8 00 00 00 00	 call	 memcpy
$LN6@antlr3Vect:

; 1324 :     }
; 1325 : 
; 1326 : 	vector->elementsSize	= newSize;

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000c5	8b 4c 24 20	 mov	 ecx, DWORD PTR newSize$[rsp]
  000c9	89 88 14 01 00
	00		 mov	 DWORD PTR [rax+276], ecx

; 1327 : }

  000cf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
antlr3VectorResize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNextEntry
_TEXT	SEGMENT
bucket$ = 0
en$ = 32
antlr3EnumNextEntry PROC				; COMDAT

; 766  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 767  :     pANTLR3_HASH_BUCKET	bucket;
; 768  : 
; 769  :     /* See if the current entry pointer is valid first of all
; 770  :      */
; 771  :     if	(en->entry != NULL)

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00023	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00028	74 28		 je	 SHORT $LN4@antlr3Enum

; 772  :     {
; 773  : 	/* Current entry was a valid point, see if there is another
; 774  : 	 * one in the chain.
; 775  : 	 */
; 776  : 	if  (en->entry->nextEntry != NULL)

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0002f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00033	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00038	74 18		 je	 SHORT $LN5@antlr3Enum

; 777  : 	{
; 778  : 	    /* Next entry in the enumeration is just the next entry
; 779  : 	     * in the chain.
; 780  : 	     */
; 781  : 	    en->entry = en->entry->nextEntry;

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0003f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00048	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 782  : 	    return;

  00050	eb 73		 jmp	 SHORT $LN1@antlr3Enum
$LN5@antlr3Enum:
$LN4@antlr3Enum:

; 783  : 	}
; 784  :     }
; 785  : 
; 786  :     /* There were no more entries in the current bucket, if there are
; 787  :      * more buckets then chase them until we find an entry.
; 788  :      */
; 789  :     en->bucket++;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00057	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0005a	ff c0		 inc	 eax
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00061	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN2@antlr3Enum:

; 790  : 
; 791  :     while   (en->bucket < en->table->modulo)

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00071	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00074	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  00077	73 4c		 jae	 SHORT $LN3@antlr3Enum

; 792  :     {
; 793  : 	/* There was one more bucket, see if it has any elements in it
; 794  : 	 */
; 795  : 	bucket	= en->table->buckets + en->bucket;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0007e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00086	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00089	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008d	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00091	48 89 04 24	 mov	 QWORD PTR bucket$[rsp], rax

; 796  : 
; 797  : 	if  (bucket->entries != NULL)

  00095	48 8b 04 24	 mov	 rax, QWORD PTR bucket$[rsp]
  00099	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0009d	74 12		 je	 SHORT $LN6@antlr3Enum

; 798  : 	{
; 799  : 	    /* There was an entry in this bucket, so we can use it
; 800  : 	     * for the next entry in the enumeration.
; 801  : 	     */
; 802  : 	    en->entry	= bucket->entries;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR bucket$[rsp]
  000a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ab	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 803  : 	    return;

  000af	eb 14		 jmp	 SHORT $LN1@antlr3Enum
$LN6@antlr3Enum:

; 804  : 	}
; 805  : 
; 806  : 	/* There was nothing in the bucket we just examined, move to the
; 807  : 	 * next one.
; 808  : 	 */
; 809  : 	en->bucket++;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  000b6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b9	ff c0		 inc	 eax
  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  000c0	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 810  :     }

  000c3	eb 9f		 jmp	 SHORT $LN2@antlr3Enum
$LN3@antlr3Enum:
$LN1@antlr3Enum:

; 811  : 
; 812  :     /* Here we have exhausted all buckets and the enumeration pointer will 
; 813  :      * have its bucket count = table->modulo which signifies that we are done.
; 814  :      */
; 815  : }

  000c5	48 83 c4 10	 add	 rsp, 16
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
antlr3EnumNextEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT freeTopo
_TEXT	SEGMENT
i$ = 32
edgeList$1 = 40
topo$ = 64
freeTopo PROC						; COMDAT

; 2693 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 2694 :     ANTLR3_UINT32   i;
; 2695 : 
; 2696 :     // Free the result vector
; 2697 :     //
; 2698 :     if  (topo->sorted != NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	74 1c		 je	 SHORT $LN5@freeTopo

; 2699 :     {
; 2700 :         ANTLR3_FREE(topo->sorted);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0002f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2701 :         topo->sorted = NULL;

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0003e	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN5@freeTopo:

; 2702 :     }
; 2703 : 
; 2704 :     // Free the visited map
; 2705 :     //
; 2706 :     if  (topo->visited != NULL)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0004b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00050	74 22		 je	 SHORT $LN6@freeTopo

; 2707 :     {
; 2708 : 
; 2709 :         topo->visited->free(topo->visited);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00057	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00060	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00064	ff 50 70	 call	 QWORD PTR [rax+112]

; 2710 :         topo->visited = NULL;

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0006c	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN6@freeTopo:

; 2711 :     }
; 2712 : 
; 2713 :     // Free any edgemaps
; 2714 :     //
; 2715 :     if  (topo->edges != NULL)

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00079	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0007d	74 5c		 je	 SHORT $LN7@freeTopo

; 2716 :     {
; 2717 :         pANTLR3_BITSET edgeList;
; 2718 : 
; 2719 :         
; 2720 :         for (i=0; i<topo->limit; i++)

  0007f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00087	eb 0a		 jmp	 SHORT $LN4@freeTopo
$LN2@freeTopo:
  00089	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008d	ff c0		 inc	 eax
  0008f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@freeTopo:
  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00098	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0009b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0009f	73 2c		 jae	 SHORT $LN3@freeTopo

; 2721 :         {
; 2722 :             edgeList = *((topo->edges) + i);

  000a1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000aa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ad	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b1	48 89 44 24 28	 mov	 QWORD PTR edgeList$1[rsp], rax

; 2723 :             if  (edgeList != NULL)

  000b6	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeList$1[rsp], 0
  000bc	74 0d		 je	 SHORT $LN8@freeTopo

; 2724 :             {
; 2725 :                 edgeList->free(edgeList);

  000be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR edgeList$1[rsp]
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR edgeList$1[rsp]
  000c8	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@freeTopo:

; 2726 :             }
; 2727 :         }

  000cb	eb bc		 jmp	 SHORT $LN2@freeTopo
$LN3@freeTopo:

; 2728 : 
; 2729 :         ANTLR3_FREE(topo->edges);

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000d2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@freeTopo:

; 2730 :     }
; 2731 :     topo->edges = NULL;

  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000e0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2732 :     
; 2733 :     // Free any cycle map
; 2734 :     //
; 2735 :     if  (topo->cycle != NULL)

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000ec	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000f1	74 0f		 je	 SHORT $LN9@freeTopo

; 2736 :     {
; 2737 :         ANTLR3_FREE(topo->cycle);

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000f8	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@freeTopo:

; 2738 :     }
; 2739 : 
; 2740 :     ANTLR3_FREE(topo);

  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2741 : }

  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
freeTopo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT sortVector
_TEXT	SEGMENT
i$ = 32
vIndex$ = 40
ind$1 = 48
topo$ = 80
v$ = 88
sortVector PROC						; COMDAT

; 2592 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 2593 :     // To sort a vector, we first perform the
; 2594 :     // sort to an array, then use the results to reorder the vector
; 2595 :     // we are given. This is just a convenience routine that allows you to
; 2596 :     // sort the children of a tree node into topological order before or
; 2597 :     // during an AST walk. This can be useful for optimizations that require
; 2598 :     // dag reorders and also when the input stream defines thigns that are
; 2599 :     // interdependent and you want to walk the list of the generated trees
; 2600 :     // for those things in topological order so you can ignore the interdependencies
; 2601 :     // at that point.
; 2602 :     //
; 2603 :     ANTLR3_UINT32 i;
; 2604 : 
; 2605 :     // Used as a lookup index to find the current location in the vector of
; 2606 :     // the vector entry that was originally at position [0], [1], [2] etc
; 2607 :     //
; 2608 :     pANTLR3_UINT32  vIndex;
; 2609 : 
; 2610 :     // Sort into an array, then we can use the array that is
; 2611 :     // stored in the topo
; 2612 :     //
; 2613 :     if  (topo->sortToArray(topo) == 0)

  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0002d	ff 50 38	 call	 QWORD PTR [rax+56]
  00030	48 85 c0	 test	 rax, rax
  00033	75 05		 jne	 SHORT $LN8@sortVector

; 2614 :     {
; 2615 :         return;     // There were no edges

  00035	e9 3a 01 00 00	 jmp	 $LN1@sortVector
$LN8@sortVector:

; 2616 :     }
; 2617 : 
; 2618 :     if  (topo->hasCycle == ANTLR3_TRUE)

  0003a	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0003f	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00043	83 f8 01	 cmp	 eax, 1
  00046	75 05		 jne	 SHORT $LN9@sortVector

; 2619 :     {
; 2620 :         return;  // Do nothing if we detected a cycle

  00048	e9 27 01 00 00	 jmp	 $LN1@sortVector
$LN9@sortVector:

; 2621 :     }
; 2622 : 
; 2623 :     // Ensure that the vector we are sorting is at least as big as the
; 2624 :     // the input sequence we were adsked to sort. It does not matter if it is
; 2625 :     // bigger as thaat probably just means that nodes numbered higher than the
; 2626 :     // limit had no dependencies and so can be left alone.
; 2627 :     //
; 2628 :     if  (topo->limit > v->count)

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00057	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0005a	39 48 20	 cmp	 DWORD PTR [rax+32], ecx
  0005d	76 10		 jbe	 SHORT $LN10@sortVector

; 2629 :     {
; 2630 :         // We can only sort the entries that we have dude! The caller is
; 2631 :         // responsible for ensuring the vector is the correct one and is the
; 2632 :         // correct size etc.
; 2633 :         //
; 2634 :         topo->limit = v->count;

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00064	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00069	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0006c	89 48 20	 mov	 DWORD PTR [rax+32], ecx
$LN10@sortVector:

; 2635 :     }
; 2636 :     // We need to know the locations of each of the entries
; 2637 :     // in the vector as we don't want to duplicate them in a new vector. We
; 2638 :     // just use an indirection table to get the vector entry for a particular sequence
; 2639 :     // acording to where we moved it last. Then we can just swap vector entries until
; 2640 :     // we are done :-)
; 2641 :     //
; 2642 :     vIndex = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00074	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00077	48 c1 e0 02	 shl	 rax, 2
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00084	48 89 44 24 28	 mov	 QWORD PTR vIndex$[rsp], rax

; 2643 : 
; 2644 :     // Start index, each vector entry is located where you think it is
; 2645 :     //
; 2646 :     for (i = 0; i < topo->limit; i++)

  00089	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00091	eb 0a		 jmp	 SHORT $LN4@sortVector
$LN2@sortVector:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00097	ff c0		 inc	 eax
  00099	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@sortVector:
  0009d	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000a2	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000a5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000a9	73 12		 jae	 SHORT $LN3@sortVector

; 2647 :     {
; 2648 :         vIndex[i] = i;

  000ab	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  000b4	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000b8	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2649 :     }

  000bb	eb d6		 jmp	 SHORT $LN2@sortVector
$LN3@sortVector:

; 2650 : 
; 2651 :     // Now we traverse the sorted array and moved the entries of
; 2652 :     // the vector around according to the sort order and the indirection
; 2653 :     // table we just created. The index telsl us where in the vector the
; 2654 :     // original element entry n is now located via vIndex[n].
; 2655 :     //
; 2656 :     for (i=0; i < topo->limit; i++)

  000bd	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c5	eb 0a		 jmp	 SHORT $LN7@sortVector
$LN5@sortVector:
  000c7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000cb	ff c0		 inc	 eax
  000cd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@sortVector:
  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000d6	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000d9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000dd	0f 83 86 00 00
	00		 jae	 $LN6@sortVector

; 2657 :     {
; 2658 :         ANTLR3_UINT32   ind;
; 2659 : 
; 2660 :         // If the vector entry at i is already the one that it
; 2661 :         // should be, then we skip moving it of course.
; 2662 :         //
; 2663 :         if  (vIndex[topo->sorted[i]] == i)

  000e3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000ec	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  000f8	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000fc	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  000ff	75 02		 jne	 SHORT $LN11@sortVector

; 2664 :         {
; 2665 :             continue;

  00101	eb c4		 jmp	 SHORT $LN5@sortVector
$LN11@sortVector:

; 2666 :         }
; 2667 : 
; 2668 :         // The vector entry at i, should be replaced with the
; 2669 :         // vector entry indicated by topo->sorted[i]. The vector entry
; 2670 :         // at topo->sorted[i] may have already been swapped out though, so we
; 2671 :         // find where it is now and move it from there to i.
; 2672 :         //
; 2673 :         ind     = vIndex[topo->sorted[i]];

  00103	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00107	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0010c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00110	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00113	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  00118	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0011b	89 44 24 30	 mov	 DWORD PTR ind$1[rsp], eax

; 2674 :         v->swap(v, i, ind);

  0011f	44 8b 44 24 30	 mov	 r8d, DWORD PTR ind$1[rsp]
  00124	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00128	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0012d	48 8b 44 24 58	 mov	 rax, QWORD PTR v$[rsp]
  00132	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 2675 : 
; 2676 :         // Update our index. The element at i is now the one we wanted
; 2677 :         // to be sorted here and the element we swapped out is now the
; 2678 :         // element that was at i just before we swapped it. If you are lost now
; 2679 :         // don't worry about it, we are just reindexing on the fly is all.
; 2680 :         //
; 2681 :         vIndex[topo->sorted[i]] = i;

  00138	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0013c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00141	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00145	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00148	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  0014d	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00151	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2682 :         vIndex[i] = ind;

  00154	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  0015d	8b 54 24 30	 mov	 edx, DWORD PTR ind$1[rsp]
  00161	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2683 :     }

  00164	e9 5e ff ff ff	 jmp	 $LN5@sortVector
$LN6@sortVector:

; 2684 : 
; 2685 :     // Having traversed all the entries, we have sorted the vector in place.
; 2686 :     //
; 2687 :     ANTLR3_FREE(vIndex);

  00169	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@sortVector:

; 2688 :     return;
; 2689 : }

  00174	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
sortVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT sortToArray
_TEXT	SEGMENT
v$ = 32
oldLimit$ = 36
topo$ = 64
sortToArray PROC					; COMDAT

; 2524 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 2525 :     ANTLR3_UINT32 v;
; 2526 :     ANTLR3_UINT32 oldLimit;
; 2527 : 
; 2528 :     // Guard against being called with no edges defined
; 2529 :     //
; 2530 :     if  (topo->edges == NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00023	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00027	75 07		 jne	 SHORT $LN5@sortToArra

; 2531 :     {
; 2532 :         return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 d7 00 00 00	 jmp	 $LN1@sortToArra
$LN5@sortToArra:

; 2533 :     }
; 2534 :     // First we need a vector to populate with enough
; 2535 :     // entries to accomodate the sorted list and another to accomodate
; 2536 :     // the maximum cycle we could detect which is all nodes such as 0->1->2->3->0
; 2537 :     //
; 2538 :     topo->sorted    = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00035	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00038	48 c1 e0 02	 shl	 rax, 2
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0004a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2539 :     topo->cycle     = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00053	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00056	48 c1 e0 02	 shl	 rax, 2
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00068	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2540 : 
; 2541 :     // Next we need an empty bitset to show whether we have visited a node
; 2542 :     // or not. This is the bit that gives us linear time of course as we are essentially
; 2543 :     // dropping through the nodes in depth first order and when we get to a node that
; 2544 :     // has no edges, we pop back up the stack adding the nodes we traversed in reverse
; 2545 :     // order.
; 2546 :     //
; 2547 :     topo->visited   = antlr3BitsetNew(0);

  0006c	33 c9		 xor	 ecx, ecx
  0006e	e8 00 00 00 00	 call	 antlr3BitsetNew
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00078	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 2548 : 
; 2549 :     // Now traverse the nodes as if we were just going left to right, but
; 2550 :     // then descend each node unless it has already been visited.
; 2551 :     //
; 2552 :     oldLimit    = topo->limit;     // Number of nodes to traverse linearly

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00081	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00084	89 44 24 24	 mov	 DWORD PTR oldLimit$[rsp], eax

; 2553 :     topo->limit = 0;               // Next entry in the sorted table

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0008d	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 2554 : 
; 2555 :     for (v = 0; v < oldLimit; v++)

  00094	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR v$[rsp], 0
  0009c	eb 0a		 jmp	 SHORT $LN4@sortToArra
$LN2@sortToArra:
  0009e	8b 44 24 20	 mov	 eax, DWORD PTR v$[rsp]
  000a2	ff c0		 inc	 eax
  000a4	89 44 24 20	 mov	 DWORD PTR v$[rsp], eax
$LN4@sortToArra:
  000a8	8b 44 24 24	 mov	 eax, DWORD PTR oldLimit$[rsp]
  000ac	39 44 24 20	 cmp	 DWORD PTR v$[rsp], eax
  000b0	73 40		 jae	 SHORT $LN3@sortToArra

; 2556 :     {
; 2557 :         // If we did not already visit this node, then descend it until we
; 2558 :         // get a node without edges or arrive at a node we have already visited.
; 2559 :         //
; 2560 :         if  (topo->visited->isMember(topo->visited, v) == ANTLR3_FALSE)

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000b7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000bb	8b 54 24 20	 mov	 edx, DWORD PTR v$[rsp]
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000c4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000c8	ff 50 48	 call	 QWORD PTR [rax+72]
  000cb	0f b6 c0	 movzx	 eax, al
  000ce	85 c0		 test	 eax, eax
  000d0	75 0e		 jne	 SHORT $LN6@sortToArra

; 2561 :         {
; 2562 :             // We have not visited this one so descend it
; 2563 :             //
; 2564 :             DFS(topo, v);

  000d2	8b 54 24 20	 mov	 edx, DWORD PTR v$[rsp]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000db	e8 00 00 00 00	 call	 DFS
$LN6@sortToArra:

; 2565 :         }
; 2566 : 
; 2567 :         // Break the loop if we detect a cycle as we have no need to go any
; 2568 :         // further
; 2569 :         //
; 2570 :         if  (topo->hasCycle == ANTLR3_TRUE)

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000e5	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	75 02		 jne	 SHORT $LN7@sortToArra

; 2571 :         {
; 2572 :             break;

  000ee	eb 02		 jmp	 SHORT $LN3@sortToArra
$LN7@sortToArra:

; 2573 :         }
; 2574 :     }

  000f0	eb ac		 jmp	 SHORT $LN2@sortToArra
$LN3@sortToArra:

; 2575 : 
; 2576 :     // Reset the limit to the number we recorded as if we hit a
; 2577 :     // cycle, then limit will have stopped at the node where we
; 2578 :     // discovered the cycle, but in order to free the edge bitmaps
; 2579 :     // we need to know how many we may have allocated and traverse them all.
; 2580 :     //
; 2581 :     topo->limit = oldLimit;

  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000f7	8b 4c 24 24	 mov	 ecx, DWORD PTR oldLimit$[rsp]
  000fb	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 2582 : 
; 2583 :     // Having traversed all the nodes we were given, we
; 2584 :     // are guaranteed to have ordered all the nodes or detected a
; 2585 :     // cycle.
; 2586 :     //
; 2587 :     return topo->sorted;

  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00103	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@sortToArra:

; 2588 : }

  00107	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
sortToArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT addEdge
_TEXT	SEGMENT
i$ = 32
maxEdge$ = 36
edgeDeps$ = 40
topo$ = 64
edge$ = 72
dependency$ = 80
addEdge	PROC						; COMDAT

; 2317 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 2318 :     ANTLR3_UINT32   i;
; 2319 :     ANTLR3_UINT32   maxEdge;
; 2320 :     pANTLR3_BITSET  edgeDeps;
; 2321 : 
; 2322 :     if (edge>dependency)

  00027	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  0002b	39 44 24 48	 cmp	 DWORD PTR edge$[rsp], eax
  0002f	76 0a		 jbe	 SHORT $LN5@addEdge

; 2323 :     {
; 2324 :         maxEdge = edge;

  00031	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  00035	89 44 24 24	 mov	 DWORD PTR maxEdge$[rsp], eax

; 2325 :     }

  00039	eb 08		 jmp	 SHORT $LN6@addEdge
$LN5@addEdge:

; 2326 :     else
; 2327 :     {
; 2328 :         maxEdge = dependency;

  0003b	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  0003f	89 44 24 24	 mov	 DWORD PTR maxEdge$[rsp], eax
$LN6@addEdge:

; 2329 :     }
; 2330 :     // We need to add an edge to says that the node indexed by 'edge' is
; 2331 :     // dependent on the node indexed by 'dependency'
; 2332 :     //
; 2333 : 
; 2334 :     // First see if we have enough room in the edges array to add the edge?
; 2335 :     //
; 2336 :     if (topo->edges == NULL)

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	75 45		 jne	 SHORT $LN7@addEdge

; 2337 :     {
; 2338 :         // We don't have any edges yet, so create an array to hold them
; 2339 :         //
; 2340 :         topo->edges = ANTLR3_CALLOC(sizeof(pANTLR3_BITSET) * (maxEdge + 1), 1);

  0004e	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  00052	ff c0		 inc	 eax
  00054	8b c0		 mov	 eax, eax
  00056	48 c1 e0 03	 shl	 rax, 3
  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	48 8b c8	 mov	 rcx, rax
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0006d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2341 :         if (topo->edges == NULL)

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00075	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00079	75 05		 jne	 SHORT $LN9@addEdge

; 2342 :         {
; 2343 :             return;

  0007b	e9 01 01 00 00	 jmp	 $LN1@addEdge
$LN9@addEdge:

; 2344 :         }
; 2345 : 
; 2346 :         // Set the limit to what we have now
; 2347 :         //
; 2348 :         topo->limit = maxEdge + 1;

  00080	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  00084	ff c0		 inc	 eax
  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0008b	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 2349 :     }

  0008e	e9 89 00 00 00	 jmp	 $LN8@addEdge
$LN7@addEdge:

; 2350 :     else if (topo->limit <= maxEdge)

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00098	8b 4c 24 24	 mov	 ecx, DWORD PTR maxEdge$[rsp]
  0009c	39 48 20	 cmp	 DWORD PTR [rax+32], ecx
  0009f	77 7b		 ja	 SHORT $LN10@addEdge

; 2351 :     {
; 2352 :         // WE have some edges but not enough
; 2353 :         //
; 2354 :         topo->edges = ANTLR3_REALLOC(topo->edges, sizeof(pANTLR3_BITSET) * (maxEdge + 1));

  000a1	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	8b c0		 mov	 eax, eax
  000a9	48 c1 e0 03	 shl	 rax, 3
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000b5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000c3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2355 :         if (topo->edges == NULL)

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000cb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000cf	75 05		 jne	 SHORT $LN11@addEdge

; 2356 :         {
; 2357 :             return;

  000d1	e9 ab 00 00 00	 jmp	 $LN1@addEdge
$LN11@addEdge:

; 2358 :         }
; 2359 : 
; 2360 :         // Initialize the new bitmaps to ;indicate we have no edges defined yet
; 2361 :         //
; 2362 :         for (i = topo->limit; i <= maxEdge; i++)

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000db	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000de	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000e2	eb 0a		 jmp	 SHORT $LN4@addEdge
$LN2@addEdge:
  000e4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e8	ff c0		 inc	 eax
  000ea	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@addEdge:
  000ee	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  000f2	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000f6	77 16		 ja	 SHORT $LN3@addEdge

; 2363 :         {
; 2364 :             *((topo->edges) + i) = NULL;

  000f8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00101	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00104	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 2365 :         }

  0010c	eb d6		 jmp	 SHORT $LN2@addEdge
$LN3@addEdge:

; 2366 : 
; 2367 :         // Set the limit to what we have now
; 2368 :         //
; 2369 :         topo->limit = maxEdge + 1;

  0010e	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  00112	ff c0		 inc	 eax
  00114	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00119	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN10@addEdge:
$LN8@addEdge:

; 2370 :     }
; 2371 : 
; 2372 :     // If the edge was flagged as depending on itself, then we just
; 2373 :     // do nothing as it means this routine was just called to add it
; 2374 :     // in to the list of nodes.
; 2375 :     //
; 2376 :     if  (edge == dependency)

  0011c	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  00120	39 44 24 48	 cmp	 DWORD PTR edge$[rsp], eax
  00124	75 02		 jne	 SHORT $LN12@addEdge

; 2377 :     {
; 2378 :         return;

  00126	eb 59		 jmp	 SHORT $LN1@addEdge
$LN12@addEdge:

; 2379 :     }
; 2380 : 
; 2381 :     // Pick up the bit map for the requested edge
; 2382 :     //
; 2383 :     edgeDeps = *((topo->edges) + edge);

  00128	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  0012c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00131	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00134	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00138	48 89 44 24 28	 mov	 QWORD PTR edgeDeps$[rsp], rax

; 2384 : 
; 2385 :     if  (edgeDeps == NULL)

  0013d	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeDeps$[rsp], 0
  00143	75 2b		 jne	 SHORT $LN13@addEdge

; 2386 :     {
; 2387 :         // No edges are defined yet for this node
; 2388 :         //
; 2389 :         edgeDeps                = antlr3BitsetNew(0);

  00145	33 c9		 xor	 ecx, ecx
  00147	e8 00 00 00 00	 call	 antlr3BitsetNew
  0014c	48 89 44 24 28	 mov	 QWORD PTR edgeDeps$[rsp], rax

; 2390 :         *((topo->edges) + edge) = edgeDeps;

  00151	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0015a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0015d	48 8b 54 24 28	 mov	 rdx, QWORD PTR edgeDeps$[rsp]
  00162	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2391 :         if (edgeDeps == NULL )

  00166	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeDeps$[rsp], 0
  0016c	75 02		 jne	 SHORT $LN14@addEdge

; 2392 :         {
; 2393 :             return;  // Out of memory

  0016e	eb 11		 jmp	 SHORT $LN1@addEdge
$LN14@addEdge:
$LN13@addEdge:

; 2394 :         }
; 2395 :     }
; 2396 : 
; 2397 :     // Set the bit in the bitmap that corresponds to the requested
; 2398 :     // dependency.
; 2399 :     //
; 2400 :     edgeDeps->add(edgeDeps, dependency);

  00170	8b 54 24 50	 mov	 edx, DWORD PTR dependency$[rsp]
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR edgeDeps$[rsp]
  00179	48 8b 44 24 28	 mov	 rax, QWORD PTR edgeDeps$[rsp]
  0017e	ff 50 30	 call	 QWORD PTR [rax+48]
$LN1@addEdge:

; 2401 : 
; 2402 :     // And we are all set
; 2403 :     //
; 2404 :     return;
; 2405 : }

  00181	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00185	5f		 pop	 rdi
  00186	c3		 ret	 0
addEdge	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieFree
_TEXT	SEGMENT
trie$ = 48
intTrieFree PROC					; COMDAT

; 2250 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 2251 :     /* Descend from the root and free all the nodes
; 2252 :      */
; 2253 :     freeIntNode(trie->root);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR trie$[rsp]
  00023	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00026	e8 00 00 00 00	 call	 freeIntNode

; 2254 : 
; 2255 :     /* the nodes are all gone now, so we need only free the memory
; 2256 :      * for the structure itself
; 2257 :      */
; 2258 :     ANTLR3_FREE(trie);

  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR trie$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2259 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
intTrieFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieAdd
_TEXT	SEGMENT
thisNode$ = 32
nextNode$ = 40
entNode$ = 48
depth$ = 56
newEnt$ = 64
nextEnt$ = 72
xorKey$ = 80
trie$ = 112
key$ = 120
type$ = 128
intVal$ = 136
data$ = 144
freeptr$ = 152
intTrieAdd PROC						; COMDAT

; 1914 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 1915 : 	pANTLR3_INT_TRIE_NODE   thisNode;
; 1916 : 	pANTLR3_INT_TRIE_NODE   nextNode;
; 1917 : 	pANTLR3_INT_TRIE_NODE   entNode;
; 1918 : 	ANTLR3_UINT32			depth;
; 1919 : 	pANTLR3_TRIE_ENTRY	    newEnt;
; 1920 : 	pANTLR3_TRIE_ENTRY	    nextEnt;
; 1921 : 	ANTLR3_INTKEY		    xorKey;
; 1922 : 
; 1923 : 	/* Cache the bit depth of this trie, which is always the highest index, 
; 1924 : 	 * which is in the root node
; 1925 : 	 */
; 1926 : 	depth   = trie->root->bitNum;

  0002d	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	8b 00		 mov	 eax, DWORD PTR [rax]
  00037	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 1927 : 
; 1928 : 	thisNode	= trie->root;		/* Start with the root node	    */

  0003b	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 1929 : 	nextNode	= trie->root->leftN;	/* And assume we start to the left  */

  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00054	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax
$LN2@intTrieAdd:

; 1930 : 
; 1931 : 	/* Now find the only node that can be currently reached by the bits in the
; 1932 : 	 * key we are being asked to insert.
; 1933 : 	 */
; 1934 : 	while (thisNode->bitNum  > nextNode->bitNum)

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00063	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00065	39 08		 cmp	 DWORD PTR [rax], ecx
  00067	76 4c		 jbe	 SHORT $LN3@intTrieAdd

; 1935 : 	{
; 1936 : 		/* Still descending the structure, next node becomes current.
; 1937 : 		 */
; 1938 : 		thisNode = nextNode;

  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  0006e	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 1939 : 
; 1940 : 		if (key & bitMask[nextNode->bitNum])

  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00078	8b 00		 mov	 eax, DWORD PTR [rax]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  00081	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00085	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  0008a	48 23 c8	 and	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 85 c0	 test	 rax, rax
  00093	74 10		 je	 SHORT $LN8@intTrieAdd

; 1941 : 		{
; 1942 : 			/* Bit at the required index was 1, so travers the right node from here
; 1943 : 			 */
; 1944 : 			nextNode = nextNode->rightN;

  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  0009a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0009e	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax

; 1945 : 		}

  000a3	eb 0e		 jmp	 SHORT $LN9@intTrieAdd
$LN8@intTrieAdd:

; 1946 : 		else
; 1947 : 		{
; 1948 : 			/* Bit at the required index was 0, so we traverse to the left
; 1949 : 			 */
; 1950 : 			nextNode = nextNode->leftN;

  000a5	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  000aa	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ae	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax
$LN9@intTrieAdd:

; 1951 : 		}
; 1952 : 	}

  000b3	eb a4		 jmp	 SHORT $LN2@intTrieAdd
$LN3@intTrieAdd:

; 1953 : 	/* Here we have located the only node that can be reached by the
; 1954 : 	 * bits in the requested key. It could in fact be that key or the node
; 1955 : 	 * we need to use to insert the new key.
; 1956 : 	 */
; 1957 : 	if (nextNode->key == key)

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  000ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  000bf	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000c3	0f 85 dd 00 00
	00		 jne	 $LN10@intTrieAdd

; 1958 : 	{
; 1959 : 		/* We have located an exact match, but we will only append to the bucket chain
; 1960 : 		 * if this trie accepts duplicate keys.
; 1961 : 		 */
; 1962 : 		if (trie->allowDups ==ANTLR3_TRUE)

  000c9	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  000ce	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	0f 85 c4 00 00
	00		 jne	 $LN11@intTrieAdd

; 1963 : 		{
; 1964 : 			/* Yes, we are accepting duplicates
; 1965 : 			 */
; 1966 : 			newEnt = (pANTLR3_TRIE_ENTRY)ANTLR3_CALLOC(1, sizeof(ANTLR3_TRIE_ENTRY));

  000db	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000eb	48 89 44 24 40	 mov	 QWORD PTR newEnt$[rsp], rax

; 1967 : 
; 1968 : 			if (newEnt == NULL)

  000f0	48 83 7c 24 40
	00		 cmp	 QWORD PTR newEnt$[rsp], 0
  000f6	75 07		 jne	 SHORT $LN13@intTrieAdd

; 1969 : 			{
; 1970 : 				/* Out of memory, all we can do is return the fact that the insert failed.
; 1971 : 				 */
; 1972 : 				return	ANTLR3_FALSE;

  000f8	32 c0		 xor	 al, al
  000fa	e9 95 04 00 00	 jmp	 $LN1@intTrieAdd
$LN13@intTrieAdd:

; 1973 : 			}
; 1974 : 
; 1975 : 			/* Otherwise insert this in the chain
; 1976 : 			*/
; 1977 : 			newEnt->type	= type;

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00104	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  0010b	89 08		 mov	 DWORD PTR [rax], ecx

; 1978 : 			newEnt->freeptr	= freeptr;

  0010d	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00112	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR freeptr$[rsp]
  0011a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1979 : 			if (type == ANTLR3_HASH_TYPE_STR)

  0011e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00126	75 13		 jne	 SHORT $LN14@intTrieAdd

; 1980 : 			{
; 1981 : 				newEnt->data.ptr = data;

  00128	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  0012d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00135	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1982 : 			}

  00139	eb 11		 jmp	 SHORT $LN15@intTrieAdd
$LN14@intTrieAdd:

; 1983 : 			else
; 1984 : 			{
; 1985 : 				newEnt->data.intVal = intVal;

  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00140	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR intVal$[rsp]
  00148	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN15@intTrieAdd:

; 1986 : 			}
; 1987 : 
; 1988 : 			/* We want to be able to traverse the stored elements in the order that they were
; 1989 : 			 * added as duplicate keys. We might need to revise this opinion if we end up having many duplicate keys
; 1990 : 			 * as perhaps reverse order is just as good, so long as it is ordered.
; 1991 : 			 */
; 1992 : 			nextEnt = nextNode->buckets;

  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00151	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00155	48 89 44 24 48	 mov	 QWORD PTR nextEnt$[rsp], rax
$LN4@intTrieAdd:

; 1993 : 			while (nextEnt->next != NULL)

  0015a	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  0015f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00164	74 10		 je	 SHORT $LN5@intTrieAdd

; 1994 : 			{
; 1995 : 				nextEnt = nextEnt->next;    

  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  0016b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0016f	48 89 44 24 48	 mov	 QWORD PTR nextEnt$[rsp], rax

; 1996 : 			}

  00174	eb e4		 jmp	 SHORT $LN4@intTrieAdd
$LN5@intTrieAdd:

; 1997 : 			nextEnt->next = newEnt;

  00176	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  0017b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newEnt$[rsp]
  00180	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1998 : 
; 1999 : 			trie->count++;

  00184	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00189	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0018c	ff c0		 inc	 eax
  0018e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trie$[rsp]
  00193	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2000 : 			return  ANTLR3_TRUE;

  00196	b0 01		 mov	 al, 1
  00198	e9 f7 03 00 00	 jmp	 $LN1@intTrieAdd

; 2001 : 		}

  0019d	eb 07		 jmp	 SHORT $LN12@intTrieAdd
$LN11@intTrieAdd:

; 2002 : 		else
; 2003 : 		{
; 2004 : 			/* We found the key is already there and we are not allowed duplicates in this
; 2005 : 			 * trie.
; 2006 : 			 */
; 2007 : 			return  ANTLR3_FALSE;

  0019f	32 c0		 xor	 al, al
  001a1	e9 ee 03 00 00	 jmp	 $LN1@intTrieAdd
$LN12@intTrieAdd:
$LN10@intTrieAdd:

; 2008 : 		}
; 2009 : 	}
; 2010 : 
; 2011 : 	/* Here we have discovered the only node that can be reached by the bits in the key
; 2012 : 	 * but we have found that this node is not the key we need to insert. We must find the
; 2013 : 	 * the leftmost bit by which the current key for that node and the new key we are going 
; 2014 : 	 * to insert, differ. While this nested series of ifs may look a bit strange, experimentation
; 2015 : 	 * showed that it allows a machine code path that works well with predicated execution
; 2016 : 	 */
; 2017 : 	xorKey = (key ^ nextNode->key);   /* Gives 1 bits only where they differ then we find the left most 1 bit*/

  001a6	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  001ab	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  001b4	48 33 c8	 xor	 rcx, rax
  001b7	48 8b c1	 mov	 rax, rcx
  001ba	48 89 44 24 50	 mov	 QWORD PTR xorKey$[rsp], rax

; 2018 : 
; 2019 : 	/* Most common case is a 32 bit key really
; 2020 : 	 */
; 2021 : #ifdef	ANTLR3_USE_64BIT
; 2022 : 	if	(xorKey & 0xFFFFFFFF00000000)

  001bf	48 b8 00 00 00
	00 ff ff ff ff	 mov	 rax, -4294967296	; ffffffff00000000H
  001c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  001ce	48 23 c8	 and	 rcx, rax
  001d1	48 8b c1	 mov	 rax, rcx
  001d4	48 85 c0	 test	 rax, rax
  001d7	0f 84 05 01 00
	00		 je	 $LN16@intTrieAdd

; 2023 : 	{
; 2024 : 		if  (xorKey & 0xFFFF000000000000)

  001dd	48 b8 00 00 00
	00 00 00 ff ff	 mov	 rax, -281474976710656	; ffff000000000000H
  001e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  001ec	48 23 c8	 and	 rcx, rax
  001ef	48 8b c1	 mov	 rax, rcx
  001f2	48 85 c0	 test	 rax, rax
  001f5	74 74		 je	 SHORT $LN18@intTrieAdd

; 2025 : 		{
; 2026 : 			if	(xorKey & 0xFF00000000000000)

  001f7	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00206	48 23 c8	 and	 rcx, rax
  00209	48 8b c1	 mov	 rax, rcx
  0020c	48 85 c0	 test	 rax, rax
  0020f	74 2d		 je	 SHORT $LN20@intTrieAdd

; 2027 : 			{
; 2028 : 				depth = 56 + bitIndex[((xorKey & 0xFF00000000000000)>>56)];

  00211	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  0021b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00220	48 23 c8	 and	 rcx, rax
  00223	48 8b c1	 mov	 rax, rcx
  00226	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00231	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00235	83 c0 38	 add	 eax, 56			; 00000038H
  00238	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2029 : 			}

  0023c	eb 2b		 jmp	 SHORT $LN21@intTrieAdd
$LN20@intTrieAdd:

; 2030 : 			else
; 2031 : 			{
; 2032 : 				depth = 48 + bitIndex[((xorKey & 0x00FF000000000000)>>48)];

  0023e	48 b8 00 00 00
	00 00 00 ff 00	 mov	 rax, 71776119061217280	; 00ff000000000000H
  00248	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  0024d	48 23 c8	 and	 rcx, rax
  00250	48 8b c1	 mov	 rax, rcx
  00253	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0025e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00262	83 c0 30	 add	 eax, 48			; 00000030H
  00265	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN21@intTrieAdd:

; 2033 : 			}
; 2034 : 		}

  00269	eb 72		 jmp	 SHORT $LN19@intTrieAdd
$LN18@intTrieAdd:

; 2035 : 		else
; 2036 : 		{
; 2037 : 			if	(xorKey & 0x0000FF0000000000)

  0026b	48 b8 00 00 00
	00 00 ff 00 00	 mov	 rax, 280375465082880	; 0000ff0000000000H
  00275	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  0027a	48 23 c8	 and	 rcx, rax
  0027d	48 8b c1	 mov	 rax, rcx
  00280	48 85 c0	 test	 rax, rax
  00283	74 2d		 je	 SHORT $LN22@intTrieAdd

; 2038 : 			{
; 2039 : 				depth = 40 + bitIndex[((xorKey & 0x0000FF0000000000)>>40)];

  00285	48 b8 00 00 00
	00 00 ff 00 00	 mov	 rax, 280375465082880	; 0000ff0000000000H
  0028f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00294	48 23 c8	 and	 rcx, rax
  00297	48 8b c1	 mov	 rax, rcx
  0029a	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  002a5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a9	83 c0 28	 add	 eax, 40			; 00000028H
  002ac	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2040 : 			}

  002b0	eb 2b		 jmp	 SHORT $LN23@intTrieAdd
$LN22@intTrieAdd:

; 2041 : 			else
; 2042 : 			{
; 2043 : 				depth = 32 + bitIndex[((xorKey & 0x000000FF00000000)>>32)];

  002b2	48 b8 00 00 00
	00 ff 00 00 00	 mov	 rax, 1095216660480	; 000000ff00000000H
  002bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  002c1	48 23 c8	 and	 rcx, rax
  002c4	48 8b c1	 mov	 rax, rcx
  002c7	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  002d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d6	83 c0 20	 add	 eax, 32			; 00000020H
  002d9	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN23@intTrieAdd:
$LN19@intTrieAdd:

; 2044 : 			}
; 2045 : 		}
; 2046 : 	}

  002dd	e9 c2 00 00 00	 jmp	 $LN17@intTrieAdd
$LN16@intTrieAdd:

; 2047 : 	else
; 2048 : #endif
; 2049 : 	{
; 2050 : 		if  (xorKey & 0x00000000FFFF0000)

  002e2	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  002e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  002ec	48 23 c8	 and	 rcx, rax
  002ef	48 8b c1	 mov	 rax, rcx
  002f2	48 85 c0	 test	 rax, rax
  002f5	74 60		 je	 SHORT $LN24@intTrieAdd

; 2051 : 		{
; 2052 : 			if	(xorKey & 0x00000000FF000000)

  002f7	b8 00 00 00 ff	 mov	 eax, -16777216		; ff000000H
  002fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00301	48 23 c8	 and	 rcx, rax
  00304	48 8b c1	 mov	 rax, rcx
  00307	48 85 c0	 test	 rax, rax
  0030a	74 28		 je	 SHORT $LN26@intTrieAdd

; 2053 : 			{
; 2054 : 				depth = 24 + bitIndex[((xorKey & 0x00000000FF000000)>>24)];

  0030c	b8 00 00 00 ff	 mov	 eax, -16777216		; ff000000H
  00311	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00316	48 23 c8	 and	 rcx, rax
  00319	48 8b c1	 mov	 rax, rcx
  0031c	48 c1 e8 18	 shr	 rax, 24
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00327	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032b	83 c0 18	 add	 eax, 24
  0032e	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2055 : 			}

  00332	eb 21		 jmp	 SHORT $LN27@intTrieAdd
$LN26@intTrieAdd:

; 2056 : 			else
; 2057 : 			{
; 2058 : 				depth = 16 + bitIndex[((xorKey & 0x0000000000FF0000)>>16)];

  00334	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  00339	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  0033f	48 c1 e8 10	 shr	 rax, 16
  00343	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0034a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034e	83 c0 10	 add	 eax, 16
  00351	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN27@intTrieAdd:

; 2059 : 			}
; 2060 : 		}

  00355	eb 4d		 jmp	 SHORT $LN25@intTrieAdd
$LN24@intTrieAdd:

; 2061 : 		else
; 2062 : 		{
; 2063 : 			if	(xorKey & 0x000000000000FF00)

  00357	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  0035c	48 25 00 ff 00
	00		 and	 rax, 65280		; 0000ff00H
  00362	48 85 c0	 test	 rax, rax
  00365	74 23		 je	 SHORT $LN28@intTrieAdd

; 2064 : 			{
; 2065 : 				depth = 8 + bitIndex[((xorKey & 0x0000000000000FF00)>>8)];

  00367	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  0036c	48 25 00 ff 00
	00		 and	 rax, 65280		; 0000ff00H
  00372	48 c1 e8 08	 shr	 rax, 8
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0037d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00381	83 c0 08	 add	 eax, 8
  00384	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2066 : 			}

  00388	eb 1a		 jmp	 SHORT $LN29@intTrieAdd
$LN28@intTrieAdd:

; 2067 : 			else
; 2068 : 			{
; 2069 : 				depth = bitIndex[xorKey & 0x00000000000000FF];

  0038a	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  0038f	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0039c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a0	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN29@intTrieAdd:
$LN25@intTrieAdd:
$LN17@intTrieAdd:

; 2070 : 			}
; 2071 : 		}
; 2072 : 	}
; 2073 : 
; 2074 :     /* We have located the leftmost differing bit, indicated by the depth variable. So, we know what
; 2075 :      * bit index we are to insert the new entry at. There are two cases, being where the two keys
; 2076 :      * differ at a bit position that is not currently part of the bit testing, where they differ on a bit
; 2077 :      * that is currently being skipped in the indexed comparisons, and where they differ on a bit
; 2078 :      * that is merely lower down in the current bit search. If the bit index went bit 4, bit 2 and they differ
; 2079 :      * at bit 3, then we have the "skipped" bit case. But if that chain was Bit 4, Bit 2 and they differ at bit 1
; 2080 :      * then we have the easy bit <pun>.
; 2081 :      *
; 2082 :      * So, set up to descend the tree again, but this time looking for the insert point
; 2083 :      * according to whether we skip the bit that differs or not.
; 2084 :      */
; 2085 :     thisNode	= trie->root;

  003a4	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  003a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ac	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 2086 :     entNode	= trie->root->leftN;

  003b1	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  003b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003b9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003bd	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax
$LN6@intTrieAdd:

; 2087 : 
; 2088 :     /* Note the slight difference in the checks here to cover both cases
; 2089 :      */
; 2090 :     while (thisNode->bitNum > entNode->bitNum && entNode->bitNum > depth)

  003c2	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  003c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  003cc	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003ce	39 08		 cmp	 DWORD PTR [rax], ecx
  003d0	76 59		 jbe	 SHORT $LN7@intTrieAdd
  003d2	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003d7	8b 4c 24 38	 mov	 ecx, DWORD PTR depth$[rsp]
  003db	39 08		 cmp	 DWORD PTR [rax], ecx
  003dd	76 4c		 jbe	 SHORT $LN7@intTrieAdd

; 2091 :     {
; 2092 : 	/* Still descending the structure, next node becomes current.
; 2093 : 	 */
; 2094 : 	thisNode = entNode;

  003df	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003e4	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 2095 : 
; 2096 : 	if (key & bitMask[entNode->bitNum])

  003e9	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003ee	8b 00		 mov	 eax, DWORD PTR [rax]
  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  003f7	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  00400	48 23 c8	 and	 rcx, rax
  00403	48 8b c1	 mov	 rax, rcx
  00406	48 85 c0	 test	 rax, rax
  00409	74 10		 je	 SHORT $LN30@intTrieAdd

; 2097 : 	{
; 2098 : 	    /* Bit at the required index was 1, so traverse the right node from here
; 2099 : 	     */
; 2100 : 	    entNode = entNode->rightN;

  0040b	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  00410	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00414	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax

; 2101 : 	}

  00419	eb 0e		 jmp	 SHORT $LN31@intTrieAdd
$LN30@intTrieAdd:

; 2102 : 	else
; 2103 : 	{
; 2104 : 	    /* Bit at the required index was 0, so we traverse to the left
; 2105 : 	     */
; 2106 : 	    entNode = entNode->leftN;

  0041b	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  00420	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00424	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax
$LN31@intTrieAdd:

; 2107 : 	}
; 2108 :     }

  00429	eb 97		 jmp	 SHORT $LN6@intTrieAdd
$LN7@intTrieAdd:

; 2109 : 
; 2110 :     /* We have located the correct insert point for this new key, so we need
; 2111 :      * to allocate our entry and insert it etc.
; 2112 :      */
; 2113 :     nextNode	= (pANTLR3_INT_TRIE_NODE)ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE_NODE));

  0042b	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00430	b9 01 00 00 00	 mov	 ecx, 1
  00435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0043b	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax

; 2114 :     if (nextNode == NULL)

  00440	48 83 7c 24 28
	00		 cmp	 QWORD PTR nextNode$[rsp], 0
  00446	75 07		 jne	 SHORT $LN32@intTrieAdd

; 2115 :     {
; 2116 : 	/* All that work and no memory - bummer.
; 2117 : 	 */
; 2118 : 	return	ANTLR3_FALSE;

  00448	32 c0		 xor	 al, al
  0044a	e9 45 01 00 00	 jmp	 $LN1@intTrieAdd
$LN32@intTrieAdd:

; 2119 :     }
; 2120 : 
; 2121 :     /* Build a new entry block for the new node
; 2122 :      */
; 2123 :     newEnt = (pANTLR3_TRIE_ENTRY)ANTLR3_CALLOC(1, sizeof(ANTLR3_TRIE_ENTRY));

  0044f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00454	b9 01 00 00 00	 mov	 ecx, 1
  00459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0045f	48 89 44 24 40	 mov	 QWORD PTR newEnt$[rsp], rax

; 2124 : 
; 2125 :     if (newEnt == NULL)

  00464	48 83 7c 24 40
	00		 cmp	 QWORD PTR newEnt$[rsp], 0
  0046a	75 07		 jne	 SHORT $LN33@intTrieAdd

; 2126 :     {
; 2127 : 	/* Out of memory, all we can do is return the fact that the insert failed.
; 2128 : 	 */
; 2129 : 	return	ANTLR3_FALSE;

  0046c	32 c0		 xor	 al, al
  0046e	e9 21 01 00 00	 jmp	 $LN1@intTrieAdd
$LN33@intTrieAdd:

; 2130 :     }
; 2131 : 
; 2132 :     /* Otherwise enter this in our new node
; 2133 :     */
; 2134 :     newEnt->type	= type;

  00473	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00478	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  0047f	89 08		 mov	 DWORD PTR [rax], ecx

; 2135 :     newEnt->freeptr	= freeptr;

  00481	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00486	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR freeptr$[rsp]
  0048e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2136 :     if (type == ANTLR3_HASH_TYPE_STR)

  00492	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  0049a	75 13		 jne	 SHORT $LN34@intTrieAdd

; 2137 :     {
; 2138 : 	newEnt->data.ptr = data;

  0049c	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  004a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  004a9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2139 :     }

  004ad	eb 11		 jmp	 SHORT $LN35@intTrieAdd
$LN34@intTrieAdd:

; 2140 :     else
; 2141 :     {
; 2142 : 	newEnt->data.intVal = intVal;

  004af	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  004b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR intVal$[rsp]
  004bc	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN35@intTrieAdd:

; 2143 :     }
; 2144 :     /* Install it
; 2145 :      */
; 2146 :     nextNode->buckets	= newEnt;

  004c0	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newEnt$[rsp]
  004ca	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2147 :     nextNode->key	= key;

  004ce	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  004d8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2148 :     nextNode->bitNum	= depth;

  004dc	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004e1	8b 4c 24 38	 mov	 ecx, DWORD PTR depth$[rsp]
  004e5	89 08		 mov	 DWORD PTR [rax], ecx

; 2149 : 
; 2150 :     /* Work out the right and left pointers for this new node, which involve
; 2151 :      * terminating with the current found node either right or left according
; 2152 :      * to whether the current index bit is 1 or 0
; 2153 :      */
; 2154 :     if (key & bitMask[depth])

  004e7	8b 44 24 38	 mov	 eax, DWORD PTR depth$[rsp]
  004eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  004f2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  004f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  004fb	48 23 c8	 and	 rcx, rax
  004fe	48 8b c1	 mov	 rax, rcx
  00501	48 85 c0	 test	 rax, rax
  00504	74 1e		 je	 SHORT $LN36@intTrieAdd

; 2155 :     {
; 2156 : 	nextNode->leftN	    = entNode;	    /* Terminates at previous position	*/

  00506	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  0050b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  00510	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2157 : 	nextNode->rightN    = nextNode;	    /* Terminates with itself		*/

  00514	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00519	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0051e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2158 :     }

  00522	eb 1c		 jmp	 SHORT $LN37@intTrieAdd
$LN36@intTrieAdd:

; 2159 :     else
; 2160 :     {
; 2161 : 	nextNode->rightN   = entNode;	    /* Terminates at previous position	*/

  00524	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00529	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  0052e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2162 : 	nextNode->leftN    = nextNode;	    /* Terminates with itself		*/		

  00532	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00537	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0053c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN37@intTrieAdd:

; 2163 :     }
; 2164 : 
; 2165 :     /* Finally, we need to change the pointers at the node we located
; 2166 :      * for inserting. If the key bit at its index is set then the right
; 2167 :      * pointer for that node becomes the newly created node, otherwise the left 
; 2168 :      * pointer does.
; 2169 :      */
; 2170 :     if (key & bitMask[thisNode->bitNum] )

  00540	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00545	8b 00		 mov	 eax, DWORD PTR [rax]
  00547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  0054e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00552	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  00557	48 23 c8	 and	 rcx, rax
  0055a	48 8b c1	 mov	 rax, rcx
  0055d	48 85 c0	 test	 rax, rax
  00560	74 10		 je	 SHORT $LN38@intTrieAdd

; 2171 :     {
; 2172 : 	thisNode->rightN    = nextNode;

  00562	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00567	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0056c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2173 :     }

  00570	eb 0e		 jmp	 SHORT $LN39@intTrieAdd
$LN38@intTrieAdd:

; 2174 :     else
; 2175 :     {
; 2176 : 	thisNode->leftN	    = nextNode;

  00572	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00577	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0057c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN39@intTrieAdd:

; 2177 :     }
; 2178 : 
; 2179 :     /* Et voila
; 2180 :      */
; 2181 :     trie->count++;

  00580	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00585	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00588	ff c0		 inc	 eax
  0058a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trie$[rsp]
  0058f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2182 :     return  ANTLR3_TRUE;

  00592	b0 01		 mov	 al, 1
$LN1@intTrieAdd:

; 2183 : 
; 2184 : }

  00594	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00598	5f		 pop	 rdi
  00599	c3		 ret	 0
intTrieAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieDel
_TEXT	SEGMENT
p$ = 0
trie$ = 32
key$ = 40
intTrieDel PROC						; COMDAT

; 1892 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1893 :     pANTLR3_INT_TRIE_NODE   p;
; 1894 : 
; 1895 :     p=trie->root;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 89 04 24	 mov	 QWORD PTR p$[rsp], rax

; 1896 :     key = key;

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
  00034	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 1897 : 
; 1898 :     return ANTLR3_FALSE;

  00039	32 c0		 xor	 al, al

; 1899 : }

  0003b	48 83 c4 10	 add	 rsp, 16
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
intTrieDel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieGet
_TEXT	SEGMENT
thisNode$ = 0
nextNode$ = 8
trie$ = 32
key$ = 40
intTrieGet PROC						; COMDAT

; 1822 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1823 : 	pANTLR3_INT_TRIE_NODE    thisNode; 
; 1824 : 	pANTLR3_INT_TRIE_NODE    nextNode; 
; 1825 : 
; 1826 : 	if (trie->count == 0)

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00028	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0002c	75 07		 jne	 SHORT $LN4@intTrieGet

; 1827 : 	{
; 1828 : 		return NULL;	    /* Nothing in this trie yet	*/

  0002e	33 c0		 xor	 eax, eax
  00030	e9 92 00 00 00	 jmp	 $LN1@intTrieGet
$LN4@intTrieGet:

; 1829 : 	}
; 1830 : 	/* Starting at the root node in the trie, compare the bit index
; 1831 : 	 * of the current node with its next child node (starts left from root).
; 1832 : 	 * When the bit index of the child node is greater than the bit index of the current node
; 1833 : 	 * then by definition (as the bit index decreases as we descent the trie)
; 1834 : 	 * we have reached a 'backward' pointer. A backward pointer means we
; 1835 : 	 * have reached the only node that can be reached by the bits given us so far
; 1836 : 	 * and it must either be the key we are looking for, or if not then it
; 1837 : 	 * means the entry was not in the trie, and we return NULL. A backward pointer
; 1838 : 	 * points back in to the tree structure rather than down (deeper) within the
; 1839 : 	 * tree branches.
; 1840 : 	 */
; 1841 : 	thisNode	= trie->root;		/* Start at the root node		*/

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 04 24	 mov	 QWORD PTR thisNode$[rsp], rax

; 1842 : 	nextNode	= thisNode->leftN;	/* Examine the left node from the root	*/

  00041	48 8b 04 24	 mov	 rax, QWORD PTR thisNode$[rsp]
  00045	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00049	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax
$LN2@intTrieGet:

; 1843 : 
; 1844 : 	/* While we are descending the tree nodes...
; 1845 : 	 */
; 1846 : 	while (thisNode->bitNum > nextNode->bitNum)

  0004e	48 8b 04 24	 mov	 rax, QWORD PTR thisNode$[rsp]
  00052	48 8b 4c 24 08	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00057	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00059	39 08		 cmp	 DWORD PTR [rax], ecx
  0005b	76 4b		 jbe	 SHORT $LN3@intTrieGet

; 1847 : 	{
; 1848 : 		/* Next node now becomes the new 'current' node
; 1849 : 		 */
; 1850 : 		thisNode    = nextNode;

  0005d	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  00062	48 89 04 24	 mov	 QWORD PTR thisNode$[rsp], rax

; 1851 : 
; 1852 : 		/* We now test the bit indicated by the bitmap in the next node
; 1853 : 		 * in the key we are searching for. The new next node is the
; 1854 : 		 * right node if that bit is set and the left node it is not.
; 1855 : 		 */
; 1856 : 		if (key & bitMask[nextNode->bitNum])

  00066	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  0006b	8b 00		 mov	 eax, DWORD PTR [rax]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  00074	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  0007d	48 23 c8	 and	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	48 85 c0	 test	 rax, rax
  00086	74 10		 je	 SHORT $LN5@intTrieGet

; 1857 : 		{
; 1858 : 			nextNode = nextNode->rightN;	/* 1 is right	*/

  00088	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  0008d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00091	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax

; 1859 : 		}

  00096	eb 0e		 jmp	 SHORT $LN6@intTrieGet
$LN5@intTrieGet:

; 1860 : 		else
; 1861 : 		{
; 1862 : 			nextNode = nextNode->leftN;		/* 0 is left	*/

  00098	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  0009d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a1	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax
$LN6@intTrieGet:

; 1863 : 		}
; 1864 : 	}

  000a6	eb a6		 jmp	 SHORT $LN2@intTrieGet
$LN3@intTrieGet:

; 1865 : 
; 1866 : 	/* Here we have reached a node where the bitMap index is lower than
; 1867 : 	 * its parent. This means it is pointing backward in the tree and
; 1868 : 	 * must therefore be a terminal node, being the only point than can
; 1869 : 	 * be reached with the bits seen so far. It is either the actual key
; 1870 : 	 * we wanted, or if that key is not in the trie it is another key
; 1871 : 	 * that is currently the only one that can be reached by those bits.
; 1872 : 	 * That situation would obviously change if the key was to be added
; 1873 : 	 * to the trie.
; 1874 : 	 *
; 1875 : 	 * Hence it only remains to test whether this is actually the key or not.
; 1876 : 	 */
; 1877 : 	if (nextNode->key == key)

  000a8	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  000b2	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000b6	75 0d		 jne	 SHORT $LN7@intTrieGet

; 1878 : 	{
; 1879 : 		/* This was the key, so return the entry pointer
; 1880 : 		 */
; 1881 : 		return	nextNode->buckets;

  000b8	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  000bd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c1	eb 04		 jmp	 SHORT $LN1@intTrieGet

; 1882 : 	}

  000c3	eb 02		 jmp	 SHORT $LN8@intTrieGet
$LN7@intTrieGet:

; 1883 : 	else
; 1884 : 	{
; 1885 : 		return	NULL;	/* That key is not in the trie (note that we set the pointer to -1 if no payload) */

  000c5	33 c0		 xor	 eax, eax
$LN8@intTrieGet:
$LN1@intTrieGet:

; 1886 : 	}
; 1887 : }

  000c7	48 83 c4 10	 add	 rsp, 16
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
intTrieGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT returnVector
_TEXT	SEGMENT
factory$ = 48
vector$ = 56
returnVector PROC					; COMDAT

; 1479 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1480 : 	// First we need to clear out anything that is still in the vector
; 1481 : 	//
; 1482 : 	vector->clear(vector);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vector$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR vector$[rsp]
  0002d	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 1483 : 
; 1484 : 	// We have a free stack available so we can add the vector we were
; 1485 : 	// given into the free chain. The vector has to have come from this
; 1486 : 	// factory, so we already know how to release its memory when it
; 1487 : 	// dies by virtue of the factory being closed.
; 1488 : 	//
; 1489 : 	factory->freeStack->push(factory->freeStack, vector, NULL);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00038	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  0003f	45 33 c0	 xor	 r8d, r8d
  00042	48 8b 54 24 38	 mov	 rdx, QWORD PTR vector$[rsp]
  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0004c	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00053	ff 50 28	 call	 QWORD PTR [rax+40]

; 1490 : 
; 1491 : 	// TODO: remove this line once happy printf("Returned vector %08X to the pool, stack size is %d\n", vector, factory->freeStack->size(factory->freeStack));
; 1492 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
returnVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT newVector
_TEXT	SEGMENT
vector$ = 32
factory$ = 64
newVector PROC						; COMDAT

; 1639 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1640 :     pANTLR3_VECTOR vector;
; 1641 : 
; 1642 : 	// If we have anything on the re claim stack, reuse it
; 1643 : 	//
; 1644 : 	vector = factory->freeStack->peek(factory->freeStack);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00023	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0002f	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00036	ff 50 38	 call	 QWORD PTR [rax+56]
  00039	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1645 : 
; 1646 : 	if  (vector != NULL)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR vector$[rsp], 0
  00044	74 25		 je	 SHORT $LN2@newVector

; 1647 : 	{
; 1648 : 		// Cool we got something we could reuse
; 1649 : 		//
; 1650 : 		factory->freeStack->pop(factory->freeStack);

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0004b	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00057	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  0005e	ff 50 18	 call	 QWORD PTR [rax+24]

; 1651 : 
; 1652 : 		// TODO: remove this line once happy printf("Reused vector %08X from stack, size is now %d\n", vector, factory->freeStack->size(factory->freeStack));
; 1653 : 		return vector;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  00066	e9 87 00 00 00	 jmp	 $LN1@newVector
$LN2@newVector:

; 1654 : 
; 1655 : 	}
; 1656 : 
; 1657 : 	// See if we need a new vector pool before allocating a new
; 1658 :     // one
; 1659 :     //
; 1660 :     if (factory->nextVector >= ANTLR3_FACTORY_VPOOL_SIZE)

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00070	81 78 0c 00 01
	00 00		 cmp	 DWORD PTR [rax+12], 256	; 00000100H
  00077	72 0a		 jb	 SHORT $LN3@newVector

; 1661 :     {
; 1662 :         // We ran out of vectors in the current pool, so we need a new pool
; 1663 :         //
; 1664 :         newPool(factory);

  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0007e	e8 00 00 00 00	 call	 newPool
$LN3@newVector:

; 1665 :     }
; 1666 : 
; 1667 :     // Assuming everything went well (we are trying for performance here so doing minimal
; 1668 :     // error checking. Then we can work out what the pointer is to the next vector.
; 1669 :     //
; 1670 :     vector = factory->pools[factory->thisPool] + factory->nextVector;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00088	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00091	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00094	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  00099	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0009c	48 69 d2 60 01
	00 00		 imul	 rdx, rdx, 352		; 00000160H
  000a3	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  000a7	48 8b c2	 mov	 rax, rdx
  000aa	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1671 :     factory->nextVector++;

  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000b4	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000b7	ff c0		 inc	 eax
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000be	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1672 : 
; 1673 :     // We have our token pointer now, so we can initialize it to the predefined model.
; 1674 :     //
; 1675 :     antlr3SetVectorApi(vector, ANTLR3_VECTOR_INTERNAL_SIZE);

  000c1	ba 10 00 00 00	 mov	 edx, 16
  000c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000cb	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1676 :     vector->factoryMade = ANTLR3_TRUE;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  000d5	c6 80 10 01 00
	00 01		 mov	 BYTE PTR [rax+272], 1

; 1677 : 
; 1678 :     // We know that the pool vectors are created at the default size, which means they
; 1679 :     // will start off using their internal entry pointers. We must intialize our pool vector
; 1680 :     // to point to its own internal entry table and not the pre-made one.
; 1681 :     //
; 1682 :     vector->elements = vector->internal;

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  000e1	48 83 c0 10	 add	 rax, 16
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000ea	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 : 
; 1684 : 		// TODO: remove this line once happy printf("Used a new vector at %08X from the pools as nothing on the reusue stack\n", vector);
; 1685 : 
; 1686 :     // And we are done
; 1687 :     //
; 1688 :     return vector;

  000ed	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
$LN1@newVector:

; 1689 : }

  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
newVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT closeVectorFactory
_TEXT	SEGMENT
pool$ = 32
poolCount$ = 40
limit$ = 44
vector$ = 48
check$ = 56
tv80 = 64
tv131 = 68
factory$ = 96
closeVectorFactory PROC					; COMDAT

; 1526 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1527 :     pANTLR3_VECTOR      pool;
; 1528 :     ANTLR3_INT32        poolCount;
; 1529 :     ANTLR3_UINT32       limit;
; 1530 :     ANTLR3_UINT32       vector;
; 1531 :     pANTLR3_VECTOR      check;
; 1532 : 
; 1533 : 	// First see if we have a free chain stack to release?
; 1534 : 	//
; 1535 : 	if	(factory->freeStack != NULL)

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00023	48 83 b8 70 01
	00 00 00	 cmp	 QWORD PTR [rax+368], 0
  0002b	74 1b		 je	 SHORT $LN14@closeVecto

; 1536 : 	{
; 1537 : 		factory->freeStack->free(factory->freeStack);

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00032	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0003e	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00045	ff 50 10	 call	 QWORD PTR [rax+16]
$LN14@closeVecto:

; 1538 : 	}
; 1539 : 
; 1540 :     /* We iterate the vector pools one at a time
; 1541 :      */
; 1542 :     for (poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  00048	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  00050	eb 0a		 jmp	 SHORT $LN4@closeVecto
$LN2@closeVecto:
  00052	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  00056	ff c0		 inc	 eax
  00058	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN4@closeVecto:
  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00061	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00064	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00068	0f 8f 99 00 00
	00		 jg	 $LN3@closeVecto

; 1543 :     {
; 1544 :         /* Pointer to current pool
; 1545 :          */
; 1546 :         pool = factory->pools[poolCount];

  0006e	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00078	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 1547 : 
; 1548 :         /* Work out how many tokens we need to check in this pool.
; 1549 :          */
; 1550 :         limit = (poolCount == factory->thisPool ? factory->nextVector : ANTLR3_FACTORY_VPOOL_SIZE);

  00084	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00089	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008c	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00090	75 0e		 jne	 SHORT $LN19@closeVecto
  00092	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00097	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0009a	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  0009e	eb 08		 jmp	 SHORT $LN20@closeVecto
$LN19@closeVecto:
  000a0	c7 44 24 40 00
	01 00 00	 mov	 DWORD PTR tv80[rsp], 256 ; 00000100H
$LN20@closeVecto:
  000a8	8b 44 24 40	 mov	 eax, DWORD PTR tv80[rsp]
  000ac	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 1551 : 
; 1552 :         /* Marginal condition, we might be at the start of a brand new pool
; 1553 :          * where the nextToken is 0 and nothing has been allocated.
; 1554 :          */
; 1555 :         if (limit > 0)

  000b0	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  000b5	76 4b		 jbe	 SHORT $LN15@closeVecto

; 1556 :         {
; 1557 :             /* We have some vectors allocated from this pool
; 1558 :              */
; 1559 :             for (vector = 0; vector < limit; vector++)

  000b7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR vector$[rsp], 0
  000bf	eb 0a		 jmp	 SHORT $LN7@closeVecto
$LN5@closeVecto:
  000c1	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  000c5	ff c0		 inc	 eax
  000c7	89 44 24 30	 mov	 DWORD PTR vector$[rsp], eax
$LN7@closeVecto:
  000cb	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  000cf	39 44 24 30	 cmp	 DWORD PTR vector$[rsp], eax
  000d3	73 2d		 jae	 SHORT $LN6@closeVecto

; 1560 :             {
; 1561 :                 /* Next one in the chain
; 1562 :                  */
; 1563 :                 check = pool + vector;

  000d5	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  000d9	48 69 c0 60 01
	00 00		 imul	 rax, rax, 352		; 00000160H
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  000e5	48 03 c8	 add	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 1564 : 
; 1565 :                 // Call the free function on each of the vectors in the pool,
; 1566 :                 // which in turn will cause any elements it holds that also have a free
; 1567 :                 // pointer to be freed. However, because any vector may be in any other
; 1568 :                 // vector, we don't free the element allocations yet. We do that in a
; 1569 :                 // a specific pass, coming up next. The vector free function knows that
; 1570 :                 // this is a factory allocated pool vector and so it won't free things it
; 1571 :                 // should not.
; 1572 :                 //
; 1573 :                 check->free(check);

  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR check$[rsp]
  000f5	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000fa	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 1574 :             }

  00100	eb bf		 jmp	 SHORT $LN5@closeVecto
$LN6@closeVecto:
$LN15@closeVecto:

; 1575 :         }
; 1576 :     }

  00102	e9 4b ff ff ff	 jmp	 $LN2@closeVecto
$LN3@closeVecto:

; 1577 : 
; 1578 :     /* We iterate the vector pools one at a time once again, but this time
; 1579 :      * we are going to free up any allocated element pointers. Note that we are doing this
; 1580 :      * so that we do not try to release vectors twice. When building ASTs we just copy
; 1581 :      * the vectors all over the place and they may be embedded in this vector pool
; 1582 :      * numerous times.
; 1583 :      */
; 1584 :     for (poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  00107	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  0010f	eb 0a		 jmp	 SHORT $LN10@closeVecto
$LN8@closeVecto:
  00111	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  00115	ff c0		 inc	 eax
  00117	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN10@closeVecto:
  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00120	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00123	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00127	0f 8f ee 00 00
	00		 jg	 $LN9@closeVecto

; 1585 :     {
; 1586 :         /* Pointer to current pool
; 1587 :          */
; 1588 :         pool = factory->pools[poolCount];

  0012d	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00132	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00137	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0013a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0013e	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 1589 : 
; 1590 :         /* Work out how many tokens we need to check in this pool.
; 1591 :          */
; 1592 :         limit = (poolCount == factory->thisPool ? factory->nextVector : ANTLR3_FACTORY_VPOOL_SIZE);

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00148	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0014b	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  0014f	75 0e		 jne	 SHORT $LN21@closeVecto
  00151	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00156	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00159	89 44 24 44	 mov	 DWORD PTR tv131[rsp], eax
  0015d	eb 08		 jmp	 SHORT $LN22@closeVecto
$LN21@closeVecto:
  0015f	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR tv131[rsp], 256 ; 00000100H
$LN22@closeVecto:
  00167	8b 44 24 44	 mov	 eax, DWORD PTR tv131[rsp]
  0016b	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 1593 : 
; 1594 :         /* Marginal condition, we might be at the start of a brand new pool
; 1595 :          * where the nextToken is 0 and nothing has been allocated.
; 1596 :          */
; 1597 :         if (limit > 0)

  0016f	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  00174	76 74		 jbe	 SHORT $LN16@closeVecto

; 1598 :         {
; 1599 :             /* We have some vectors allocated from this pool
; 1600 :              */
; 1601 :             for (vector = 0; vector < limit; vector++)

  00176	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR vector$[rsp], 0
  0017e	eb 0a		 jmp	 SHORT $LN13@closeVecto
$LN11@closeVecto:
  00180	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  00184	ff c0		 inc	 eax
  00186	89 44 24 30	 mov	 DWORD PTR vector$[rsp], eax
$LN13@closeVecto:
  0018a	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  0018e	39 44 24 30	 cmp	 DWORD PTR vector$[rsp], eax
  00192	73 56		 jae	 SHORT $LN12@closeVecto

; 1602 :             {
; 1603 :                 /* Next one in the chain
; 1604 :                  */
; 1605 :                 check = pool + vector;

  00194	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  00198	48 69 c0 60 01
	00 00		 imul	 rax, rax, 352		; 00000160H
  0019f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  001a4	48 03 c8	 add	 rcx, rax
  001a7	48 8b c1	 mov	 rax, rcx
  001aa	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 1606 : 
; 1607 :                 // Anything in here should be factory made, but we do this just
; 1608 :                 // to triple check. We just free up the elements if they were
; 1609 :                 // allocated beyond the internal size.
; 1610 :                 //
; 1611 :                 if (check->factoryMade == ANTLR3_TRUE && check->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  001af	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001b4	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  001bb	83 f8 01	 cmp	 eax, 1
  001be	75 28		 jne	 SHORT $LN17@closeVecto
  001c0	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001c5	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  001cc	76 1a		 jbe	 SHORT $LN17@closeVecto

; 1612 :                 {
; 1613 :                     ANTLR3_FREE(check->elements);

  001ce	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001d3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1614 :                     check->elements = NULL;

  001dc	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001e1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN17@closeVecto:

; 1615 :                 }
; 1616 :             }

  001e8	eb 96		 jmp	 SHORT $LN11@closeVecto
$LN12@closeVecto:
$LN16@closeVecto:

; 1617 :         }
; 1618 : 
; 1619 :         // We can now free this pool allocation as we have called free on every element in every vector
; 1620 :         // and freed any memory for pointers the grew beyond the internal size limit.
; 1621 :         //
; 1622 :         ANTLR3_FREE(factory->pools[poolCount]);

  001ea	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  001ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  001f4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001f7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1623 :         factory->pools[poolCount] = NULL;

  00201	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00206	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 1624 :     }

  00216	e9 f6 fe ff ff	 jmp	 $LN8@closeVecto
$LN9@closeVecto:

; 1625 : 
; 1626 :     /* All the pools are deallocated we can free the pointers to the pools
; 1627 :      * now.
; 1628 :      */
; 1629 :     ANTLR3_FREE(factory->pools);

  0021b	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00220	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1630 : 
; 1631 :     /* Finally, we can free the space for the factory itself
; 1632 :      */
; 1633 :     ANTLR3_FREE(factory);

  00229	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1634 : 
; 1635 : }

  00234	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00238	5f		 pop	 rdi
  00239	c3		 ret	 0
closeVectorFactory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT newPool
_TEXT	SEGMENT
factory$ = 48
newPool	PROC						; COMDAT

; 1496 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1497 :     /* Increment factory count
; 1498 :      */
; 1499 :     factory->thisPool++;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c0		 inc	 eax
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1500 : 
; 1501 :     /* Ensure we have enough pointers allocated
; 1502 :      */
; 1503 :     factory->pools = (pANTLR3_VECTOR *)

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00035	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00038	ff c0		 inc	 eax
  0003a	48 98		 cdqe
  0003c	48 c1 e0 03	 shl	 rax, 3
  00040	8b c0		 mov	 eax, eax
  00042	8b d0		 mov	 edx, eax
  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00049	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00057	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1504 : 		     ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
; 1505 : 					(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_VECTOR *))	/* Memory for new pool pointers */
; 1506 : 					);
; 1507 : 
; 1508 :     /* Allocate a new pool for the factory
; 1509 :      */
; 1510 :     factory->pools[factory->thisPool]	=

  0005a	b9 00 60 01 00	 mov	 ecx, 90112		; 00016000H
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0006a	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  0006e	48 8b 54 24 30	 mov	 rdx, QWORD PTR factory$[rsp]
  00073	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00076	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 1511 : 			    (pANTLR3_VECTOR)
; 1512 : 				ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR) * ANTLR3_FACTORY_VPOOL_SIZE));
; 1513 : 
; 1514 : 
; 1515 :     /* Reset the counters
; 1516 :      */
; 1517 :     factory->nextVector	= 0;

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0007f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 1518 : 
; 1519 :     /* Done
; 1520 :      */
; 1521 :     return;
; 1522 : }

  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
newPool	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSwap
_TEXT	SEGMENT
tempEntry$ = 0
freeptr$ = 8
vector$ = 32
entry1$ = 40
entry2$ = 48
antlr3VectorSwap PROC					; COMDAT

; 1394 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 10	 sub	 rsp, 16
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 04 00 00 00	 mov	 ecx, 4
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1395 : 
; 1396 :     void               * tempEntry;
; 1397 :     void (ANTLR3_CDECL *freeptr)(void *);
; 1398 : 
; 1399 : 	// If the vector is currently not big enough, then we do nothing
; 1400 : 	//
; 1401 : 	if (entry1 >= vector->elementsSize || entry2 >= vector->elementsSize)

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  0002c	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00032	39 44 24 28	 cmp	 DWORD PTR entry1$[rsp], eax
  00036	73 11		 jae	 SHORT $LN3@antlr3Vect
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  0003d	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00043	39 44 24 30	 cmp	 DWORD PTR entry2$[rsp], eax
  00047	72 07		 jb	 SHORT $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1402 : 	{
; 1403 :         return ANTLR3_FALSE;

  00049	32 c0		 xor	 al, al
  0004b	e9 b8 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1404 : 	}
; 1405 : 
; 1406 : 	// Valid request, swap them
; 1407 : 	//
; 1408 :     tempEntry   = vector->elements[entry1].element;

  00050	8b 44 24 28	 mov	 eax, DWORD PTR entry1$[rsp]
  00054	48 6b c0 10	 imul	 rax, rax, 16
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  0005d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00060	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00064	48 89 04 24	 mov	 QWORD PTR tempEntry$[rsp], rax

; 1409 :     freeptr     = vector->elements[entry1].freeptr;

  00068	8b 44 24 28	 mov	 eax, DWORD PTR entry1$[rsp]
  0006c	48 6b c0 10	 imul	 rax, rax, 16
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  00075	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00078	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0007d	48 89 44 24 08	 mov	 QWORD PTR freeptr$[rsp], rax

; 1410 : 
; 1411 : 	// Install the new pointers
; 1412 : 	//
; 1413 :     vector->elements[entry1].freeptr	= vector->elements[entry2].freeptr;

  00082	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  00086	48 6b c0 10	 imul	 rax, rax, 16
  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  0008f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00092	8b 54 24 28	 mov	 edx, DWORD PTR entry1$[rsp]
  00096	48 6b d2 10	 imul	 rdx, rdx, 16
  0009a	4c 8b 44 24 20	 mov	 r8, QWORD PTR vector$[rsp]
  0009f	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000a2	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000a7	49 89 44 10 08	 mov	 QWORD PTR [r8+rdx+8], rax

; 1414 : 	vector->elements[entry1].element	= vector->elements[entry2].element;

  000ac	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  000b0	48 6b c0 10	 imul	 rax, rax, 16
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000b9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000bc	8b 54 24 28	 mov	 edx, DWORD PTR entry1$[rsp]
  000c0	48 6b d2 10	 imul	 rdx, rdx, 16
  000c4	4c 8b 44 24 20	 mov	 r8, QWORD PTR vector$[rsp]
  000c9	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000cc	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d0	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax

; 1415 : 
; 1416 : 	vector->elements[entry2].freeptr	= freeptr;

  000d4	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  000d8	48 6b c0 10	 imul	 rax, rax, 16
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000e1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e4	48 8b 54 24 08	 mov	 rdx, QWORD PTR freeptr$[rsp]
  000e9	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1417 : 	vector->elements[entry2].element	= tempEntry;

  000ee	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  000f2	48 6b c0 10	 imul	 rax, rax, 16
  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000fb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fe	48 8b 14 24	 mov	 rdx, QWORD PTR tempEntry$[rsp]
  00102	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1418 : 
; 1419 : 	return  ANTLR3_TRUE;

  00106	b0 01		 mov	 al, 1
$LN1@antlr3Vect:

; 1420 : 
; 1421 : }

  00108	48 83 c4 10	 add	 rsp, 16
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
antlr3VectorSwap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSize
_TEXT	SEGMENT
vector$ = 16
antlr3VectorSize PROC					; COMDAT

; 1424 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1425 :     return  vector->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR vector$[rsp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1426 : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr3VectorSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSet
_TEXT	SEGMENT
vector$ = 48
entry$ = 56
element$ = 64
freeptr$ = 72
freeExisting$ = 80
antlr3VectorSet PROC					; COMDAT

; 1357 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1358 : 
; 1359 : 	// If the vector is currently not big enough, then we expand it
; 1360 : 	//
; 1361 : 	if (entry >= vector->elementsSize)

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00031	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00037	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  0003b	72 0e		 jb	 SHORT $LN2@antlr3Vect

; 1362 : 	{
; 1363 : 		antlr3VectorResize(vector, entry);	// We will get at least this many 

  0003d	8b 54 24 38	 mov	 edx, DWORD PTR entry$[rsp]
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00046	e8 00 00 00 00	 call	 antlr3VectorResize
$LN2@antlr3Vect:

; 1364 : 	}
; 1365 : 
; 1366 : 	// Valid request, replace the current one, freeing any prior entry if told to
; 1367 : 	//
; 1368 : 	if	(		entry < vector->count						// If actually replacing an element
; 1369 : 			&&	freeExisting								// And told to free any existing element
; 1370 : 			&&	vector->elements[entry].freeptr != NULL		// And the existing element has a free pointer

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00050	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00053	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  00057	73 4a		 jae	 SHORT $LN3@antlr3Vect
  00059	0f b6 44 24 50	 movzx	 eax, BYTE PTR freeExisting$[rsp]
  0005e	85 c0		 test	 eax, eax
  00060	74 41		 je	 SHORT $LN3@antlr3Vect
  00062	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  00066	48 6b c0 10	 imul	 rax, rax, 16
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0006f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00072	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00078	74 29		 je	 SHORT $LN3@antlr3Vect

; 1371 : 		)
; 1372 : 	{
; 1373 : 		vector->elements[entry].freeptr(vector->elements[entry].element);

  0007a	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  0007e	48 6b c0 10	 imul	 rax, rax, 16
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00087	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008a	8b 54 24 38	 mov	 edx, DWORD PTR entry$[rsp]
  0008e	48 6b d2 10	 imul	 rdx, rdx, 16
  00092	4c 8b 44 24 30	 mov	 r8, QWORD PTR vector$[rsp]
  00097	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0009a	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0009e	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN3@antlr3Vect:

; 1374 : 	}
; 1375 : 
; 1376 : 	// Install the new pointers
; 1377 : 	//
; 1378 : 	vector->elements[entry].freeptr	= freeptr;

  000a3	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  000a7	48 6b c0 10	 imul	 rax, rax, 16
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  000b0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b3	48 8b 54 24 48	 mov	 rdx, QWORD PTR freeptr$[rsp]
  000b8	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1379 : 	vector->elements[entry].element	= element;

  000bd	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  000c1	48 6b c0 10	 imul	 rax, rax, 16
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  000ca	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cd	48 8b 54 24 40	 mov	 rdx, QWORD PTR element$[rsp]
  000d2	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1380 : 
; 1381 : 	if (entry >= vector->count)

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  000db	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000de	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  000e2	72 0e		 jb	 SHORT $LN4@antlr3Vect

; 1382 : 	{
; 1383 : 		vector->count = entry + 1;

  000e4	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  000e8	ff c0		 inc	 eax
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  000ef	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN4@antlr3Vect:

; 1384 : 	}
; 1385 : 	return  (ANTLR3_UINT32)(entry);	    // Indicates the replacement was successful

  000f2	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]

; 1386 : 
; 1387 : }

  000f6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
antlr3VectorSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorAdd
_TEXT	SEGMENT
vector$ = 48
element$ = 56
freeptr$ = 64
antlr3VectorAdd PROC					; COMDAT

; 1333 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1334 : 	// Do we need to resize the vector table?
; 1335 : 	//
; 1336 : 	if	(vector->count == vector->elementsSize)

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00032	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [rcx+276]
  00038	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0003b	75 0c		 jne	 SHORT $LN2@antlr3Vect

; 1337 : 	{
; 1338 : 		antlr3VectorResize(vector, 0);	    // Give no hint, we let it add 1024 or double it

  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00044	e8 00 00 00 00	 call	 antlr3VectorResize
$LN2@antlr3Vect:

; 1339 : 	}
; 1340 : 
; 1341 : 	// Insert the new entry
; 1342 : 	//
; 1343 : 	vector->elements[vector->count].element	= element;

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0004e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00051	48 6b c0 10	 imul	 rax, rax, 16
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0005a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005d	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  00062	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1344 : 	vector->elements[vector->count].freeptr	= freeptr;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0006b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006e	48 6b c0 10	 imul	 rax, rax, 16
  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	48 8b 54 24 40	 mov	 rdx, QWORD PTR freeptr$[rsp]
  0007f	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1345 : 
; 1346 : 	vector->count++;	    // One more element counted

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00089	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008c	ff c0		 inc	 eax
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00093	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1347 : 
; 1348 : 	return  (ANTLR3_UINT32)(vector->count);

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0009b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1349 : 
; 1350 : }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
antlr3VectorAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorClear
_TEXT	SEGMENT
entry$ = 32
vector$ = 64
antlr3VectorClear PROC					; COMDAT

; 1137 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1138 : 	ANTLR3_UINT32   entry;
; 1139 : 
; 1140 : 	// We must traverse every entry in the vector and if it has
; 1141 : 	// a pointer to a free function then we call it with the
; 1142 : 	// the entry pointer
; 1143 : 	//
; 1144 : 	for	(entry = 0; entry < vector->count; entry++)

  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR entry$[rsp], 0
  00026	eb 0a		 jmp	 SHORT $LN4@antlr3Vect
$LN2@antlr3Vect:
  00028	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0002c	ff c0		 inc	 eax
  0002e	89 44 24 20	 mov	 DWORD PTR entry$[rsp], eax
$LN4@antlr3Vect:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 20	 cmp	 DWORD PTR entry$[rsp], eax
  0003e	73 77		 jae	 SHORT $LN3@antlr3Vect

; 1145 : 	{
; 1146 : 		if  (vector->elements[entry].freeptr != NULL)

  00040	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00044	48 6b c0 10	 imul	 rax, rax, 16
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00056	74 29		 je	 SHORT $LN5@antlr3Vect

; 1147 : 		{
; 1148 : 			vector->elements[entry].freeptr(vector->elements[entry].element);

  00058	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0005c	48 6b c0 10	 imul	 rax, rax, 16
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	8b 54 24 20	 mov	 edx, DWORD PTR entry$[rsp]
  0006c	48 6b d2 10	 imul	 rdx, rdx, 16
  00070	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  00075	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00078	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0007c	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN5@antlr3Vect:

; 1149 : 		}
; 1150 : 		vector->elements[entry].freeptr    = NULL;

  00081	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00085	48 6b c0 10	 imul	 rax, rax, 16
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0008e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00091	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1151 : 		vector->elements[entry].element    = NULL;

  0009a	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0009e	48 6b c0 10	 imul	 rax, rax, 16
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000a7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000aa	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1152 : 	}

  000b2	e9 71 ff ff ff	 jmp	 $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1153 : 
; 1154 : 	// Having called any free pointers, we just reset the entry count
; 1155 : 	// back to zero.
; 1156 : 	//
; 1157 : 	vector->count	= 0;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000bc	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1158 : }

  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
antlr3VectorClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antrl3VectorRemove
_TEXT	SEGMENT
element$ = 32
tv132 = 40
vector$ = 64
entry$ = 72
antrl3VectorRemove PROC					; COMDAT

; 1251 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1252 : 	void * element;
; 1253 : 
; 1254 : 	// Check this is a valid request first 
; 1255 : 	//
; 1256 : 	if	(entry >= vector->count)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00027	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002a	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0002e	72 07		 jb	 SHORT $LN2@antrl3Vect

; 1257 : 	{
; 1258 : 		return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	e9 c7 00 00 00	 jmp	 $LN1@antrl3Vect
$LN2@antrl3Vect:

; 1259 : 	}
; 1260 : 
; 1261 : 	// Valid request, return the sorted pointer
; 1262 : 	//
; 1263 : 
; 1264 : 	element				    = vector->elements[entry].element;

  00037	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  0003b	48 6b c0 10	 imul	 rax, rax, 16
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00044	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00047	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0004b	48 89 44 24 20	 mov	 QWORD PTR element$[rsp], rax

; 1265 : 
; 1266 : 	if	(entry == vector->count - 1)

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00055	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00058	ff c8		 dec	 eax
  0005a	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0005e	75 33		 jne	 SHORT $LN3@antrl3Vect

; 1267 : 	{
; 1268 : 		// Ensure the pointer is never reused by accident, but otherwise just 
; 1269 : 		// decrement the pointer.
; 1270 : 		///
; 1271 : 		vector->elements[entry].element    = NULL;

  00060	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00064	48 6b c0 10	 imul	 rax, rax, 16
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0006d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00070	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1272 : 		vector->elements[entry].freeptr    = NULL;

  00078	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  0007c	48 6b c0 10	 imul	 rax, rax, 16
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00088	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1273 : 	}

  00091	eb 54		 jmp	 SHORT $LN4@antrl3Vect
$LN3@antrl3Vect:

; 1274 : 	else
; 1275 : 	{
; 1276 : 		// Need to shuffle trailing pointers back over the deleted entry
; 1277 : 		//
; 1278 : 		ANTLR3_MEMMOVE(vector->elements + entry, vector->elements + entry + 1, sizeof(ANTLR3_VECTOR_ELEMENT) * (vector->count - entry - 1));

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00098	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  0009c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0009f	2b c1		 sub	 eax, ecx
  000a1	ff c8		 dec	 eax
  000a3	8b c0		 mov	 eax, eax
  000a5	48 6b c0 10	 imul	 rax, rax, 16
  000a9	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  000ad	48 6b c9 10	 imul	 rcx, rcx, 16
  000b1	48 8b 54 24 40	 mov	 rdx, QWORD PTR vector$[rsp]
  000b6	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000b9	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  000be	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  000c2	48 6b d2 10	 imul	 rdx, rdx, 16
  000c6	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  000cb	49 03 10	 add	 rdx, QWORD PTR [r8]
  000ce	48 89 54 24 28	 mov	 QWORD PTR tv132[rsp], rdx
  000d3	4c 8b c0	 mov	 r8, rax
  000d6	48 8b d1	 mov	 rdx, rcx
  000d9	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  000de	48 8b c8	 mov	 rcx, rax
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN4@antrl3Vect:

; 1279 : 	}
; 1280 : 
; 1281 : 	// One less entry in the vector now
; 1282 : 	//
; 1283 : 	vector->count--;

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ef	ff c8		 dec	 eax
  000f1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000f6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1284 : 
; 1285 : 	return  element;

  000f9	48 8b 44 24 20	 mov	 rax, QWORD PTR element$[rsp]
$LN1@antrl3Vect:

; 1286 : }

  000fe	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
antrl3VectorRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorGet
_TEXT	SEGMENT
vector$ = 16
entry$ = 24
antlr3VectorGet PROC					; COMDAT

; 1232 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1233 : 	// Ensure this is a valid request
; 1234 : 	//
; 1235 : 	if	(entry < vector->count)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR vector$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	39 44 24 18	 cmp	 DWORD PTR entry$[rsp], eax
  00016	73 18		 jae	 SHORT $LN2@antlr3Vect

; 1236 : 	{
; 1237 : 		return	vector->elements[entry].element;

  00018	8b 44 24 18	 mov	 eax, DWORD PTR entry$[rsp]
  0001c	48 6b c0 10	 imul	 rax, rax, 16
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR vector$[rsp]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002c	eb 04		 jmp	 SHORT $LN1@antlr3Vect

; 1238 : 	}

  0002e	eb 02		 jmp	 SHORT $LN3@antlr3Vect
$LN2@antlr3Vect:

; 1239 : 	else
; 1240 : 	{
; 1241 : 		// I know nothing, Mr. Fawlty!
; 1242 : 		//
; 1243 : 		return	NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@antlr3Vect:
$LN1@antlr3Vect:

; 1244 : 	}
; 1245 : }

  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
antlr3VectorGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorDel
_TEXT	SEGMENT
tv144 = 32
vector$ = 64
entry$ = 72
antlr3VectorDel PROC					; COMDAT

; 1196 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1197 : 	// Check this is a valid request first
; 1198 : 	//
; 1199 : 	if	(entry >= vector->count)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00027	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002a	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0002e	72 05		 jb	 SHORT $LN2@antlr3Vect

; 1200 : 	{
; 1201 : 		return;

  00030	e9 ea 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1202 : 	}
; 1203 : 
; 1204 : 	// Valid request, check for free pointer and call it if present
; 1205 : 	//
; 1206 : 	if	(vector->elements[entry].freeptr != NULL)

  00035	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00039	48 6b c0 10	 imul	 rax, rax, 16
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  0004b	74 42		 je	 SHORT $LN3@antlr3Vect

; 1207 : 	{
; 1208 : 		vector->elements[entry].freeptr(vector->elements[entry].element);

  0004d	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00051	48 6b c0 10	 imul	 rax, rax, 16
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0005a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005d	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  00061	48 6b d2 10	 imul	 rdx, rdx, 16
  00065	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  0006a	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0006d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00071	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]

; 1209 : 		vector->elements[entry].freeptr    = NULL;

  00076	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  0007a	48 6b c0 10	 imul	 rax, rax, 16
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0
$LN3@antlr3Vect:

; 1210 : 	}
; 1211 : 
; 1212 : 	if	(entry == vector->count - 1)

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00094	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00097	ff c8		 dec	 eax
  00099	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0009d	75 1a		 jne	 SHORT $LN4@antlr3Vect

; 1213 : 	{
; 1214 : 		// Ensure the pointer is never reused by accident, but otherwise just 
; 1215 : 		// decrement the pointer.
; 1216 : 		//
; 1217 : 		vector->elements[entry].element    = NULL;

  0009f	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  000a3	48 6b c0 10	 imul	 rax, rax, 16
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000ac	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000af	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1218 : 	}

  000b7	eb 54		 jmp	 SHORT $LN5@antlr3Vect
$LN4@antlr3Vect:

; 1219 : 	else
; 1220 : 	{
; 1221 : 		// Need to shuffle trailing pointers back over the deleted entry
; 1222 : 		//
; 1223 : 		ANTLR3_MEMMOVE(vector->elements + entry, vector->elements + entry + 1, sizeof(ANTLR3_VECTOR_ELEMENT) * (vector->count - entry - 1));

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000be	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  000c2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c5	2b c1		 sub	 eax, ecx
  000c7	ff c8		 dec	 eax
  000c9	8b c0		 mov	 eax, eax
  000cb	48 6b c0 10	 imul	 rax, rax, 16
  000cf	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  000d3	48 6b c9 10	 imul	 rcx, rcx, 16
  000d7	48 8b 54 24 40	 mov	 rdx, QWORD PTR vector$[rsp]
  000dc	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000df	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  000e4	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  000e8	48 6b d2 10	 imul	 rdx, rdx, 16
  000ec	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  000f1	49 03 10	 add	 rdx, QWORD PTR [r8]
  000f4	48 89 54 24 20	 mov	 QWORD PTR tv144[rsp], rdx
  000f9	4c 8b c0	 mov	 r8, rax
  000fc	48 8b d1	 mov	 rdx, rcx
  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR tv144[rsp]
  00104	48 8b c8	 mov	 rcx, rax
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN5@antlr3Vect:

; 1224 : 	}
; 1225 : 
; 1226 : 	// One less entry in the vector now
; 1227 : 	//
; 1228 : 	vector->count--;

  0010d	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00112	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00115	ff c8		 dec	 eax
  00117	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0011c	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN1@antlr3Vect:

; 1229 : }

  0011f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
antlr3VectorDel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorFree
_TEXT	SEGMENT
entry$ = 32
vector$ = 64
antlr3VectorFree PROC					; COMDAT

; 1162 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1163 : 	ANTLR3_UINT32   entry;
; 1164 : 
; 1165 : 	// We must traverse every entry in the vector and if it has
; 1166 : 	// a pointer to a free function then we call it with the
; 1167 : 	// the entry pointer
; 1168 : 	//
; 1169 : 	for	(entry = 0; entry < vector->count; entry++)

  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR entry$[rsp], 0
  00026	eb 0a		 jmp	 SHORT $LN4@antlr3Vect
$LN2@antlr3Vect:
  00028	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0002c	ff c0		 inc	 eax
  0002e	89 44 24 20	 mov	 DWORD PTR entry$[rsp], eax
$LN4@antlr3Vect:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 20	 cmp	 DWORD PTR entry$[rsp], eax
  0003e	73 77		 jae	 SHORT $LN3@antlr3Vect

; 1170 : 	{
; 1171 : 		if  (vector->elements[entry].freeptr != NULL)

  00040	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00044	48 6b c0 10	 imul	 rax, rax, 16
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00056	74 29		 je	 SHORT $LN5@antlr3Vect

; 1172 : 		{
; 1173 : 			vector->elements[entry].freeptr(vector->elements[entry].element);

  00058	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0005c	48 6b c0 10	 imul	 rax, rax, 16
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	8b 54 24 20	 mov	 edx, DWORD PTR entry$[rsp]
  0006c	48 6b d2 10	 imul	 rdx, rdx, 16
  00070	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  00075	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00078	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0007c	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN5@antlr3Vect:

; 1174 : 		}
; 1175 : 		vector->elements[entry].freeptr    = NULL;

  00081	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00085	48 6b c0 10	 imul	 rax, rax, 16
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0008e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00091	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1176 : 		vector->elements[entry].element    = NULL;

  0009a	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0009e	48 6b c0 10	 imul	 rax, rax, 16
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000a7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000aa	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1177 : 	}

  000b2	e9 71 ff ff ff	 jmp	 $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1178 : 
; 1179 : 	if	(vector->factoryMade == ANTLR3_FALSE)

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000bc	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  000c3	85 c0		 test	 eax, eax
  000c5	75 33		 jne	 SHORT $LN6@antlr3Vect

; 1180 : 	{
; 1181 : 		// The entries are freed, so free the element allocation
; 1182 : 		//
; 1183 :         if  (vector->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000cc	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  000d3	76 0e		 jbe	 SHORT $LN7@antlr3Vect

; 1184 :         {
; 1185 :             ANTLR3_FREE(vector->elements);

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000da	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@antlr3Vect:

; 1186 :         }
; 1187 : 		vector->elements = NULL;

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000e8	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1188 : 
; 1189 : 		// Finally, free the allocation for the vector itself
; 1190 : 		//
; 1191 : 		ANTLR3_FREE(vector);

  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@antlr3Vect:

; 1192 : 	}
; 1193 : }

  000fa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
antlr3VectorFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPeek
_TEXT	SEGMENT
stack$ = 16
antlr3StackPeek PROC					; COMDAT

; 1042 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1043 :     return  stack->top;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stack$[rsp]
  0000b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1044 : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr3StackPeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackSize
_TEXT	SEGMENT
stack$ = 16
antlr3StackSize PROC					; COMDAT

; 1000 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1001 :     return  stack->vector->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stack$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1002 : }

  00011	5f		 pop	 rdi
  00012	c3		 ret	 0
antlr3StackSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPush
_TEXT	SEGMENT
stack$ = 48
element$ = 56
freeptr$ = 64
antlr3StackPush PROC					; COMDAT

; 1048 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1049 :     stack->top	= element;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR element$[rsp]
  00032	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1050 :     return (ANTLR3_BOOLEAN)(stack->vector->add(stack->vector, element, freeptr));

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	4c 8b 44 24 40	 mov	 r8, QWORD PTR freeptr$[rsp]
  00043	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 1051 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
antlr3StackPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackGet
_TEXT	SEGMENT
stack$ = 48
key$ = 56
antlr3StackGet PROC					; COMDAT

; 1036 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1037 :     return  stack->vector->get(stack->vector, (ANTLR3_UINT32)key);

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	8b 54 24 38	 mov	 edx, DWORD PTR key$[rsp]
  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  00034	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00037	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 1038 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
antlr3StackGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPop
_TEXT	SEGMENT
tv86 = 32
tv83 = 40
stack$ = 64
antlr3StackPop PROC					; COMDAT

; 1019 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1020 :     // Delete the element that is currently at the top of the stack
; 1021 :     //
; 1022 :     stack->vector->del(stack->vector, stack->vector->count - 1);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00029	ff c8		 dec	 eax
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 89 4c 24 20	 mov	 QWORD PTR tv86[rsp], rcx
  00038	8b d0		 mov	 edx, eax
  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0003f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR tv86[rsp]
  00047	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 1023 : 
; 1024 :     // And get the element that is the now the top of the stack (if anything)
; 1025 :     // NOTE! This is not quite like a 'real' stack, which would normally return you
; 1026 :     // the current top of the stack, then remove it from the stack.
; 1027 :     // TODO: Review this, it is correct for follow sets which is what this was done for
; 1028 :     //       but is not as obvious when using it as a 'real'stack.
; 1029 :     //
; 1030 :     stack->top = stack->vector->get(stack->vector, stack->vector->count - 1);

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00058	ff c8		 dec	 eax
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  0005f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00062	48 89 4c 24 28	 mov	 QWORD PTR tv83[rsp], rcx
  00067	8b d0		 mov	 edx, eax
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0006e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR tv83[rsp]
  00076	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  00081	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1031 :     return stack->top;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0008a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1032 : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
antlr3StackPop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackFree
_TEXT	SEGMENT
stack$ = 48
antlr3StackFree PROC					; COMDAT

; 1007 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1008 :     /* Free the list that supports the stack
; 1009 :      */
; 1010 :     stack->vector->free(stack->vector);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 1011 :     stack->vector   = NULL;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00039	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1012 :     stack->top	    = NULL;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00045	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1013 : 
; 1014 :     ANTLR3_FREE(stack);

  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1015 : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
antlr3StackFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListSize
_TEXT	SEGMENT
list$ = 48
antlr3ListSize PROC					; COMDAT

; 899  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 900  :     return  list->table->size(list->table);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	ff 50 60	 call	 QWORD PTR [rax+96]

; 901  : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
antlr3ListSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListRemove
_TEXT	SEGMENT
entry$ = 32
list$ = 64
key$ = 72
antlr3ListRemove PROC					; COMDAT

; 942  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 943  :     pANTLR3_HASH_ENTRY	    entry;
; 944  : 
; 945  :     entry = list->table->removeI(list->table, key);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	ff 50 48	 call	 QWORD PTR [rax+72]
  0003b	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 946  : 
; 947  :     if	(entry != NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00046	74 0d		 je	 SHORT $LN2@antlr3List

; 948  :     {
; 949  :         return  entry->data;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0004d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00051	eb 04		 jmp	 SHORT $LN1@antlr3List

; 950  :     }

  00053	eb 02		 jmp	 SHORT $LN3@antlr3List
$LN2@antlr3List:

; 951  :     else
; 952  :     {
; 953  : 	return	NULL;

  00055	33 c0		 xor	 eax, eax
$LN3@antlr3List:
$LN1@antlr3List:

; 954  :     }
; 955  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
antlr3ListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListAdd
_TEXT	SEGMENT
key$ = 32
list$ = 64
element$ = 72
freeptr$ = 80
antlr3ListAdd PROC					; COMDAT

; 930  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 931  :     ANTLR3_INTKEY   key;
; 932  : 
; 933  :     key	    = list->table->size(list->table) + 1;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	ff 50 60	 call	 QWORD PTR [rax+96]
  0003b	ff c0		 inc	 eax
  0003d	8b c0		 mov	 eax, eax
  0003f	48 89 44 24 20	 mov	 QWORD PTR key$[rsp], rax

; 934  :     return list->put(list, key, element, freeptr);

  00044	4c 8b 4c 24 50	 mov	 r9, QWORD PTR freeptr$[rsp]
  00049	4c 8b 44 24 48	 mov	 r8, QWORD PTR element$[rsp]
  0004e	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$[rsp]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  0005d	ff 50 30	 call	 QWORD PTR [rax+48]

; 935  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3ListAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListPut
_TEXT	SEGMENT
list$ = 48
key$ = 56
element$ = 64
freeptr$ = 72
antlr3ListPut PROC					; COMDAT

; 959  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 960  :     return  list->table->putI(list->table, key, element, freeptr);

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	4c 8b 4c 24 48	 mov	 r9, QWORD PTR freeptr$[rsp]
  0003a	4c 8b 44 24 40	 mov	 r8, QWORD PTR element$[rsp]
  0003f	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	ff 50 58	 call	 QWORD PTR [rax+88]

; 961  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
antlr3ListPut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListGet
_TEXT	SEGMENT
list$ = 48
key$ = 56
antlr3ListGet PROC					; COMDAT

; 923  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 924  :     return list->table->getI(list->table, key);

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	ff 50 50	 call	 QWORD PTR [rax+80]

; 925  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
antlr3ListGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListDelete
_TEXT	SEGMENT
list$ = 48
key$ = 56
antlr3ListDelete PROC					; COMDAT

; 917  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 918  :     list->table->delI(list->table, key);

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	ff 50 40	 call	 QWORD PTR [rax+64]

; 919  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
antlr3ListDelete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListFree
_TEXT	SEGMENT
list$ = 48
antlr3ListFree PROC					; COMDAT

; 905  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 906  :     /* Free the hashtable that stores the list
; 907  :      */
; 908  :     list->table->free(list->table);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	ff 50 18	 call	 QWORD PTR [rax+24]

; 909  : 
; 910  :     /* Free the allocation for the list itself
; 911  :      */
; 912  :     ANTLR3_FREE(list);

  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 913  : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
antlr3ListFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumFree
_TEXT	SEGMENT
en$ = 48
antlr3EnumFree PROC					; COMDAT

; 823  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 824  :     /* Nothing to check, we just free it.
; 825  :      */
; 826  :     ANTLR3_FREE(en);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 827  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
antlr3EnumFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNext
_TEXT	SEGMENT
en$ = 48
key$ = 56
data$ = 64
antlr3EnumNext PROC					; COMDAT

; 730  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 731  :     /* If the current entry is valid, then use it
; 732  :      */
; 733  :     if  (en->bucket >= en->table->modulo)

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0003b	72 07		 jb	 SHORT $LN2@antlr3Enum

; 734  :     {
; 735  :         /* Already exhausted the table
; 736  :          */
; 737  :         return	ANTLR3_FAIL;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 32		 jmp	 SHORT $LN1@antlr3Enum
$LN2@antlr3Enum:

; 738  :     }
; 739  : 
; 740  :     /* Pointers are already set to the current entry to return, or
; 741  :      * we would not be at this point in the logic flow.
; 742  :      */
; 743  :     *key	= &(en->entry->keybase);

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00052	48 89 01	 mov	 QWORD PTR [rcx], rax

; 744  :     *data	= en->entry->data;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00063	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00067	48 89 01	 mov	 QWORD PTR [rcx], rax

; 745  : 
; 746  :     /* Return pointers are set up, so now we move the element
; 747  :      * pointer to the next in the table (if any).
; 748  :      */
; 749  :     antlr3EnumNextEntry(en);

  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  0006f	e8 00 00 00 00	 call	 antlr3EnumNextEntry

; 750  : 
; 751  :     return	ANTLR3_SUCCESS;

  00074	33 c0		 xor	 eax, eax
$LN1@antlr3Enum:

; 752  : }

  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
antlr3EnumNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashSize
_TEXT	SEGMENT
table$ = 16
antlr3HashSize PROC					; COMDAT

; 267  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 268  :     return  table->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR table$[rsp]
  0000b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 269  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr3HashSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashFree
_TEXT	SEGMENT
bucket$ = 32
thisBucket$ = 40
entry$ = 48
nextEntry$ = 56
table$ = 80
antlr3HashFree PROC					; COMDAT

; 196  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 197  :     ANTLR3_UINT32	bucket;	/* Used to traverse the buckets	*/
; 198  : 
; 199  :     pANTLR3_HASH_BUCKET	thisBucket;
; 200  :     pANTLR3_HASH_ENTRY	entry;
; 201  :     pANTLR3_HASH_ENTRY	nextEntry;
; 202  : 
; 203  :     /* Free the table, all buckets and all entries, and all the
; 204  :      * keys and data (if the table exists)
; 205  :      */
; 206  :     if	(table	!= NULL)

  0001e	48 83 7c 24 50
	00		 cmp	 QWORD PTR table$[rsp], 0
  00024	0f 84 e7 00 00
	00		 je	 $LN7@antlr3Hash

; 207  :     {
; 208  : 	for	(bucket = 0; bucket < table->modulo; bucket++)

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bucket$[rsp], 0
  00032	eb 0a		 jmp	 SHORT $LN4@antlr3Hash
$LN2@antlr3Hash:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR bucket$[rsp]
  00038	ff c0		 inc	 eax
  0003a	89 44 24 20	 mov	 DWORD PTR bucket$[rsp], eax
$LN4@antlr3Hash:
  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00043	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00046	39 44 24 20	 cmp	 DWORD PTR bucket$[rsp], eax
  0004a	0f 83 b2 00 00
	00		 jae	 $LN3@antlr3Hash

; 209  : 	{
; 210  : 	    thisBucket	= &(table->buckets[bucket]);

  00050	8b 44 24 20	 mov	 eax, DWORD PTR bucket$[rsp]
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00059	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00061	48 89 44 24 28	 mov	 QWORD PTR thisBucket$[rsp], rax

; 211  : 
; 212  : 	    /* Allow sparse tables, though we don't create them as such at present
; 213  : 	     */
; 214  : 	    if	( thisBucket != NULL)

  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR thisBucket$[rsp], 0
  0006c	0f 84 8b 00 00
	00		 je	 $LN8@antlr3Hash

; 215  : 	    {
; 216  : 		entry	= thisBucket->entries;

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR thisBucket$[rsp]
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 217  : 
; 218  : 		/* Search all entries in the bucket and free them up
; 219  : 		 */
; 220  : 		while	(entry != NULL)

  0007f	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00085	74 6a		 je	 SHORT $LN6@antlr3Hash

; 221  : 		{
; 222  : 		    /* Save next entry - we do not want to access memory in entry after we
; 223  : 		     * have freed it.
; 224  : 		     */
; 225  : 		    nextEntry	= entry->nextEntry;

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0008c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00090	48 89 44 24 38	 mov	 QWORD PTR nextEntry$[rsp], rax

; 226  : 
; 227  : 		    /* Free any data pointer, this only happens if the user supplied
; 228  : 		     * a pointer to a routine that knwos how to free the structure they
; 229  : 		     * added to the table.
; 230  : 		     */
; 231  : 		    if	(entry->free != NULL)

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0009a	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0009f	74 11		 je	 SHORT $LN9@antlr3Hash

; 232  : 		    {
; 233  : 			entry->free(entry->data);

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000a6	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000af	ff 50 18	 call	 QWORD PTR [rax+24]
$LN9@antlr3Hash:

; 234  : 		    }
; 235  : 
; 236  : 		    /* Free the key memory - we know that we allocated this
; 237  : 		     */
; 238  : 		    if	(entry->keybase.type == ANTLR3_HASH_TYPE_STR && entry->keybase.key.sKey != NULL)

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000b7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	75 1b		 jne	 SHORT $LN10@antlr3Hash
  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000c4	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c9	74 0f		 je	 SHORT $LN10@antlr3Hash

; 239  : 		    {
; 240  : 			ANTLR3_FREE(entry->keybase.key.sKey);

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000d0	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN10@antlr3Hash:

; 241  : 		    }
; 242  : 
; 243  : 		    /* Free this entry
; 244  : 		     */
; 245  : 		    ANTLR3_FREE(entry);

  000da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 246  : 		    entry   = nextEntry;    /* Load next pointer to see if we shoud free it */

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR nextEntry$[rsp]
  000ea	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 247  : 		}

  000ef	eb 8e		 jmp	 SHORT $LN5@antlr3Hash
$LN6@antlr3Hash:

; 248  : 		/* Invalidate the current pointer
; 249  : 		 */
; 250  : 		thisBucket->entries = NULL;

  000f1	48 8b 44 24 28	 mov	 rax, QWORD PTR thisBucket$[rsp]
  000f6	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN8@antlr3Hash:

; 251  : 	    }
; 252  : 	}

  000fd	e9 32 ff ff ff	 jmp	 $LN2@antlr3Hash
$LN3@antlr3Hash:

; 253  : 
; 254  : 	/* Now we can free the bucket memory
; 255  : 	 */
; 256  : 	ANTLR3_FREE(table->buckets);

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00107	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@antlr3Hash:

; 257  :     }
; 258  : 
; 259  :     /* Now we free teh memory for the table itself
; 260  :      */
; 261  :     ANTLR3_FREE(table);

  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 262  : }

  0011c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
antlr3HashFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashPutI
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
newPointer$ = 56
tv65 = 64
table$ = 96
key$ = 104
element$ = 112
freeptr$ = 120
antlr3HashPutI PROC					; COMDAT

; 524  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 525  : 	ANTLR3_UINT32	    hash;
; 526  : 	pANTLR3_HASH_BUCKET	    bucket;
; 527  : 	pANTLR3_HASH_ENTRY	    entry;
; 528  : 	pANTLR3_HASH_ENTRY	    * newPointer;
; 529  : 
; 530  : 	/* First we need to know the hash of the provided key
; 531  : 	*/
; 532  : 	hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  00032	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00035	48 89 44 24 40	 mov	 QWORD PTR tv65[rsp], rax
  0003a	33 d2		 xor	 edx, edx
  0003c	48 8b 44 24 68	 mov	 rax, QWORD PTR key$[rsp]
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv65[rsp]
  00046	48 f7 f1	 div	 rcx
  00049	48 8b c2	 mov	 rax, rdx
  0004c	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 533  : 
; 534  : 	/* Knowing the hash, we can find the bucket
; 535  : 	*/
; 536  : 	bucket  = table->buckets + hash;

  00050	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  00054	48 8b 4c 24 60	 mov	 rcx, QWORD PTR table$[rsp]
  00059	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00061	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 537  : 
; 538  : 	/* Knowing the bucket, we can traverse the entries until we
; 539  : 	* we find a NULL pointer or we find that this is already 
; 540  : 	* in the table and duplicates were not allowed.
; 541  : 	*/
; 542  : 	newPointer	= &bucket->entries;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  0006b	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax
$LN2@antlr3Hash:

; 543  : 
; 544  : 	while   (*newPointer !=  NULL)

  00070	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00075	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00079	74 3a		 je	 SHORT $LN3@antlr3Hash

; 545  : 	{
; 546  : 		/* The value at new pointer is pointing to an existing entry.
; 547  : 		* If duplicates are allowed then we don't care what it is, but
; 548  : 		* must reject this add if the key is the same as the one we are
; 549  : 		* supplied with.
; 550  : 		*/
; 551  : 		if  (table->allowDups == ANTLR3_FALSE)

  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  00080	83 38 00	 cmp	 DWORD PTR [rax], 0
  00083	75 1d		 jne	 SHORT $LN4@antlr3Hash

; 552  : 		{
; 553  : 			if	((*newPointer)->keybase.key.iKey == key)

  00085	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0008a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  00092	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00096	75 0a		 jne	 SHORT $LN5@antlr3Hash

; 554  : 			{
; 555  : 				return	ANTLR3_ERR_HASHDUP;

  00098	b8 03 00 00 00	 mov	 eax, 3
  0009d	e9 92 00 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:
$LN4@antlr3Hash:

; 556  : 			}
; 557  : 		}
; 558  : 
; 559  : 		/* Point to the next entry pointer of the current entry we
; 560  : 		* are traversing, if it is NULL we will create our new
; 561  : 		* structure and point this to it.
; 562  : 		*/
; 563  : 		newPointer = &((*newPointer)->nextEntry);

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  000a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000aa	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ae	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax

; 564  : 	}

  000b3	eb bb		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 565  : 
; 566  : 	/* newPointer is now pointing at the pointer where we need to
; 567  : 	* add our new entry, so let's crate the entry and add it in.
; 568  : 	*/
; 569  : 	entry   = (pANTLR3_HASH_ENTRY)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENTRY));

  000b5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c0	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 570  : 
; 571  : 	if	(entry == NULL)

  000c5	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000cb	75 07		 jne	 SHORT $LN6@antlr3Hash

; 572  : 	{
; 573  : 		return	ANTLR3_ERR_NOMEM;

  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	eb 60		 jmp	 SHORT $LN1@antlr3Hash
$LN6@antlr3Hash:

; 574  : 	}
; 575  : 
; 576  : 	entry->data			= element;		/* Install the data element supplied			*/

  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR element$[rsp]
  000de	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 577  : 	entry->free			= freeptr;		/* Function that knows how to release the entry		*/

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freeptr$[rsp]
  000ec	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 578  : 	entry->keybase.type		= ANTLR3_HASH_TYPE_INT;	/* Indicate the key type stored here for when we free	*/

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f5	c6 00 00	 mov	 BYTE PTR [rax], 0

; 579  : 	entry->keybase.key.iKey	= key;			/* Record the key value					*/

  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  00102	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 580  : 	entry->nextEntry		= NULL;			/* Ensure that the forward pointer ends the chain	*/

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0010b	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 581  : 
; 582  : 	*newPointer	= entry;    /* Install the next entry in this bucket	*/

  00113	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00118	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  0011d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 583  : 
; 584  : 	table->count++;

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  00125	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00128	ff c0		 inc	 eax
  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR table$[rsp]
  0012f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 585  : 
; 586  : 	return  ANTLR3_SUCCESS;

  00132	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 587  : }

  00134	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00138	5f		 pop	 rdi
  00139	c3		 ret	 0
antlr3HashPutI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashRemoveI
_TEXT	SEGMENT
hash$ = 0
bucket$ = 8
entry$ = 16
nextPointer$ = 24
tv65 = 32
table$ = 64
key$ = 72
antlr3HashRemoveI PROC					; COMDAT

; 275  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 276  :     ANTLR3_UINT32	    hash;
; 277  :     pANTLR3_HASH_BUCKET	    bucket;
; 278  :     pANTLR3_HASH_ENTRY	    entry;
; 279  :     pANTLR3_HASH_ENTRY	    * nextPointer;
; 280  : 
; 281  :     /* First we need to know the hash of the provided key
; 282  :      */
; 283  :     hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR table$[rsp]
  00028	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0002b	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  0003c	48 f7 f1	 div	 rcx
  0003f	48 8b c2	 mov	 rax, rdx
  00042	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 284  : 
; 285  :     /* Knowing the hash, we can find the bucket
; 286  :      */
; 287  :     bucket  = table->buckets + hash;

  00045	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  0004d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00051	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00055	48 89 44 24 08	 mov	 QWORD PTR bucket$[rsp], rax

; 288  : 
; 289  :     /* Now, we traverse the entries in the bucket until
; 290  :      * we find the key or the end of the entries in the bucket. 
; 291  :      * We track the element prior to the one we are examining
; 292  :      * as we need to set its next pointer to the next pointer
; 293  :      * of the entry we are deleting (if we find it).
; 294  :      */
; 295  :     entry	    =   bucket->entries;    /* Entry to examine					    */

  0005a	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax

; 296  :     nextPointer	    = & bucket->entries;    /* Where to put the next pointer of the deleted entry   */

  00067	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  0006c	48 89 44 24 18	 mov	 QWORD PTR nextPointer$[rsp], rax
$LN2@antlr3Hash:

; 297  : 
; 298  :     while   (entry != NULL)

  00071	48 83 7c 24 10
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00077	74 5a		 je	 SHORT $LN3@antlr3Hash

; 299  :     {
; 300  : 	/* See if this is the entry we wish to delete
; 301  : 	 */
; 302  : 	if  (entry->keybase.key.iKey == key)

  00079	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00083	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00087	75 2c		 jne	 SHORT $LN4@antlr3Hash

; 303  : 	{
; 304  : 	    /* It was the correct entry, so we set the next pointer
; 305  : 	     * of the previous entry to the next pointer of this
; 306  : 	     * located one, which takes it out of the chain.
; 307  : 	     */
; 308  : 	    (*nextPointer)		= entry->nextEntry;

  00089	48 8b 44 24 18	 mov	 rax, QWORD PTR nextPointer$[rsp]
  0008e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR entry$[rsp]
  00093	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00097	48 89 08	 mov	 QWORD PTR [rax], rcx

; 309  : 
; 310  : 	    table->count--;

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR table$[rsp]
  0009f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a2	ff c8		 dec	 eax
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  000a9	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 311  : 
; 312  : 	    return entry;

  000ac	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  000b1	eb 22		 jmp	 SHORT $LN1@antlr3Hash

; 313  : 	}

  000b3	eb 1c		 jmp	 SHORT $LN5@antlr3Hash
$LN4@antlr3Hash:

; 314  : 	else
; 315  : 	{
; 316  : 	    /* We found an entry but it wasn't the one that was wanted, so
; 317  : 	     * move to the next one, if any.
; 318  : 	     */
; 319  : 	    nextPointer	= & (entry->nextEntry);	    /* Address of the next pointer in the current entry	    */

  000b5	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  000ba	48 83 c0 20	 add	 rax, 32			; 00000020H
  000be	48 89 44 24 18	 mov	 QWORD PTR nextPointer$[rsp], rax

; 320  : 	    entry	= entry->nextEntry;	    /* Address of the next element in the bucket (if any)   */

  000c3	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  000c8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000cc	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 321  : 	}
; 322  :     }

  000d1	eb 9e		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 323  : 
; 324  :     return NULL;  /* Not found */

  000d3	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 325  : }

  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
antlr3HashRemoveI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashGetI
_TEXT	SEGMENT
hash$ = 0
bucket$ = 8
entry$ = 16
tv65 = 24
table$ = 48
key$ = 56
antlr3HashGetI PROC					; COMDAT

; 445  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 446  :     ANTLR3_UINT32	    hash;
; 447  :     pANTLR3_HASH_BUCKET	    bucket;
; 448  :     pANTLR3_HASH_ENTRY	    entry;
; 449  : 
; 450  :     /* First we need to know the hash of the provided key
; 451  :      */
; 452  :     hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR table$[rsp]
  00028	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0002b	48 89 44 24 18	 mov	 QWORD PTR tv65[rsp], rax
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR key$[rsp]
  00037	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tv65[rsp]
  0003c	48 f7 f1	 div	 rcx
  0003f	48 8b c2	 mov	 rax, rdx
  00042	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 453  : 
; 454  :     /* Knowing the hash, we can find the bucket
; 455  :      */
; 456  :     bucket  = table->buckets + hash;

  00045	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  0004d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00051	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00055	48 89 44 24 08	 mov	 QWORD PTR bucket$[rsp], rax

; 457  : 
; 458  :     /* Now we can inspect the key at each entry in the bucket
; 459  :      * and see if we have a match.
; 460  :      */
; 461  :     entry   = bucket->entries;

  0005a	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax
$LN2@antlr3Hash:

; 462  : 
; 463  :     while   (entry != NULL)

  00067	48 83 7c 24 10
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0006d	74 2b		 je	 SHORT $LN3@antlr3Hash

; 464  :     {
; 465  : 	if  (entry->keybase.key.iKey == key)

  0006f	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  00074	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00079	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0007d	75 0b		 jne	 SHORT $LN4@antlr3Hash

; 466  : 	{
; 467  : 	    /* Match was found, return the data pointer for this entry
; 468  : 	     */
; 469  : 	    return  entry->data;

  0007f	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  00084	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00088	eb 12		 jmp	 SHORT $LN1@antlr3Hash
$LN4@antlr3Hash:

; 470  : 	}
; 471  : 	entry = entry->nextEntry;

  0008a	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  0008f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00093	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax

; 472  :     }

  00098	eb cd		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 473  : 
; 474  :     /* If we got here, then we did not find the key
; 475  :      */
; 476  :     return  NULL;

  0009a	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 477  : }

  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
antlr3HashGetI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashDeleteI
_TEXT	SEGMENT
entry$ = 32
table$ = 64
key$ = 72
antlr3HashDeleteI PROC					; COMDAT

; 397  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 398  :     pANTLR3_HASH_ENTRY	entry;
; 399  : 
; 400  :     entry = antlr3HashRemoveI(table, key);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3HashRemoveI
  00032	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 401  : 	
; 402  :     /* Now we can free the elements and the entry in order
; 403  :      */
; 404  :     if	(entry != NULL && entry->free != NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0003d	74 2a		 je	 SHORT $LN2@antlr3Hash
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00044	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00049	74 1e		 je	 SHORT $LN2@antlr3Hash

; 405  :     {
; 406  : 	/* Call programmer supplied function to release this entry data
; 407  : 	 */
; 408  : 	entry->free(entry->data);

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00050	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00059	ff 50 18	 call	 QWORD PTR [rax+24]

; 409  : 	entry->data = NULL;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00061	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN2@antlr3Hash:

; 410  :     }
; 411  :     /* Finally release the space for this entry block.
; 412  :      */
; 413  :     ANTLR3_FREE(entry);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 414  : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
antlr3HashDeleteI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashPut
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
newPointer$ = 56
table$ = 80
key$ = 88
element$ = 96
freeptr$ = 104
antlr3HashPut PROC					; COMDAT

; 595  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 596  : 	ANTLR3_UINT32	    hash;
; 597  : 	pANTLR3_HASH_BUCKET	    bucket;
; 598  : 	pANTLR3_HASH_ENTRY	    entry;
; 599  : 	pANTLR3_HASH_ENTRY	    * newPointer;
; 600  : 
; 601  : 	/* First we need to know the hash of the provided key
; 602  : 	*/
; 603  : 	hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  0002d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00032	e8 00 00 00 00	 call	 strlen
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0003e	e8 00 00 00 00	 call	 antlr3Hash
  00043	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 604  : 
; 605  : 	/* Knowing the hash, we can find the bucket
; 606  : 	*/
; 607  : 	bucket  = table->buckets + (hash % table->modulo);

  00047	33 d2		 xor	 edx, edx
  00049	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00052	f7 71 04	 div	 DWORD PTR [rcx+4]
  00055	8b c2		 mov	 eax, edx
  00057	8b c0		 mov	 eax, eax
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  0005e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00062	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00066	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 608  : 
; 609  : 	/* Knowign the bucket, we can traverse the entries until we
; 610  : 	* we find a NULL pointer ofr we find that this is already 
; 611  : 	* in the table and duplicates were not allowed.
; 612  : 	*/
; 613  : 	newPointer	= &bucket->entries;

  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00070	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax
$LN2@antlr3Hash:

; 614  : 
; 615  : 	while   (*newPointer !=  NULL)

  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0007a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0007e	74 41		 je	 SHORT $LN3@antlr3Hash

; 616  : 	{
; 617  : 		/* The value at new pointer is pointing to an existing entry.
; 618  : 		* If duplicates are allowed then we don't care what it is, but
; 619  : 		* must reject this add if the key is the same as the one we are
; 620  : 		* supplied with.
; 621  : 		*/
; 622  : 		if  (table->allowDups == ANTLR3_FALSE)

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00085	83 38 00	 cmp	 DWORD PTR [rax], 0
  00088	75 24		 jne	 SHORT $LN4@antlr3Hash

; 623  : 		{
; 624  : 			if	(strcmp((const char*) key, (const char *)(*newPointer)->keybase.key.sKey) == 0)

  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0008f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00092	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00096	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0009b	e8 00 00 00 00	 call	 strcmp
  000a0	85 c0		 test	 eax, eax
  000a2	75 0a		 jne	 SHORT $LN5@antlr3Hash

; 625  : 			{
; 626  : 				return	ANTLR3_ERR_HASHDUP;

  000a4	b8 03 00 00 00	 mov	 eax, 3
  000a9	e9 b9 00 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:
$LN4@antlr3Hash:

; 627  : 			}
; 628  : 		}
; 629  : 
; 630  : 		/* Point to the next entry pointer of the current entry we
; 631  : 		* are traversing, if it is NULL we will create our new
; 632  : 		* structure and point this to it.
; 633  : 		*/
; 634  : 		newPointer = &((*newPointer)->nextEntry);

  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ba	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax

; 635  : 	}

  000bf	eb b4		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 636  : 
; 637  : 	/* newPointer is now poiting at the pointer where we need to
; 638  : 	* add our new entry, so let's crate the entry and add it in.
; 639  : 	*/
; 640  : 	entry   = (pANTLR3_HASH_ENTRY)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENTRY));

  000c1	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000cc	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 641  : 
; 642  : 	if	(entry == NULL)

  000d1	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000d7	75 0a		 jne	 SHORT $LN6@antlr3Hash

; 643  : 	{
; 644  : 		return	ANTLR3_ERR_NOMEM;

  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	e9 84 00 00 00	 jmp	 $LN1@antlr3Hash
$LN6@antlr3Hash:

; 645  : 	}
; 646  : 
; 647  : 	entry->data			= element;					/* Install the data element supplied				*/

  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR element$[rsp]
  000ed	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 648  : 	entry->free			= freeptr;					/* Function that knows how to release the entry	    */

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR freeptr$[rsp]
  000fb	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 649  : 	entry->keybase.type	= ANTLR3_HASH_TYPE_STR;     /* Indicate the key type stored here for free()	    */

  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00104	c6 00 01	 mov	 BYTE PTR [rax], 1

; 650  :     if  (table->doStrdup == ANTLR3_TRUE)

  00107	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  0010c	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  00110	83 f8 01	 cmp	 eax, 1
  00113	75 16		 jne	 SHORT $LN7@antlr3Hash

; 651  :     {
; 652  :         entry->keybase.key.sKey	= ANTLR3_STRDUP(key);	/* Record the key value								*/

  00115	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  00125	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 653  :     }

  00129	eb 0e		 jmp	 SHORT $LN8@antlr3Hash
$LN7@antlr3Hash:

; 654  :     else
; 655  :     {
; 656  :         entry->keybase.key.sKey	= key;                  /* Record the key value								*/

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00130	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00135	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN8@antlr3Hash:

; 657  :     }
; 658  : 	entry->nextEntry		= NULL;					/* Ensure that the forward pointer ends the chain   */

  00139	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0013e	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 659  : 
; 660  : 	*newPointer	= entry;    /* Install the next entry in this bucket	*/

  00146	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  00150	48 89 08	 mov	 QWORD PTR [rax], rcx

; 661  : 
; 662  : 	table->count++;

  00153	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00158	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0015b	ff c0		 inc	 eax
  0015d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00162	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 663  : 
; 664  : 	return  ANTLR3_SUCCESS;

  00165	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 665  : }

  00167	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0016b	5f		 pop	 rdi
  0016c	c3		 ret	 0
antlr3HashPut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashRemove
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
nextPointer$ = 56
table$ = 80
key$ = 88
antlr3HashRemove PROC					; COMDAT

; 332  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 333  :     ANTLR3_UINT32	    hash;
; 334  :     pANTLR3_HASH_BUCKET	    bucket;
; 335  :     pANTLR3_HASH_ENTRY	    entry;
; 336  :     pANTLR3_HASH_ENTRY	    * nextPointer;
; 337  : 
; 338  :     /* First we need to know the hash of the provided key
; 339  :      */
; 340  :     hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	8b d0		 mov	 edx, eax
  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00034	e8 00 00 00 00	 call	 antlr3Hash
  00039	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 341  : 
; 342  :     /* Knowing the hash, we can find the bucket
; 343  :      */
; 344  :     bucket  = table->buckets + (hash % table->modulo);

  0003d	33 d2		 xor	 edx, edx
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00048	f7 71 04	 div	 DWORD PTR [rcx+4]
  0004b	8b c2		 mov	 eax, edx
  0004d	8b c0		 mov	 eax, eax
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00054	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00058	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0005c	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 345  : 
; 346  :     /* Now, we traverse the entries in the bucket until
; 347  :      * we find the key or the end of the entires in the bucket. 
; 348  :      * We track the element prior to the one we are exmaining
; 349  :      * as we need to set its next pointer to the next pointer
; 350  :      * of the entry we are deleting (if we find it).
; 351  :      */
; 352  :     entry	    =   bucket->entries;    /* Entry to examine					    */

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 353  :     nextPointer	    = & bucket->entries;    /* Where to put the next pointer of the deleted entry   */

  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00073	48 89 44 24 38	 mov	 QWORD PTR nextPointer$[rsp], rax
$LN2@antlr3Hash:

; 354  : 
; 355  :     while   (entry != NULL)

  00078	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0007e	0f 84 8e 00 00
	00		 je	 $LN3@antlr3Hash

; 356  :     {
; 357  : 	/* See if this is the entry we wish to delete
; 358  : 	 */
; 359  : 	if  (strcmp((const char *)key, (const char *)entry->keybase.key.sKey) == 0)

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00089	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00092	e8 00 00 00 00	 call	 strcmp
  00097	85 c0		 test	 eax, eax
  00099	75 56		 jne	 SHORT $LN4@antlr3Hash

; 360  : 	{
; 361  : 	    /* It was the correct entry, so we set the next pointer
; 362  : 	     * of the previous entry to the next pointer of this
; 363  : 	     * located one, which takes it out of the chain.
; 364  : 	     */
; 365  : 	    (*nextPointer)		= entry->nextEntry;

  0009b	48 8b 44 24 38	 mov	 rax, QWORD PTR nextPointer$[rsp]
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  000a5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 366  : 
; 367  : 	    /* Release the key - if we allocated that
; 368  : 	     */
; 369  :         if (table->doStrdup == ANTLR3_TRUE)

  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  000b1	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  000b5	83 f8 01	 cmp	 eax, 1
  000b8	75 0f		 jne	 SHORT $LN6@antlr3Hash

; 370  :         {
; 371  :             ANTLR3_FREE(entry->keybase.key.sKey);

  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000bf	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@antlr3Hash:

; 372  :         }
; 373  : 	    entry->keybase.key.sKey	= NULL;

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000ce	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 374  : 
; 375  : 	    table->count--;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  000db	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000de	ff c8		 dec	 eax
  000e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  000e5	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 376  : 
; 377  : 	    return entry;

  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000ed	eb 25		 jmp	 SHORT $LN1@antlr3Hash

; 378  : 	}

  000ef	eb 1c		 jmp	 SHORT $LN5@antlr3Hash
$LN4@antlr3Hash:

; 379  : 	else
; 380  : 	{
; 381  : 	    /* We found an entry but it wasn't the one that was wanted, so
; 382  : 	     * move to the next one, if any.
; 383  : 	     */
; 384  : 	    nextPointer	= & (entry->nextEntry);	    /* Address of the next pointer in the current entry	    */

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f6	48 83 c0 20	 add	 rax, 32			; 00000020H
  000fa	48 89 44 24 38	 mov	 QWORD PTR nextPointer$[rsp], rax

; 385  : 	    entry	= entry->nextEntry;	    /* Address of the next element in the bucket (if any)   */

  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00104	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00108	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 386  : 	}
; 387  :     }

  0010d	e9 66 ff ff ff	 jmp	 $LN2@antlr3Hash
$LN3@antlr3Hash:

; 388  : 
; 389  :     return NULL;  /* Not found */

  00112	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 390  : }

  00114	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00118	5f		 pop	 rdi
  00119	c3		 ret	 0
antlr3HashRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashGet
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
table$ = 80
key$ = 88
antlr3HashGet PROC					; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 485  :     ANTLR3_UINT32	    hash;
; 486  :     pANTLR3_HASH_BUCKET	    bucket;
; 487  :     pANTLR3_HASH_ENTRY	    entry;
; 488  : 
; 489  : 
; 490  :     /* First we need to know the hash of the provided key
; 491  :      */
; 492  :     hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	8b d0		 mov	 edx, eax
  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00034	e8 00 00 00 00	 call	 antlr3Hash
  00039	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 493  : 
; 494  :     /* Knowing the hash, we can find the bucket
; 495  :      */
; 496  :     bucket  = table->buckets + (hash % table->modulo);

  0003d	33 d2		 xor	 edx, edx
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00048	f7 71 04	 div	 DWORD PTR [rcx+4]
  0004b	8b c2		 mov	 eax, edx
  0004d	8b c0		 mov	 eax, eax
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00054	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00058	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0005c	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 497  : 
; 498  :     /* Now we can inspect the key at each entry in the bucket
; 499  :      * and see if we have a match.
; 500  :      */
; 501  :     entry   = bucket->entries;

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN2@antlr3Hash:

; 502  : 
; 503  :     while   (entry != NULL)

  0006e	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00074	74 32		 je	 SHORT $LN3@antlr3Hash

; 504  :     {
; 505  : 	if  (strcmp((const char *)key, (const char *)entry->keybase.key.sKey) == 0)

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0007b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00084	e8 00 00 00 00	 call	 strcmp
  00089	85 c0		 test	 eax, eax
  0008b	75 0b		 jne	 SHORT $LN4@antlr3Hash

; 506  : 	{
; 507  : 	    /* Match was found, return the data pointer for this entry
; 508  : 	     */
; 509  : 	    return  entry->data;

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00092	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00096	eb 12		 jmp	 SHORT $LN1@antlr3Hash
$LN4@antlr3Hash:

; 510  : 	}
; 511  : 	entry = entry->nextEntry;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0009d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000a1	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 512  :     }

  000a6	eb c6		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 513  : 
; 514  :     /* If we got here, then we did not find the key
; 515  :      */
; 516  :     return  NULL;

  000a8	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 517  : }

  000aa	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
antlr3HashGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashDelete
_TEXT	SEGMENT
entry$ = 32
table$ = 64
key$ = 72
antlr3HashDelete PROC					; COMDAT

; 421  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 422  :     pANTLR3_HASH_ENTRY	entry;
; 423  : 
; 424  :     entry = antlr3HashRemove(table, key);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3HashRemove
  00032	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 425  : 	
; 426  :     /* Now we can free the elements and the entry in order
; 427  :      */
; 428  :     if	(entry != NULL && entry->free != NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0003d	74 2a		 je	 SHORT $LN2@antlr3Hash
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00044	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00049	74 1e		 je	 SHORT $LN2@antlr3Hash

; 429  :     {
; 430  : 	/* Call programmer supplied function to release this entry data
; 431  : 	 */
; 432  : 	entry->free(entry->data);

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00050	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00059	ff 50 18	 call	 QWORD PTR [rax+24]

; 433  : 	entry->data = NULL;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00061	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN2@antlr3Hash:

; 434  :     }
; 435  :     /* Finally release the space for this entry block.
; 436  :      */
; 437  :     ANTLR3_FREE(entry);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 438  : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
antlr3HashDelete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3TopoNew
_TEXT	SEGMENT
topo$ = 32
antlr3TopoNew PROC					; COMDAT

; 2285 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 0c 00 00 00	 mov	 ecx, 12
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd

; 2286 :     pANTLR3_TOPO topo = (pANTLR3_TOPO)ANTLR3_MALLOC(sizeof(ANTLR3_TOPO));

  00015	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00020	48 89 44 24 20	 mov	 QWORD PTR topo$[rsp], rax

; 2287 : 
; 2288 :     if  (topo == NULL)

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR topo$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN2@antlr3Topo

; 2289 :     {
; 2290 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 99 00 00 00	 jmp	 $LN1@antlr3Topo
$LN2@antlr3Topo:

; 2291 :     }
; 2292 : 
; 2293 :     // Initialize variables
; 2294 :     //
; 2295 : 
; 2296 :     topo->visited   = NULL;                 // Don't know how big it is yet

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00039	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 2297 :     topo->limit     = 1;                    // No edges added yet

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00046	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 2298 :     topo->edges     = NULL;                 // No edges added yet

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00052	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2299 :     topo->sorted    = NULL;                 // Nothing sorted at the start

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0005e	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 2300 :     topo->cycle     = NULL;                 // No cycles at the start

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0006b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 2301 :     topo->cycleMark = 0;                    // No cycles at the start

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00078	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 2302 :     topo->hasCycle  = ANTLR3_FALSE;         // No cycle at the start

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00084	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 2303 :     
; 2304 :     // API
; 2305 :     //
; 2306 :     topo->addEdge       = addEdge;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addEdge
  00094	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 2307 :     topo->sortToArray   = sortToArray;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sortToArray
  000a4	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 2308 :     topo->sortVector    = sortVector;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sortVector
  000b4	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 2309 :     topo->free          = freeTopo;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeTopo
  000c4	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2310 : 
; 2311 :     return topo;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
$LN1@antlr3Topo:

; 2312 : }

  000cd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
antlr3TopoNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3SetVectorApi
_TEXT	SEGMENT
initialSize$ = 32
vector$ = 64
sizeHint$ = 72
antlr3SetVectorApi PROC					; COMDAT

; 1079 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1080 :     ANTLR3_UINT32   initialSize;
; 1081 : 
; 1082 :     // Allow vectors to be guessed by ourselves, so input size can be zero
; 1083 :     //
; 1084 :     if	(sizeHint > ANTLR3_VECTOR_INTERNAL_SIZE)

  00022	83 7c 24 48 10	 cmp	 DWORD PTR sizeHint$[rsp], 16
  00027	76 0a		 jbe	 SHORT $LN2@antlr3SetV

; 1085 :     {
; 1086 :         initialSize = sizeHint;

  00029	8b 44 24 48	 mov	 eax, DWORD PTR sizeHint$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR initialSize$[rsp], eax

; 1087 :     }

  00031	eb 08		 jmp	 SHORT $LN3@antlr3SetV
$LN2@antlr3SetV:

; 1088 :     else
; 1089 :     {
; 1090 :         initialSize = ANTLR3_VECTOR_INTERNAL_SIZE;

  00033	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR initialSize$[rsp], 16
$LN3@antlr3SetV:

; 1091 :     }
; 1092 : 
; 1093 :     if  (sizeHint > ANTLR3_VECTOR_INTERNAL_SIZE)

  0003b	83 7c 24 48 10	 cmp	 DWORD PTR sizeHint$[rsp], 16
  00040	76 1b		 jbe	 SHORT $LN4@antlr3SetV

; 1094 :     {
; 1095 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR_ELEMENT) * initialSize));

  00042	8b 44 24 20	 mov	 eax, DWORD PTR initialSize$[rsp]
  00046	48 6b c0 10	 imul	 rax, rax, 16
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00058	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1096 :     }

  0005b	eb 11		 jmp	 SHORT $LN5@antlr3SetV
$LN4@antlr3SetV:

; 1097 :     else
; 1098 :     {
; 1099 :         vector->elements    = vector->internal;

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00062	48 83 c0 10	 add	 rax, 16
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0006b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@antlr3SetV:

; 1100 :     }
; 1101 : 
; 1102 :     if	(vector->elements == NULL)

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00073	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00077	75 10		 jne	 SHORT $LN6@antlr3SetV

; 1103 :     {
; 1104 :         ANTLR3_FREE(vector);

  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1105 :         return;

  00084	e9 d2 00 00 00	 jmp	 $LN1@antlr3SetV
$LN6@antlr3SetV:

; 1106 :     }
; 1107 : 
; 1108 :     // Memory allocated successfully
; 1109 :     //
; 1110 :     vector->count			= 0;			// No entries yet of course

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0008e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1111 :     vector->elementsSize    = initialSize;  // Available entries

  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0009a	8b 4c 24 20	 mov	 ecx, DWORD PTR initialSize$[rsp]
  0009e	89 88 14 01 00
	00		 mov	 DWORD PTR [rax+276], ecx

; 1112 : 
; 1113 :     // Now we can install the API
; 1114 :     //
; 1115 :     vector->add	    = antlr3VectorAdd;

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorAdd
  000b0	48 89 88 48 01
	00 00		 mov	 QWORD PTR [rax+328], rcx

; 1116 :     vector->del	    = antlr3VectorDel;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorDel
  000c3	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 1117 :     vector->get	    = antlr3VectorGet;

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorGet
  000d6	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 1118 :     vector->free    = antlr3VectorFree;

  000dd	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorFree
  000e9	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 1119 :     vector->set	    = antlr3VectorSet;

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSet
  000fc	48 89 88 50 01
	00 00		 mov	 QWORD PTR [rax+336], rcx

; 1120 :     vector->remove  = antrl3VectorRemove;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antrl3VectorRemove
  0010f	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 1121 :     vector->clear   = antlr3VectorClear;

  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorClear
  00122	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 1122 :     vector->size    = antlr3VectorSize;

  00129	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSize
  00135	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 1123 :     vector->swap    = antlr3VectorSwap;

  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSwap
  00148	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 1124 : 
; 1125 :     // Assume that this is not a factory made vector
; 1126 :     //
; 1127 :     vector->factoryMade	= ANTLR3_FALSE;

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00154	c6 80 10 01 00
	00 00		 mov	 BYTE PTR [rax+272], 0
$LN1@antlr3SetV:

; 1128 : }

  0015b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015f	5f		 pop	 rdi
  00160	c3		 ret	 0
antlr3SetVectorApi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackNew
_TEXT	SEGMENT
stack$ = 32
sizeHint$ = 64
antlr3StackNew PROC					; COMDAT

; 965  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 966  :     pANTLR3_STACK   stack;
; 967  : 
; 968  :     /* Allocate memory
; 969  :      */
; 970  :     stack    = (pANTLR3_STACK)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_STACK));

  0001c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR stack$[rsp], rax

; 971  : 
; 972  :     if	(stack == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR stack$[rsp], 0
  00032	75 0a		 jne	 SHORT $LN2@antlr3Stac

; 973  :     {
; 974  : 	return	(pANTLR3_STACK)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	e9 95 00 00 00	 jmp	 $LN1@antlr3Stac
$LN2@antlr3Stac:

; 975  :     }
; 976  : 
; 977  :     /* Now we need to add a new table
; 978  :      */
; 979  :     stack->vector   = antlr3VectorNew(sizeHint);

  0003e	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  00042	e8 00 00 00 00	 call	 antlr3VectorNew
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stack$[rsp]
  0004c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 980  :     stack->top	    = NULL;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00054	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 981  : 
; 982  :     if	(stack->vector == (pANTLR3_VECTOR)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM))

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00061	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00065	75 07		 jne	 SHORT $LN3@antlr3Stac

; 983  :     {
; 984  : 	return	(pANTLR3_STACK)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	eb 65		 jmp	 SHORT $LN1@antlr3Stac
$LN3@antlr3Stac:

; 985  :     }
; 986  : 
; 987  :     /* Looks good, now add the interface
; 988  :      */
; 989  :     stack->get	=  antlr3StackGet;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackGet
  0007a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 990  :     stack->free	=  antlr3StackFree;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackFree
  0008a	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 991  :     stack->pop	=  antlr3StackPop;

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPop
  0009a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 992  :     stack->push	=  antlr3StackPush;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPush
  000aa	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 993  :     stack->size	=  antlr3StackSize;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackSize
  000ba	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 994  :     stack->peek	=  antlr3StackPeek;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPeek
  000ca	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 995  : 
; 996  :     return  stack;

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
$LN1@antlr3Stac:

; 997  : }

  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
antlr3StackNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorNew
_TEXT	SEGMENT
vector$ = 32
sizeHint$ = 64
antlr3VectorNew PROC					; COMDAT

; 1055 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 1056 : 	pANTLR3_VECTOR  vector;
; 1057 : 
; 1058 : 
; 1059 : 	// Allocate memory for the vector structure itself
; 1060 : 	//
; 1061 : 	vector  = (pANTLR3_VECTOR) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR)));

  0001c	b9 60 01 00 00	 mov	 ecx, 352		; 00000160H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1062 : 
; 1063 : 	if	(vector == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR vector$[rsp], 0
  00032	75 07		 jne	 SHORT $LN2@antlr3Vect

; 1064 : 	{
; 1065 : 		return	(pANTLR3_VECTOR)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	eb 13		 jmp	 SHORT $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1066 : 	}
; 1067 : 
; 1068 : 	// Now fill in the defaults
; 1069 : 	//
; 1070 :     antlr3SetVectorApi(vector, sizeHint);

  0003b	8b 54 24 40	 mov	 edx, DWORD PTR sizeHint$[rsp]
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  00044	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1071 : 
; 1072 : 	// And everything is hunky dory
; 1073 : 	//
; 1074 : 	return  vector;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
$LN1@antlr3Vect:

; 1075 : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
antlr3VectorNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorFactoryNew
_TEXT	SEGMENT
factory$ = 32
sizeHint$ = 64
antlr3VectorFactoryNew PROC				; COMDAT

; 1436 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 1437 : 	pANTLR3_VECTOR_FACTORY  factory;
; 1438 : 
; 1439 : 	// Allocate memory for the factory
; 1440 : 	//
; 1441 : 	factory = (pANTLR3_VECTOR_FACTORY)ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR_FACTORY)));

  0001c	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 1442 : 
; 1443 : 	if	(factory == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00032	75 07		 jne	 SHORT $LN2@antlr3Vect

; 1444 : 	{
; 1445 : 		return	NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 98 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1446 : 	}
; 1447 : 
; 1448 : 	// Factory memory is good, so create a new vector pool
; 1449 : 	//
; 1450 :     factory->pools      = NULL;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00040	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1451 :     factory->thisPool   = -1;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0004c	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 1452 : 
; 1453 :     newPool(factory);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00058	e8 00 00 00 00	 call	 newPool

; 1454 : 
; 1455 :     // Initialize the API, ignore the hint as this algorithm does
; 1456 :     // a better job really.
; 1457 :     //
; 1458 :     antlr3SetVectorApi(&(factory->unTruc), ANTLR3_VECTOR_INTERNAL_SIZE);

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00062	48 83 c0 10	 add	 rax, 16
  00066	ba 10 00 00 00	 mov	 edx, 16
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1459 :     
; 1460 :     factory->unTruc.factoryMade = ANTLR3_TRUE;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00078	c6 80 20 01 00
	00 01		 mov	 BYTE PTR [rax+288], 1

; 1461 : 
; 1462 : 	// Install the factory API
; 1463 : 	//
; 1464 : 	factory->close			= closeVectorFactory;

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeVectorFactory
  0008b	48 89 88 78 01
	00 00		 mov	 QWORD PTR [rax+376], rcx

; 1465 : 	factory->newVector		= newVector;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newVector
  0009e	48 89 88 80 01
	00 00		 mov	 QWORD PTR [rax+384], rcx

; 1466 : 	factory->returnVector	= returnVector;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:returnVector
  000b1	48 89 88 88 01
	00 00		 mov	 QWORD PTR [rax+392], rcx

; 1467 : 
; 1468 : 	// Create a stack to accumulate reusable vectors
; 1469 : 	//
; 1470 : 	factory->freeStack		= antlr3StackNew(16);

  000b8	b9 10 00 00 00	 mov	 ecx, 16
  000bd	e8 00 00 00 00	 call	 antlr3StackNew
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000c7	48 89 81 70 01
	00 00		 mov	 QWORD PTR [rcx+368], rax

; 1471 : 	return  factory;

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Vect:

; 1472 : }

  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
antlr3VectorFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListNew
_TEXT	SEGMENT
list$ = 32
sizeHint$ = 64
antlr3ListNew PROC					; COMDAT

; 864  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 865  :     pANTLR3_LIST    list;
; 866  : 
; 867  :     /* Allocate memory
; 868  :      */
; 869  :     list    = (pANTLR3_LIST)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_LIST));

  0001c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax

; 870  : 
; 871  :     if	(list == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR list$[rsp], 0
  00032	75 0a		 jne	 SHORT $LN2@antlr3List

; 872  :     {
; 873  : 	return	(pANTLR3_LIST)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	e9 98 00 00 00	 jmp	 $LN1@antlr3List
$LN2@antlr3List:

; 874  :     }
; 875  : 
; 876  :     /* Now we need to add a new table
; 877  :      */
; 878  :     list->table	= antlr3HashTableNew(sizeHint);

  0003e	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  00042	e8 00 00 00 00	 call	 antlr3HashTableNew
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  0004c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 879  : 
; 880  :     if	(list->table == (pANTLR3_HASH_TABLE)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM))

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00054	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00058	75 07		 jne	 SHORT $LN3@antlr3List

; 881  :     {
; 882  : 	return	(pANTLR3_LIST)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	eb 75		 jmp	 SHORT $LN1@antlr3List
$LN3@antlr3List:

; 883  :     }
; 884  : 
; 885  :     /* Allocation was good, install interface
; 886  :      */
; 887  :     list->free	    =  antlr3ListFree;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListFree
  0006d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 888  :     list->del	    =  antlr3ListDelete;

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListDelete
  0007d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 889  :     list->get	    =  antlr3ListGet;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListGet
  0008d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 890  :     list->add	    =  antlr3ListAdd;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListAdd
  0009d	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 891  :     list->remove    =  antlr3ListRemove;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListRemove
  000ad	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 892  :     list->put	    =  antlr3ListPut;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListPut
  000bd	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 893  :     list->size	    =  antlr3ListSize;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListSize
  000cd	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 894  : 
; 895  :     return  list;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
$LN1@antlr3List:

; 896  : }

  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
antlr3ListNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNew
_TEXT	SEGMENT
en$ = 32
table$ = 64
antlr3EnumNew PROC					; COMDAT

; 674  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 675  :     pANTLR3_HASH_ENUM	en;
; 676  : 
; 677  :     /* Allocate structure memory
; 678  :      */
; 679  :     en    = (pANTLR3_HASH_ENUM) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENUM));

  0001e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 20	 mov	 QWORD PTR en$[rsp], rax

; 680  : 
; 681  :     /* Check that the allocation was good 
; 682  :      */
; 683  :     if	(en == NULL)

  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR en$[rsp], 0
  00034	75 07		 jne	 SHORT $LN2@antlr3Enum

; 684  :     {
; 685  : 	return	(pANTLR3_HASH_ENUM) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	eb 6c		 jmp	 SHORT $LN1@antlr3Enum
$LN2@antlr3Enum:

; 686  :     }
; 687  :     
; 688  :     /* Initialize the start pointers
; 689  :     */
; 690  :     en->table	= table;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx

; 691  :     en->bucket	= 0;				/* First bucket		    */

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0004f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 692  :     en->entry	= en->table->buckets->entries;	/* First entry to return    */

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0005b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00067	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 693  : 
; 694  :     /* Special case in that the first bucket may not have anything in it
; 695  :      * but the antlr3EnumNext() function expects that the en->entry is
; 696  :      * set to the next valid pointer. Hence if it is not a valid element
; 697  :      * pointer, attempt to find the next one that is, (table may be empty
; 698  :      * of course.
; 699  :      */
; 700  :     if	(en->entry == NULL)

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00073	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00078	75 0a		 jne	 SHORT $LN3@antlr3Enum

; 701  :     {
; 702  : 	antlr3EnumNextEntry(en);

  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  0007f	e8 00 00 00 00	 call	 antlr3EnumNextEntry
$LN3@antlr3Enum:

; 703  :     }
; 704  : 
; 705  :     /* Install the interface
; 706  :      */
; 707  :     en->free	=  antlr3EnumFree;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EnumFree
  00090	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 708  :     en->next	=  antlr3EnumNext;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EnumNext
  000a0	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 709  : 
; 710  :     /* All is good
; 711  :      */
; 712  :     return  en;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
$LN1@antlr3Enum:

; 713  : }

  000a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
antlr3EnumNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3Hash
_TEXT	SEGMENT
hash$ = 0
keyPtr$ = 8
i1$ = 16
key$ = 48
keylen$ = 56
antlr3Hash PROC						; COMDAT

; 835  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 836  :     /* Accumulate the hash value of the key
; 837  :      */
; 838  :     ANTLR3_UINT32   hash;
; 839  :     pANTLR3_UINT8   keyPtr;
; 840  :     ANTLR3_UINT32   i1;
; 841  : 
; 842  :     hash    = 0;

  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR hash$[rsp], 0

; 843  :     keyPtr  = (pANTLR3_UINT8) key;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  0002e	48 89 44 24 08	 mov	 QWORD PTR keyPtr$[rsp], rax
$LN2@antlr3Hash:

; 844  : 
; 845  :     /* Iterate the key and accumulate the hash
; 846  :      */
; 847  :     while(keylen > 0)

  00033	83 7c 24 38 00	 cmp	 DWORD PTR keylen$[rsp], 0
  00038	76 5e		 jbe	 SHORT $LN3@antlr3Hash

; 848  :     {
; 849  : 	hash = (hash << 4) + (*(keyPtr++));

  0003a	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  0003d	c1 e0 04	 shl	 eax, 4
  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR keyPtr$[rsp]
  00045	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00048	03 c1		 add	 eax, ecx
  0004a	89 04 24	 mov	 DWORD PTR hash$[rsp], eax
  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR keyPtr$[rsp]
  00052	48 ff c0	 inc	 rax
  00055	48 89 44 24 08	 mov	 QWORD PTR keyPtr$[rsp], rax

; 850  : 
; 851  : 	if ((i1=hash&0xf0000000) != 0)

  0005a	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  0005d	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00062	89 44 24 10	 mov	 DWORD PTR i1$[rsp], eax
  00066	83 7c 24 10 00	 cmp	 DWORD PTR i1$[rsp], 0
  0006b	74 1f		 je	 SHORT $LN4@antlr3Hash

; 852  : 	{
; 853  : 		hash = hash ^ (i1 >> 24);

  0006d	8b 44 24 10	 mov	 eax, DWORD PTR i1$[rsp]
  00071	c1 e8 18	 shr	 eax, 24
  00074	8b 0c 24	 mov	 ecx, DWORD PTR hash$[rsp]
  00077	33 c8		 xor	 ecx, eax
  00079	8b c1		 mov	 eax, ecx
  0007b	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 854  : 		hash = hash ^ i1;

  0007e	8b 44 24 10	 mov	 eax, DWORD PTR i1$[rsp]
  00082	8b 0c 24	 mov	 ecx, DWORD PTR hash$[rsp]
  00085	33 c8		 xor	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	89 04 24	 mov	 DWORD PTR hash$[rsp], eax
$LN4@antlr3Hash:

; 855  : 	}
; 856  : 	keylen--;

  0008c	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00090	ff c8		 dec	 eax
  00092	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 857  :     }

  00096	eb 9b		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 858  : 
; 859  :     return  hash;

  00098	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]

; 860  : }

  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
antlr3Hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashTableNew
_TEXT	SEGMENT
table$ = 32
bucket$ = 40
sizeHint$ = 64
antlr3HashTableNew PROC					; COMDAT

; 127  : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 128  : 	// All we have to do is create the hashtable tracking structure
; 129  : 	// and allocate memory for the requested number of buckets.
; 130  : 	//
; 131  : 	pANTLR3_HASH_TABLE	table;
; 132  : 
; 133  : 	ANTLR3_UINT32	bucket;	// Used to traverse the buckets
; 134  : 
; 135  : 	table   = ANTLR3_MALLOC(sizeof(ANTLR3_HASH_TABLE));

  0001c	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR table$[rsp], rax

; 136  : 
; 137  : 	// Error out if no memory left
; 138  : 	if	(table	== NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR table$[rsp], 0
  00032	75 07		 jne	 SHORT $LN5@antlr3Hash

; 139  : 	{
; 140  : 		return	NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 3e 01 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:

; 141  : 	}
; 142  : 
; 143  : 	// Allocate memory for the buckets
; 144  : 	//
; 145  : 	table->buckets = (pANTLR3_HASH_BUCKET) ANTLR3_MALLOC((size_t) (sizeof(ANTLR3_HASH_BUCKET) * sizeHint)); 

  0003b	8b 44 24 40	 mov	 eax, DWORD PTR sizeHint$[rsp]
  0003f	48 c1 e0 03	 shl	 rax, 3
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  00051	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 146  : 
; 147  : 	if	(table->buckets == NULL)

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  0005a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0005f	75 12		 jne	 SHORT $LN6@antlr3Hash

; 148  : 	{
; 149  : 		ANTLR3_FREE((void *)table);

  00061	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 150  : 		return	NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 06 01 00 00	 jmp	 $LN1@antlr3Hash
$LN6@antlr3Hash:

; 151  : 	}
; 152  : 
; 153  : 	// Modulo of the table, (bucket count).
; 154  : 	//
; 155  : 	table->modulo   = sizeHint;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00078	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  0007c	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 156  : 
; 157  : 	table->count    = 0;	    /* Nothing in there yet ( I hope)	*/

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00084	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 158  : 
; 159  : 	/* Initialize the buckets to empty
; 160  : 	*/
; 161  : 	for	(bucket = 0; bucket < sizeHint; bucket++)

  0008b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR bucket$[rsp], 0
  00093	eb 0a		 jmp	 SHORT $LN4@antlr3Hash
$LN2@antlr3Hash:
  00095	8b 44 24 28	 mov	 eax, DWORD PTR bucket$[rsp]
  00099	ff c0		 inc	 eax
  0009b	89 44 24 28	 mov	 DWORD PTR bucket$[rsp], eax
$LN4@antlr3Hash:
  0009f	8b 44 24 40	 mov	 eax, DWORD PTR sizeHint$[rsp]
  000a3	39 44 24 28	 cmp	 DWORD PTR bucket$[rsp], eax
  000a7	73 17		 jae	 SHORT $LN3@antlr3Hash

; 162  : 	{
; 163  : 		table->buckets[bucket].entries = NULL;

  000a9	8b 44 24 28	 mov	 eax, DWORD PTR bucket$[rsp]
  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  000b2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b6	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 164  : 	}

  000be	eb d5		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 165  : 
; 166  : 	/* Exclude duplicate entries by default
; 167  : 	*/
; 168  : 	table->allowDups	= ANTLR3_FALSE;

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000c5	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 169  : 
; 170  :     /* Assume that keys should by strduped before they are
; 171  :      * entered in the table.
; 172  :      */
; 173  :     table->doStrdup     = ANTLR3_TRUE;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000d0	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 174  : 
; 175  : 	/* Install the interface
; 176  : 	*/
; 177  : 
; 178  : 	table->get		=  antlr3HashGet;

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashGet
  000e0	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 179  : 	table->put		=  antlr3HashPut;

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashPut
  000f0	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 180  : 	table->del		=  antlr3HashDelete;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashDelete
  00100	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 181  : 	table->remove	=  antlr3HashRemove;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashRemove
  00110	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 182  : 
; 183  : 	table->getI		=  antlr3HashGetI;

  00114	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashGetI
  00120	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 184  : 	table->putI		=  antlr3HashPutI;

  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashPutI
  00130	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 185  : 	table->delI		=  antlr3HashDeleteI;

  00134	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashDeleteI
  00140	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 186  : 	table->removeI	=  antlr3HashRemoveI;

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashRemoveI
  00150	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 187  : 
; 188  : 	table->size		=  antlr3HashSize;

  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashSize
  00160	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 189  : 	table->free		=  antlr3HashFree;

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashFree
  00170	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 190  : 
; 191  : 	return  table;

  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
$LN1@antlr3Hash:

; 192  : }

  00179	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017d	5f		 pop	 rdi
  0017e	c3		 ret	 0
antlr3HashTableNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3IntTrieNew
_TEXT	SEGMENT
trie$ = 32
depth$ = 64
antlr3IntTrieNew PROC					; COMDAT

; 1769 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 1770 : 	pANTLR3_INT_TRIE	trie;
; 1771 : 
; 1772 : 	trie    = (pANTLR3_INT_TRIE) ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE));	/* Base memory required	*/

  0001c	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002c	48 89 44 24 20	 mov	 QWORD PTR trie$[rsp], rax

; 1773 : 
; 1774 : 	if (trie == NULL)

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR trie$[rsp], 0
  00037	75 0a		 jne	 SHORT $LN2@antlr3IntT

; 1775 : 	{
; 1776 : 		return	(pANTLR3_INT_TRIE) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	e9 bf 00 00 00	 jmp	 $LN1@antlr3IntT
$LN2@antlr3IntT:

; 1777 : 	}
; 1778 : 
; 1779 : 	/* Now we need to allocate the root node. This makes it easier
; 1780 : 	 * to use the tree as we don't have to do anything special 
; 1781 : 	 * for the root node.
; 1782 : 	 */
; 1783 : 	trie->root	= (pANTLR3_INT_TRIE_NODE) ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE));

  00043	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  00048	b9 01 00 00 00	 mov	 ecx, 1
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  00058	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1784 : 
; 1785 : 	if (trie->root == NULL)

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	75 15		 jne	 SHORT $LN3@antlr3IntT

; 1786 : 	{
; 1787 : 		ANTLR3_FREE(trie);

  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1788 : 		return	(pANTLR3_INT_TRIE) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	e9 87 00 00 00	 jmp	 $LN1@antlr3IntT
$LN3@antlr3IntT:

; 1789 : 	}
; 1790 : 
; 1791 : 	trie->add	= intTrieAdd;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieAdd
  00087	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1792 : 	trie->del	= intTrieDel;

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieDel
  00097	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1793 : 	trie->free	= intTrieFree;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieFree
  000a7	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1794 : 	trie->get	= intTrieGet;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieGet
  000b7	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1795 : 
; 1796 : 	/* Now we seed the root node with the index being the
; 1797 : 	 * highest left most bit we want to test, which limits the
; 1798 : 	 * keys in the trie. This is the trie 'depth'. The limit for
; 1799 : 	 * this implementation is 63 (bits 0..63).
; 1800 : 	 */
; 1801 : 	trie->root->bitNum = depth;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	8b 4c 24 40	 mov	 ecx, DWORD PTR depth$[rsp]
  000c7	89 08		 mov	 DWORD PTR [rax], ecx

; 1802 : 
; 1803 : 	/* And as we have nothing in here yet, we set both child pointers
; 1804 : 	 * of the root node to point back to itself.
; 1805 : 	 */
; 1806 : 	trie->root->leftN	= trie->root;

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  000d6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1807 : 	trie->root->rightN	= trie->root;

  000dd	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  000ea	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ed	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1808 : 	trie->count			= 0;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000f6	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 1809 : 
; 1810 : 	/* Finally, note that the key for this root node is 0 because
; 1811 : 	 * we use calloc() to initialise it.
; 1812 : 	 */
; 1813 : 
; 1814 : 	return trie;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
$LN1@antlr3IntT:

; 1815 : }

  00102	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
antlr3IntTrieNew ENDP
_TEXT	ENDS
END
