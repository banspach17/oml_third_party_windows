; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3BaseTreeAdaptorInit
PUBLIC	??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC?$AA@	; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_03EKALBCDP@?$CC?$FN?6?$AA@		; `string'
PUBLIC	??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5?$AA@ ; `string'
PUBLIC	??_C@_04BBDFLMDN@?5?9?$DO?5?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7ranks@ ; `string'
PUBLIC	??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_02JHLIKEIA@?6?$HN?$AA@			; `string'
PUBLIC	??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TODO@ ; `string'
PUBLIC	??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of?5@ ; `string'
PUBLIC	??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of?5@ ; `string'
PUBLIC	??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of?5@ ; `string'
PUBLIC	??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of?5@ ; `string'
PUBLIC	??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of?5@ ; `string'
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseTreeAdaptorInit DD imagerel $LN5
	DD	imagerel $LN5+569
	DD	imagerel $unwind$antlr3BaseTreeAdaptorInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nilNode DD imagerel nilNode
	DD	imagerel nilNode+54
	DD	imagerel $unwind$nilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgNil DD imagerel dbgNil
	DD	imagerel dbgNil+93
	DD	imagerel $unwind$dbgNil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTree DD imagerel dupTree
	DD	imagerel dupTree+62
	DD	imagerel $unwind$dupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgDupTree DD imagerel dbgDupTree
	DD	imagerel dbgDupTree+87
	DD	imagerel $unwind$dbgDupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTreeTT DD imagerel dupTreeTT
	DD	imagerel dupTreeTT+286
	DD	imagerel $unwind$dupTreeTT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+80
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgAddChild DD imagerel dbgAddChild
	DD	imagerel dbgAddChild+114
	DD	imagerel $unwind$dbgAddChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRoot DD imagerel becomeRoot
	DD	imagerel becomeRoot+267
	DD	imagerel $unwind$becomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgBecomeRoot DD imagerel dbgBecomeRoot
	DD	imagerel dbgBecomeRoot+110
	DD	imagerel $unwind$dbgBecomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rulePostProcessing DD imagerel rulePostProcessing
	DD	imagerel rulePostProcessing+215
	DD	imagerel $unwind$rulePostProcessing
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChildToken DD imagerel addChildToken
	DD	imagerel addChildToken+104
	DD	imagerel $unwind$addChildToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgAddChildToken DD imagerel dbgAddChildToken
	DD	imagerel dbgAddChildToken+145
	DD	imagerel $unwind$dbgAddChildToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRootToken DD imagerel becomeRootToken
	DD	imagerel becomeRootToken+88
	DD	imagerel $unwind$becomeRootToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgBecomeRootToken DD imagerel dbgBecomeRootToken
	DD	imagerel dbgBecomeRootToken+132
	DD	imagerel $unwind$dbgBecomeRootToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeToken DD imagerel createTypeToken
	DD	imagerel createTypeToken+112
	DD	imagerel $unwind$createTypeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeToken DD imagerel dbgCreateTypeToken
	DD	imagerel dbgCreateTypeToken+103
	DD	imagerel $unwind$dbgCreateTypeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeTokenText DD imagerel createTypeTokenText
	DD	imagerel createTypeTokenText+138
	DD	imagerel $unwind$createTypeTokenText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeTokenText DD imagerel dbgCreateTypeTokenText
	DD	imagerel dbgCreateTypeTokenText+113
	DD	imagerel $unwind$dbgCreateTypeTokenText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeText DD imagerel createTypeText
	DD	imagerel createTypeText+96
	DD	imagerel $unwind$createTypeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeText DD imagerel dbgCreateTypeText
	DD	imagerel dbgCreateTypeText+103
	DD	imagerel $unwind$dbgCreateTypeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+15
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setType DD imagerel setType
	DD	imagerel setType+72
	DD	imagerel $unwind$setType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+69
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText DD imagerel setText
	DD	imagerel setText+67
	DD	imagerel $unwind$setText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText8 DD imagerel setText8
	DD	imagerel setText8+67
	DD	imagerel $unwind$setText8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+74
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+69
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getUniqueID DD imagerel getUniqueID
	DD	imagerel getUniqueID+17
	DD	imagerel $unwind$getUniqueID
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isNilNode DD imagerel isNilNode
	DD	imagerel isNilNode+57
	DD	imagerel $unwind$isNilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$makeDot DD imagerel makeDot
	DD	imagerel makeDot+619
	DD	imagerel $unwind$makeDot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defineDotNodes DD imagerel defineDotNodes
	DD	imagerel defineDotNodes+622
	DD	imagerel $unwind$defineDotNodes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defineDotEdges DD imagerel defineDotEdges
	DD	imagerel defineDotEdges+970
	DD	imagerel $unwind$defineDotEdges
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$simulateTreeConstruction DD imagerel simulateTreeConstruction
	DD	imagerel simulateTreeConstruction+207
	DD	imagerel $unwind$simulateTreeConstruction
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of?5@
CONST	SEGMENT
??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of?5@ DB 'Internal e'
	DB	'rror - implementor of superclass containing ANTLR3_TREE_ADAPT'
	DB	'OR did not implement getChildCount()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of?5@
CONST	SEGMENT
??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of?5@ DB 'Internal e'
	DB	'rror - implementor of superclass containing ANTLR3_TREE_ADAPT'
	DB	'OR did not implement getChild()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of?5@
CONST	SEGMENT
??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of?5@ DB 'Internal e'
	DB	'rror - implementor of superclass containing ANTLR3_TREE_ADAPT'
	DB	'OR did not implement setText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of?5@
CONST	SEGMENT
??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of?5@ DB 'Internal e'
	DB	'rror - implementor of superclass containing ANTLR3_TREE_ADAPT'
	DB	'OR did not implement getText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of?5@
CONST	SEGMENT
??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of?5@ DB 'Internal e'
	DB	'rror - implementor of superclass containing ANTLR3_TREE_ADAPT'
	DB	'OR did not implement setType()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TODO@
CONST	SEGMENT
??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TODO@ DB 'More th'
	DB	'an one node as root! TODO: Create tree exception handling', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHLIKEIA@?6?$HN?$AA@
CONST	SEGMENT
??_C@_02JHLIKEIA@?6?$HN?$AA@ DB 0aH, '}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6?$AA@ DB 'n0[la'
	DB	'bel="EMPTY TREE"]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7ranks@
CONST	SEGMENT
??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7ranks@ DB 'd'
	DB	'igraph {', 0aH, 0aH, 09H, 'ordering=out;', 0aH, 09H, 'ranksep'
	DB	'=.4;', 0aH, 09H, 'bgcolor="lightgrey";  node [shape=box, fixe'
	DB	'dsize=false, fontsize=12, fontname="Helvetica-bold", fontcolo'
	DB	'r="blue"', 0aH, 09H, 'width=.25, height=.25, color="black", f'
	DB	'illcolor="white", style="filled, solid, bold"];', 0aH, 0aH, 09H
	DB	'edge [arrowsize=.5, color="black", style="bold"]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BBDFLMDN@?5?9?$DO?5?$AA@
CONST	SEGMENT
??_C@_04BBDFLMDN@?5?9?$DO?5?$AA@ DB ' -> ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5?$AA@
CONST	SEGMENT
??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5?$AA@ DB 09H, 09H, 'n'
	DB	'%p -> n%p', 09H, 09H, '// ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EKALBCDP@?$CC?$FN?6?$AA@
CONST	SEGMENT
??_C@_03EKALBCDP@?$CC?$FN?6?$AA@ DB '"]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC?$AA@ DB 09H, 'n%p[label="', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$simulateTreeConstruction DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defineDotEdges DD 034019H
	DD	01e0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
defineDotEdges$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
defineDotEdges$rtcVarDesc DD 040H
	DD	080H
	DQ	FLAT:defineDotEdges$rtcName$0
	ORG $+48
defineDotEdges$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:defineDotEdges$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defineDotNodes DD 034019H
	DD	0160117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
defineDotNodes$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
defineDotNodes$rtcVarDesc DD 040H
	DD	040H
	DQ	FLAT:defineDotNodes$rtcName$0
	ORG $+48
defineDotNodes$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:defineDotNodes$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$makeDot DD 033b19H
	DD	0160112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
makeDot$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
makeDot$rtcVarDesc DD 040H
	DD	040H
	DQ	FLAT:makeDot$rtcName$0
	ORG $+48
makeDot$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:makeDot$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isNilNode DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getUniqueID DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText8 DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setType DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeText DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeText DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeTokenText DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeTokenText DD 022c01H
	DD	070143218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeToken DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeToken DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgBecomeRootToken DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRootToken DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgAddChildToken DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChildToken DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rulePostProcessing DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgBecomeRoot DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRoot DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgAddChild DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTreeTT DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgDupTree DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTree DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgNil DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nilNode DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseTreeAdaptorInit DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT simulateTreeConstruction
_TEXT	SEGMENT
n$ = 32
i$ = 36
child$ = 40
adaptor$ = 64
tree$ = 72
simulateTreeConstruction PROC				; COMDAT

; 501  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 502  : 	ANTLR3_UINT32		n;
; 503  : 	ANTLR3_UINT32		i;
; 504  : 	pANTLR3_BASE_TREE	child;
; 505  : 
; 506  : 	// Send the create node event
; 507  : 	//
; 508  : 	adaptor->debugger->createNode(adaptor->debugger, tree);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003a	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 509  : 
; 510  : 	n = adaptor->getChildCount(adaptor, tree);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004f	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  00055	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 511  : 	for	(i = 0; i < n; i++)

  00059	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00061	eb 0a		 jmp	 SHORT $LN4@simulateTr
$LN2@simulateTr:
  00063	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00067	ff c0		 inc	 eax
  00069	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@simulateTr:
  0006d	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00071	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00075	73 52		 jae	 SHORT $LN3@simulateTr

; 512  : 	{
; 513  : 		child = adaptor->getChild(adaptor, tree, i);

  00077	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  0007c	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0008b	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00091	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 514  : 		simulateTreeConstruction(adaptor, child);

  00096	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000a0	e8 00 00 00 00	 call	 simulateTreeConstruction

; 515  : 		adaptor->debugger->addChild(adaptor->debugger, tree, child);

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  000aa	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ae	4c 8b 44 24 28	 mov	 r8, QWORD PTR child$[rsp]
  000b3	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000bd	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000c1	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]

; 516  : 	}

  000c7	eb 9a		 jmp	 SHORT $LN2@simulateTr
$LN3@simulateTr:

; 517  : }

  000c9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
simulateTreeConstruction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT defineDotEdges
_TEXT	SEGMENT
nCount$ = 32
i$ = 36
child$4 = 40
buff$5 = 64
text$6 = 200
j$7 = 208
tv95 = 224
tv161 = 228
__$ArrayPad$ = 232
adaptor$ = 256
t$ = 264
dotSpec$ = 272
defineDotEdges PROC					; COMDAT

; 241  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR [rsp+256]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 242  : 	// How many nodes are we talking about?
; 243  : 	//
; 244  : 	int	nCount;
; 245  : 	int i;
; 246  : 
; 247  : 	if	(t == NULL)

  00040	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR t$[rsp], 0
  00049	75 05		 jne	 SHORT $LN15@defineDotE

; 248  : 	{
; 249  : 		// No tree, so do nothing
; 250  : 		//
; 251  : 		return;

  0004b	e9 52 03 00 00	 jmp	 $LN1@defineDotE
$LN15@defineDotE:

; 252  : 	}
; 253  : 
; 254  : 	// Count the nodes
; 255  : 	//
; 256  : 	nCount = adaptor->getChildCount(adaptor, t);

  00050	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00058	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00060	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00068	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  0006e	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 257  : 
; 258  : 	if	(nCount == 0)

  00072	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00077	75 05		 jne	 SHORT $LN16@defineDotE

; 259  : 	{
; 260  : 		// This will already have been included as a child of another node
; 261  : 		// so there is nothing to add.
; 262  : 		//
; 263  : 		return;

  00079	e9 24 03 00 00	 jmp	 $LN1@defineDotE
$LN16@defineDotE:

; 264  : 	}
; 265  : 
; 266  : 	// For each child, define an edge from this parent, then process
; 267  : 	// and children of this child in the same way
; 268  : 	//
; 269  : 	for	(i=0; i<nCount; i++)

  0007e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00086	eb 0a		 jmp	 SHORT $LN4@defineDotE
$LN2@defineDotE:
  00088	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@defineDotE:
  00092	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  00096	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0009a	0f 8d 02 03 00
	00		 jge	 $LN3@defineDotE

; 270  : 	{
; 271  : 		pANTLR3_BASE_TREE child;
; 272  : 		char	buff[128];
; 273  :         pANTLR3_STRING text;
; 274  :         int                 j;
; 275  : 
; 276  : 		// Next child
; 277  : 		//
; 278  : 		child	= adaptor->getChild(adaptor, t, i);

  000a0	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  000a5	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  000ad	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000b5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000bd	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000c3	48 89 44 24 28	 mov	 QWORD PTR child$4[rsp], rax

; 279  : 
; 280  : 		// Create the edge relation
; 281  : 		//
; 282  : 		sprintf(buff, "\t\tn%p -> n%p\t\t// ",  t, child);

  000c8	4c 8b 4c 24 28	 mov	 r9, QWORD PTR child$4[rsp]
  000cd	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR t$[rsp]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5?$AA@
  000dc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$5[rsp]
  000e1	e8 00 00 00 00	 call	 sprintf

; 283  :         
; 284  : 		dotSpec->append8(dotSpec, buff);

  000e6	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$5[rsp]
  000eb	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000f3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000fb	ff 50 38	 call	 QWORD PTR [rax+56]

; 285  : 
; 286  : 		// Document the relationship
; 287  : 		//
; 288  :         text = adaptor->getText(adaptor, t);

  000fe	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00106	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0010e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00116	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0011c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR text$6[rsp], rax

; 289  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  00124	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$7[rsp], 0
  0012f	eb 10		 jmp	 SHORT $LN7@defineDotE
$LN5@defineDotE:
  00131	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR j$7[rsp]
  00138	ff c0		 inc	 eax
  0013a	89 84 24 d0 00
	00 00		 mov	 DWORD PTR j$7[rsp], eax
$LN7@defineDotE:
  00141	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00149	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0014c	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR j$7[rsp], eax
  00153	0f 8d cf 00 00
	00		 jge	 $LN6@defineDotE

; 290  :         {
; 291  :                 switch(text->charAt(text, j))

  00159	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  00160	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  00168	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00170	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00176	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv95[rsp], eax
  0017d	83 bc 24 e0 00
	00 00 0a	 cmp	 DWORD PTR tv95[rsp], 10
  00185	74 32		 je	 SHORT $LN18@defineDotE
  00187	83 bc 24 e0 00
	00 00 0d	 cmp	 DWORD PTR tv95[rsp], 13
  0018f	74 44		 je	 SHORT $LN19@defineDotE
  00191	83 bc 24 e0 00
	00 00 22	 cmp	 DWORD PTR tv95[rsp], 34	; 00000022H
  00199	74 02		 je	 SHORT $LN17@defineDotE
  0019b	eb 54		 jmp	 SHORT $LN20@defineDotE
$LN17@defineDotE:

; 292  :                 {
; 293  :                     case '"':
; 294  : 
; 295  :                         dotSpec->append8(dotSpec, "\\\"");

  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
  001a4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001ac	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001b4	ff 50 38	 call	 QWORD PTR [rax+56]

; 296  :                         break;

  001b7	eb 6a		 jmp	 SHORT $LN8@defineDotE
$LN18@defineDotE:

; 297  : 
; 298  :                     case '\n':
; 299  : 
; 300  :                         dotSpec->append8(dotSpec, "\\n");

  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
  001c0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001c8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001d0	ff 50 38	 call	 QWORD PTR [rax+56]

; 301  :                         break;

  001d3	eb 4e		 jmp	 SHORT $LN8@defineDotE
$LN19@defineDotE:

; 302  : 
; 303  :                     case '\r':
; 304  : 
; 305  :                         dotSpec->append8(dotSpec, "\\r");

  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
  001dc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001e4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001ec	ff 50 38	 call	 QWORD PTR [rax+56]

; 306  :                         break;

  001ef	eb 32		 jmp	 SHORT $LN8@defineDotE
$LN20@defineDotE:

; 307  : 
; 308  :                     default:
; 309  : 
; 310  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  001f1	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  001f8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  00200	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00208	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0020e	8b d0		 mov	 edx, eax
  00210	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00218	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00220	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@defineDotE:

; 311  :                         break;
; 312  :                 }
; 313  :         }

  00223	e9 09 ff ff ff	 jmp	 $LN5@defineDotE
$LN6@defineDotE:

; 314  : 
; 315  :         dotSpec->append8(dotSpec, " -> ");

  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BBDFLMDN@?5?9?$DO?5?$AA@
  0022f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00237	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0023f	ff 50 38	 call	 QWORD PTR [rax+56]

; 316  : 
; 317  :         text = adaptor->getText(adaptor, child);

  00242	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$4[rsp]
  00247	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0024f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00257	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0025d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR text$6[rsp], rax

; 318  :         for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  00265	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$7[rsp], 0
  00270	eb 10		 jmp	 SHORT $LN12@defineDotE
$LN10@defineDotE:
  00272	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR j$7[rsp]
  00279	ff c0		 inc	 eax
  0027b	89 84 24 d0 00
	00 00		 mov	 DWORD PTR j$7[rsp], eax
$LN12@defineDotE:
  00282	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  0028a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0028d	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR j$7[rsp], eax
  00294	0f 8d cf 00 00
	00		 jge	 $LN11@defineDotE

; 319  :         {
; 320  :                 switch(text->charAt(text, j))

  0029a	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  002a1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  002a9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  002b1	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  002b7	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  002be	83 bc 24 e4 00
	00 00 0a	 cmp	 DWORD PTR tv161[rsp], 10
  002c6	74 32		 je	 SHORT $LN22@defineDotE
  002c8	83 bc 24 e4 00
	00 00 0d	 cmp	 DWORD PTR tv161[rsp], 13
  002d0	74 44		 je	 SHORT $LN23@defineDotE
  002d2	83 bc 24 e4 00
	00 00 22	 cmp	 DWORD PTR tv161[rsp], 34 ; 00000022H
  002da	74 02		 je	 SHORT $LN21@defineDotE
  002dc	eb 54		 jmp	 SHORT $LN24@defineDotE
$LN21@defineDotE:

; 321  :                 {
; 322  :                     case '"':
; 323  : 
; 324  :                         dotSpec->append8(dotSpec, "\\\"");

  002de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
  002e5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  002ed	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  002f5	ff 50 38	 call	 QWORD PTR [rax+56]

; 325  :                         break;

  002f8	eb 6a		 jmp	 SHORT $LN13@defineDotE
$LN22@defineDotE:

; 326  : 
; 327  :                     case '\n':
; 328  : 
; 329  :                         dotSpec->append8(dotSpec, "\\n");

  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
  00301	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00309	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00311	ff 50 38	 call	 QWORD PTR [rax+56]

; 330  :                         break;

  00314	eb 4e		 jmp	 SHORT $LN13@defineDotE
$LN23@defineDotE:

; 331  : 
; 332  :                     case '\r':
; 333  : 
; 334  :                         dotSpec->append8(dotSpec, "\\r");

  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
  0031d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00325	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0032d	ff 50 38	 call	 QWORD PTR [rax+56]

; 335  :                         break;

  00330	eb 32		 jmp	 SHORT $LN13@defineDotE
$LN24@defineDotE:

; 336  : 
; 337  :                     default:
; 338  : 
; 339  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  00332	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  00339	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  00341	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00349	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0034f	8b d0		 mov	 edx, eax
  00351	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00359	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00361	ff 50 70	 call	 QWORD PTR [rax+112]
$LN13@defineDotE:

; 340  :                         break;
; 341  :                 }
; 342  :         }

  00364	e9 09 ff ff ff	 jmp	 $LN10@defineDotE
$LN11@defineDotE:

; 343  : 		dotSpec->append8(dotSpec, "\n");

  00369	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00370	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00378	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00380	ff 50 38	 call	 QWORD PTR [rax+56]

; 344  : 
; 345  :         
; 346  : 		// Define edges for this child
; 347  : 		//
; 348  : 		defineDotEdges(adaptor, child, dotSpec);

  00383	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR dotSpec$[rsp]
  0038b	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$4[rsp]
  00390	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00398	e8 00 00 00 00	 call	 defineDotEdges

; 349  : 	}

  0039d	e9 e6 fc ff ff	 jmp	 $LN2@defineDotE
$LN3@defineDotE:
$LN1@defineDotE:

; 350  : 
; 351  : 	// Done
; 352  : 	//
; 353  : 	return;
; 354  : }

  003a2	48 8b cc	 mov	 rcx, rsp
  003a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:defineDotEdges$rtcFrameData
  003ac	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b9	48 33 cc	 xor	 rcx, rsp
  003bc	e8 00 00 00 00	 call	 __security_check_cookie
  003c1	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  003c8	5f		 pop	 rdi
  003c9	c3		 ret	 0
defineDotEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT defineDotNodes
_TEXT	SEGMENT
nCount$ = 32
i$ = 36
child$ = 40
buff$ = 64
text$ = 136
j$ = 144
tv93 = 160
__$ArrayPad$ = 168
adaptor$ = 192
t$ = 200
dotSpec$ = 208
defineDotNodes PROC					; COMDAT

; 161  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 162  : 	// How many nodes are we talking about?
; 163  : 	//
; 164  : 	int	nCount;
; 165  : 	int i;
; 166  :     pANTLR3_BASE_TREE child;
; 167  : 	char	buff[64];
; 168  : 	pANTLR3_STRING	text;
; 169  : 	int		j;
; 170  : 
; 171  : 
; 172  : 
; 173  : 
; 174  : 
; 175  : 	// Count the nodes
; 176  : 	//
; 177  : 	nCount = adaptor->getChildCount(adaptor, t);

  00040	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00048	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00050	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00058	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  0005e	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 178  : 
; 179  : 	if	(nCount == 0)

  00062	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00067	75 05		 jne	 SHORT $LN10@defineDotN

; 180  : 	{
; 181  : 		// This will already have been included as a child of another node
; 182  : 		// so there is nothing to add.
; 183  : 		//
; 184  : 		return;

  00069	e9 d8 01 00 00	 jmp	 $LN1@defineDotN
$LN10@defineDotN:

; 185  : 	}
; 186  : 
; 187  : 	// For each child of the current tree, define a node using the
; 188  : 	// memory address of the node to name it
; 189  : 	//
; 190  : 	for	(i = 0; i<nCount; i++)

  0006e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00076	eb 0a		 jmp	 SHORT $LN4@defineDotN
$LN2@defineDotN:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@defineDotN:
  00082	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  00086	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0008a	0f 8d b6 01 00
	00		 jge	 $LN3@defineDotN

; 191  : 	{
; 192  : 
; 193  : 		// Pick up a pointer for the child
; 194  : 		//
; 195  : 		child = adaptor->getChild(adaptor, t, i);

  00090	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  00095	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0009d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000a5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ad	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000b3	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 196  : 
; 197  : 		// Name the node
; 198  : 		//
; 199  : 		sprintf(buff, "\tn%p[label=\"", child);

  000b8	4c 8b 44 24 28	 mov	 r8, QWORD PTR child$[rsp]
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC?$AA@
  000c4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$[rsp]
  000c9	e8 00 00 00 00	 call	 sprintf

; 200  : 		dotSpec->append8(dotSpec, buff);

  000ce	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$[rsp]
  000d3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000db	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000e3	ff 50 38	 call	 QWORD PTR [rax+56]

; 201  : 		text = adaptor->getText(adaptor, child);

  000e6	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  000eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000f3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000fb	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00101	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR text$[rsp], rax

; 202  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  00109	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00114	eb 10		 jmp	 SHORT $LN7@defineDotN
$LN5@defineDotN:
  00116	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0011d	ff c0		 inc	 eax
  0011f	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN7@defineDotN:
  00126	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  0012e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00131	39 84 24 90 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00138	0f 8d cf 00 00
	00		 jge	 $LN6@defineDotN

; 203  : 		{
; 204  :             switch(text->charAt(text, j))

  0013e	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  00145	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  0014d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00155	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0015b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  00162	83 bc 24 a0 00
	00 00 0a	 cmp	 DWORD PTR tv93[rsp], 10
  0016a	74 32		 je	 SHORT $LN12@defineDotN
  0016c	83 bc 24 a0 00
	00 00 0d	 cmp	 DWORD PTR tv93[rsp], 13
  00174	74 44		 je	 SHORT $LN13@defineDotN
  00176	83 bc 24 a0 00
	00 00 22	 cmp	 DWORD PTR tv93[rsp], 34	; 00000022H
  0017e	74 02		 je	 SHORT $LN11@defineDotN
  00180	eb 54		 jmp	 SHORT $LN14@defineDotN
$LN11@defineDotN:

; 205  :             {
; 206  :                 case '"':
; 207  : 
; 208  :                     dotSpec->append8(dotSpec, "\\\"");

  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
  00189	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00191	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00199	ff 50 38	 call	 QWORD PTR [rax+56]

; 209  :                     break;

  0019c	eb 6a		 jmp	 SHORT $LN8@defineDotN
$LN12@defineDotN:

; 210  : 
; 211  :                 case '\n':
; 212  : 
; 213  :                     dotSpec->append8(dotSpec, "\\n");

  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
  001a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001ad	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001b5	ff 50 38	 call	 QWORD PTR [rax+56]

; 214  :                     break;

  001b8	eb 4e		 jmp	 SHORT $LN8@defineDotN
$LN13@defineDotN:

; 215  : 
; 216  :                 case '\r':
; 217  : 
; 218  :                     dotSpec->append8(dotSpec, "\\r");

  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
  001c1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001c9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001d1	ff 50 38	 call	 QWORD PTR [rax+56]

; 219  :                     break;

  001d4	eb 32		 jmp	 SHORT $LN8@defineDotN
$LN14@defineDotN:

; 220  : 
; 221  :                 default:
; 222  : 
; 223  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  001d6	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  001dd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  001e5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  001ed	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  001f3	8b d0		 mov	 edx, eax
  001f5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001fd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00205	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@defineDotN:

; 224  :                     break;
; 225  :             }
; 226  : 		}

  00208	e9 09 ff ff ff	 jmp	 $LN5@defineDotN
$LN6@defineDotN:

; 227  : 		dotSpec->append8(dotSpec, "\"]\n");

  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EKALBCDP@?$CC?$FN?6?$AA@
  00214	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0021c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00224	ff 50 38	 call	 QWORD PTR [rax+56]

; 228  : 
; 229  : 		// And now define the children of this child (if any)
; 230  : 		//
; 231  : 		defineDotNodes(adaptor, child, dotSpec);

  00227	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR dotSpec$[rsp]
  0022f	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  00234	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0023c	e8 00 00 00 00	 call	 defineDotNodes

; 232  : 	}

  00241	e9 32 fe ff ff	 jmp	 $LN2@defineDotN
$LN3@defineDotN:
$LN1@defineDotN:

; 233  : 	
; 234  : 	// Done
; 235  : 	//
; 236  : 	return;
; 237  : }

  00246	48 8b cc	 mov	 rcx, rsp
  00249	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:defineDotNodes$rtcFrameData
  00250	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00255	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0025d	48 33 cc	 xor	 rcx, rsp
  00260	e8 00 00 00 00	 call	 __security_check_cookie
  00265	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  0026c	5f		 pop	 rdi
  0026d	c3		 ret	 0
defineDotNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT makeDot
_TEXT	SEGMENT
dotSpec$ = 32
buff$ = 64
text$ = 136
j$ = 144
tv91 = 160
__$ArrayPad$ = 168
adaptor$ = 192
theTree$ = 200
makeDot	PROC						; COMDAT

; 360  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 361  : 	// The string we are building up
; 362  : 	//
; 363  : 	pANTLR3_STRING		dotSpec;
; 364  : 	char                buff[64];
; 365  : 	pANTLR3_STRING      text;
; 366  : 	int                 j;
; 367  : 
; 368  : 	dotSpec = adaptor->strFactory->newStr8

  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00043	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7ranks@
  0004e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00056	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005a	ff 50 38	 call	 QWORD PTR [rax+56]
  0005d	48 89 44 24 20	 mov	 QWORD PTR dotSpec$[rsp], rax

; 369  : 		
; 370  : 		(
; 371  : 			adaptor->strFactory,
; 372  : 
; 373  : 			// Default look and feel
; 374  : 			//
; 375  : 			(pANTLR3_UINT8)
; 376  : 			"digraph {\n\n"
; 377  : 			"\tordering=out;\n"
; 378  : 			"\tranksep=.4;\n"
; 379  : 			"\tbgcolor=\"lightgrey\";  node [shape=box, fixedsize=false, fontsize=12, fontname=\"Helvetica-bold\", fontcolor=\"blue\"\n"
; 380  : 			"\twidth=.25, height=.25, color=\"black\", fillcolor=\"white\", style=\"filled, solid, bold\"];\n\n"
; 381  : 			"\tedge [arrowsize=.5, color=\"black\", style=\"bold\"]\n\n"
; 382  : 		);
; 383  : 
; 384  :     if	(theTree == NULL)

  00062	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR theTree$[rsp], 0
  0006b	75 1e		 jne	 SHORT $LN7@makeDot

; 385  : 	{
; 386  : 		// No tree, so create a blank spec
; 387  : 		//
; 388  : 		dotSpec->append8(dotSpec, "n0[label=\"EMPTY TREE\"]\n");

  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6?$AA@
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0007e	ff 50 38	 call	 QWORD PTR [rax+56]

; 389  : 		return dotSpec;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00086	e9 b2 01 00 00	 jmp	 $LN1@makeDot
$LN7@makeDot:

; 390  : 	}
; 391  : 
; 392  :     sprintf(buff, "\tn%p[label=\"", theTree);

  0008b	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR theTree$[rsp]
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC?$AA@
  0009a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$[rsp]
  0009f	e8 00 00 00 00	 call	 sprintf

; 393  : 	dotSpec->append8(dotSpec, buff);

  000a4	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$[rsp]
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000b3	ff 50 38	 call	 QWORD PTR [rax+56]

; 394  :     text = adaptor->getText(adaptor, theTree);

  000b6	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  000be	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000c6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ce	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  000d4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR text$[rsp], rax

; 395  :     for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  000dc	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  000e7	eb 10		 jmp	 SHORT $LN4@makeDot
$LN2@makeDot:
  000e9	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  000f0	ff c0		 inc	 eax
  000f2	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN4@makeDot:
  000f9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00101	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00104	39 84 24 90 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  0010b	0f 8d b7 00 00
	00		 jge	 $LN3@makeDot

; 396  :     {
; 397  :             switch(text->charAt(text, j))

  00111	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  00118	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  00120	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00128	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0012e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv91[rsp], eax
  00135	83 bc 24 a0 00
	00 00 0a	 cmp	 DWORD PTR tv91[rsp], 10
  0013d	74 2c		 je	 SHORT $LN9@makeDot
  0013f	83 bc 24 a0 00
	00 00 0d	 cmp	 DWORD PTR tv91[rsp], 13
  00147	74 38		 je	 SHORT $LN10@makeDot
  00149	83 bc 24 a0 00
	00 00 22	 cmp	 DWORD PTR tv91[rsp], 34	; 00000022H
  00151	74 02		 je	 SHORT $LN8@makeDot
  00153	eb 42		 jmp	 SHORT $LN11@makeDot
$LN8@makeDot:

; 398  :             {
; 399  :                 case '"':
; 400  : 
; 401  :                     dotSpec->append8(dotSpec, "\\\"");

  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00166	ff 50 38	 call	 QWORD PTR [rax+56]

; 402  :                     break;

  00169	eb 58		 jmp	 SHORT $LN5@makeDot
$LN9@makeDot:

; 403  : 
; 404  :                 case '\n':
; 405  : 
; 406  :                     dotSpec->append8(dotSpec, "\\n");

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
  00172	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0017c	ff 50 38	 call	 QWORD PTR [rax+56]

; 407  :                     break;

  0017f	eb 42		 jmp	 SHORT $LN5@makeDot
$LN10@makeDot:

; 408  : 
; 409  :                 case '\r':
; 410  : 
; 411  :                     dotSpec->append8(dotSpec, "\\r");

  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
  00188	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00192	ff 50 38	 call	 QWORD PTR [rax+56]

; 412  :                     break;

  00195	eb 2c		 jmp	 SHORT $LN5@makeDot
$LN11@makeDot:

; 413  : 
; 414  :                 default:
; 415  : 
; 416  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  00197	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  0019e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  001a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  001ae	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  001b4	8b d0		 mov	 edx, eax
  001b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001bb	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001c0	ff 50 70	 call	 QWORD PTR [rax+112]
$LN5@makeDot:

; 417  :                     break;
; 418  :             }
; 419  :     }

  001c3	e9 21 ff ff ff	 jmp	 $LN2@makeDot
$LN3@makeDot:

; 420  : 	dotSpec->append8(dotSpec, "\"]\n");

  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EKALBCDP@?$CC?$FN?6?$AA@
  001cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001d4	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001d9	ff 50 38	 call	 QWORD PTR [rax+56]

; 421  : 
; 422  : 	// First produce the node defintions
; 423  : 	//
; 424  : 	defineDotNodes(adaptor, theTree, dotSpec);

  001dc	4c 8b 44 24 20	 mov	 r8, QWORD PTR dotSpec$[rsp]
  001e1	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  001e9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  001f1	e8 00 00 00 00	 call	 defineDotNodes

; 425  : 	dotSpec->append8(dotSpec, "\n");

  001f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  001fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00202	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00207	ff 50 38	 call	 QWORD PTR [rax+56]

; 426  : 	defineDotEdges(adaptor, theTree, dotSpec);

  0020a	4c 8b 44 24 20	 mov	 r8, QWORD PTR dotSpec$[rsp]
  0020f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  00217	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0021f	e8 00 00 00 00	 call	 defineDotEdges

; 427  : 	
; 428  : 	// Terminate the spec
; 429  : 	//
; 430  : 	dotSpec->append8(dotSpec, "\n}");

  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JHLIKEIA@?6?$HN?$AA@
  0022b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00230	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00235	ff 50 38	 call	 QWORD PTR [rax+56]

; 431  : 
; 432  : 	// Result
; 433  : 	//
; 434  : 	return dotSpec;

  00238	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
$LN1@makeDot:

; 435  : }

  0023d	48 8b f8	 mov	 rdi, rax
  00240	48 8b cc	 mov	 rcx, rsp
  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:makeDot$rtcFrameData
  0024a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0024f	48 8b c7	 mov	 rax, rdi
  00252	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0025a	48 33 cc	 xor	 rcx, rsp
  0025d	e8 00 00 00 00	 call	 __security_check_cookie
  00262	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00269	5f		 pop	 rdi
  0026a	c3		 ret	 0
makeDot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT isNilNode
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
isNilNode PROC						; COMDAT

; 907  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 908  : 	return t->isNilNode(t);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]

; 909  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
isNilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getUniqueID
_TEXT	SEGMENT
adaptor$ = 16
node$ = 24
getUniqueID PROC					; COMDAT

; 901  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 902  : 	return	ANTLR3_UINT32_CAST(node);

  0000b	8b 44 24 18	 mov	 eax, DWORD PTR node$[rsp]

; 903  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getUniqueID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getChildCount
_TEXT	SEGMENT
adaptor$ = 48
tree$ = 56
getChildCount PROC					; COMDAT

; 891  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 892  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChildCount()\n");

  00023	b9 02 00 00 00	 mov	 ecx, 2
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of?5@
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 fprintf

; 893  : 	return 0;

  0003d	33 c0		 xor	 eax, eax

; 894  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getChild
_TEXT	SEGMENT
adaptor$ = 48
tree$ = 56
i$ = 64
getChild PROC						; COMDAT

; 884  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 885  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChild()\n");

  00028	b9 02 00 00 00	 mov	 ecx, 2
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of?5@
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fprintf

; 886  : 	return NULL;

  00042	33 c0		 xor	 eax, eax

; 887  : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setText8
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
setText8 PROC						; COMDAT

; 878  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 879  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  00023	b9 02 00 00 00	 mov	 ecx, 2
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of?5@
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 fprintf

; 880  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
setText	PROC						; COMDAT

; 871  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 872  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  00023	b9 02 00 00 00	 mov	 ecx, 2
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of?5@
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 fprintf

; 873  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
setText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getText	PROC						; COMDAT

; 862  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 863  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getText()\n");

  00023	b9 02 00 00 00	 mov	 ecx, 2
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of?5@
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 fprintf

; 864  : 	return	NULL;

  0003d	33 c0		 xor	 eax, eax

; 865  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setType
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
type$ = 64
setType	PROC						; COMDAT

; 854  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 855  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setType()\n");

  00028	b9 02 00 00 00	 mov	 ecx, 2
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of?5@
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fprintf

; 856  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
setType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getType
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getType	PROC						; COMDAT

; 846  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 847  : 	return	0;

  0000b	33 c0		 xor	 eax, eax

; 848  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeText
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
dbgCreateTypeText PROC					; COMDAT

; 832  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 833  : 	pANTLR3_BASE_TREE t;
; 834  : 
; 835  : 	t = createTypeText(adaptor, tokenType, text);

  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR text$[rsp]
  0002c	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00035	e8 00 00 00 00	 call	 createTypeText
  0003a	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 836  : 
; 837  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00044	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00052	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00056	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 838  : 
; 839  : 	return t;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 840  : 
; 841  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
dbgCreateTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeText
_TEXT	SEGMENT
fromToken$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
createTypeText PROC					; COMDAT

; 819  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 820  : 	pANTLR3_COMMON_TOKEN	fromToken;
; 821  : 
; 822  : 	/* Create the new token
; 823  : 	 */
; 824  : 	fromToken = adaptor->createToken(adaptor, tokenType, text);

  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR text$[rsp]
  0002c	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003a	ff 90 08 01 00
	00		 call	 QWORD PTR [rax+264]
  00040	48 89 44 24 20	 mov	 QWORD PTR fromToken$[rsp], rax

; 825  : 
; 826  : 	/* Return a new node based upon this token
; 827  : 	 */
; 828  : 	return	adaptor->create(adaptor, fromToken);

  00045	48 8b 54 24 20	 mov	 rdx, QWORD PTR fromToken$[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00054	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 829  : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
createTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeTokenText
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
fromToken$ = 80
text$ = 88
dbgCreateTypeTokenText PROC				; COMDAT

; 807  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 808  : 	pANTLR3_BASE_TREE t;
; 809  : 
; 810  : 	t = createTypeTokenText(adaptor, tokenType, fromToken, text);

  0002c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR text$[rsp]
  00031	4c 8b 44 24 50	 mov	 r8, QWORD PTR fromToken$[rsp]
  00036	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0003f	e8 00 00 00 00	 call	 createTypeTokenText
  00044	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 811  : 
; 812  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00052	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0005c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00060	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 813  : 
; 814  : 	return t;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 815  : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
dbgCreateTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeTokenText
_TEXT	SEGMENT
adaptor$ = 48
tokenType$ = 56
fromToken$ = 64
text$ = 72
createTypeTokenText PROC				; COMDAT

; 788  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 789  : 	/* Create the new token
; 790  : 	 */
; 791  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  0002c	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003b	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]
  00041	48 89 44 24 40	 mov	 QWORD PTR fromToken$[rsp], rax

; 792  : 
; 793  : 	/* Set the type of the new token to that supplied
; 794  : 	 */
; 795  : 	fromToken->setType(fromToken, tokenType);

  00046	8b 54 24 38	 mov	 edx, DWORD PTR tokenType$[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  00054	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 796  : 
; 797  : 	/* Set the text of the token accordingly
; 798  : 	 */
; 799  : 	fromToken->setText8(fromToken, text);

  0005a	48 8b 54 24 48	 mov	 rdx, QWORD PTR text$[rsp]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  00069	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 800  : 
; 801  : 	/* Return a new node based upon this token
; 802  : 	 */
; 803  : 	return	adaptor->create(adaptor, fromToken);

  0006f	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0007e	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 804  : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
createTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeToken
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
fromToken$ = 80
dbgCreateTypeToken PROC					; COMDAT

; 776  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 777  : 	pANTLR3_BASE_TREE t;
; 778  : 
; 779  : 	t = createTypeToken(adaptor, tokenType, fromToken);

  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR fromToken$[rsp]
  0002c	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00035	e8 00 00 00 00	 call	 createTypeToken
  0003a	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 780  : 
; 781  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00044	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00052	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00056	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 782  : 
; 783  : 	return t;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 784  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
dbgCreateTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeToken
_TEXT	SEGMENT
adaptor$ = 48
tokenType$ = 56
fromToken$ = 64
createTypeToken PROC					; COMDAT

; 761  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 762  : 	/* Create the new token
; 763  : 	 */
; 764  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  00027	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00036	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]
  0003c	48 89 44 24 40	 mov	 QWORD PTR fromToken$[rsp], rax

; 765  : 
; 766  : 	/* Set the type of the new token to that supplied
; 767  : 	 */
; 768  : 	fromToken->setType(fromToken, tokenType);

  00041	8b 54 24 38	 mov	 edx, DWORD PTR tokenType$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  0004f	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 769  : 
; 770  : 	/* Return a new node based upon this token
; 771  : 	 */
; 772  : 	return	adaptor->create(adaptor, fromToken);

  00055	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00064	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 773  : }

  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
createTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgBecomeRootToken
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
newRoot$ = 72
oldRoot$ = 80
dbgBecomeRootToken PROC					; COMDAT

; 746  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 747  : 	pANTLR3_BASE_TREE	t;
; 748  : 
; 749  : 	t =	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRoot$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00037	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0003d	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRoot$[rsp]
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004f	ff 50 68	 call	 QWORD PTR [rax+104]
  00052	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 750  : 
; 751  : 	adaptor->debugger->becomeRoot(adaptor->debugger,t, oldRoot);

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00060	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRoot$[rsp]
  00065	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0006f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00073	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 752  : 
; 753  : 	return t;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 754  : }

  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
dbgBecomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT becomeRootToken
_TEXT	SEGMENT
adaptor$ = 48
newRoot$ = 56
oldRoot$ = 64
becomeRootToken PROC					; COMDAT

; 741  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 742  : 	return	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);

  00028	48 8b 54 24 38	 mov	 rdx, QWORD PTR newRoot$[rsp]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00037	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0003d	4c 8b 44 24 40	 mov	 r8, QWORD PTR oldRoot$[rsp]
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004f	ff 50 68	 call	 QWORD PTR [rax+104]

; 743  : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
becomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgAddChildToken
_TEXT	SEGMENT
tc$ = 32
adaptor$ = 64
t$ = 72
child$ = 80
dbgAddChildToken PROC					; COMDAT

; 576  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 577  : 	pANTLR3_BASE_TREE	tc;
; 578  : 
; 579  : 	if	(t != NULL && child != NULL)

  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002e	74 5b		 je	 SHORT $LN2@dbgAddChil
  00030	48 83 7c 24 50
	00		 cmp	 QWORD PTR child$[rsp], 0
  00036	74 53		 je	 SHORT $LN2@dbgAddChil

; 580  : 	{
; 581  : 		tc = adaptor->create(adaptor, child);

  00038	48 8b 54 24 50	 mov	 rdx, QWORD PTR child$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00047	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0004d	48 89 44 24 20	 mov	 QWORD PTR tc$[rsp], rax

; 582  : 		adaptor->addChild(adaptor, t, tc);

  00052	4c 8b 44 24 20	 mov	 r8, QWORD PTR tc$[rsp]
  00057	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00066	ff 50 38	 call	 QWORD PTR [rax+56]

; 583  : 		adaptor->debugger->addChild(adaptor->debugger, t, tc);

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00072	4c 8b 44 24 20	 mov	 r8, QWORD PTR tc$[rsp]
  00077	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00081	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00085	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
$LN2@dbgAddChil:

; 584  : 	}
; 585  : }

  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
dbgAddChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT addChildToken
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
addChildToken PROC					; COMDAT

; 568  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 569  : 	if	(t != NULL && child != NULL)

  00028	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002e	74 32		 je	 SHORT $LN2@addChildTo
  00030	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00036	74 2a		 je	 SHORT $LN2@addChildTo

; 570  : 	{
; 571  : 		adaptor->addChild(adaptor, t, adaptor->create(adaptor, child));

  00038	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00047	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0004d	4c 8b c0	 mov	 r8, rax
  00050	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005f	ff 50 38	 call	 QWORD PTR [rax+56]
$LN2@addChildTo:

; 572  : 	}
; 573  : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
addChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT rulePostProcessing
_TEXT	SEGMENT
saveRoot$ = 32
adaptor$ = 64
root$ = 72
rulePostProcessing PROC					; COMDAT

; 705  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 706  :     pANTLR3_BASE_TREE saveRoot;
; 707  : 
; 708  :     // Keep track of the root we are given. If it is a nilNode, then we
; 709  :     // can reuse it rather than orphaning it!
; 710  :     //
; 711  :     saveRoot = root;

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR saveRoot$[rsp], rax

; 712  : 
; 713  : 	if (root != NULL && root->isNilNode(root))

  0002d	48 83 7c 24 48
	00		 cmp	 QWORD PTR root$[rsp], 0
  00033	0f 84 93 00 00
	00		 je	 $LN2@rulePostPr
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00043	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	74 7c		 je	 SHORT $LN2@rulePostPr

; 714  : 	{
; 715  : 		if	(root->getChildCount(root) == 0)

  00050	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  0005a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00060	85 c0		 test	 eax, eax
  00062	75 0b		 jne	 SHORT $LN3@rulePostPr

; 716  : 		{
; 717  : 			root = NULL;

  00064	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR root$[rsp], 0

; 718  : 		}

  0006d	eb 5d		 jmp	 SHORT $LN4@rulePostPr
$LN3@rulePostPr:

; 719  : 		else if	(root->getChildCount(root) == 1)

  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00079	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0007f	83 f8 01	 cmp	 eax, 1
  00082	75 48		 jne	 SHORT $LN5@rulePostPr

; 720  : 		{
; 721  : 			root = root->getChild(root, 0);

  00084	33 d2		 xor	 edx, edx
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00090	ff 50 70	 call	 QWORD PTR [rax+112]
  00093	48 89 44 24 48	 mov	 QWORD PTR root$[rsp], rax

; 722  : 			root->setParent(root, NULL);

  00098	33 d2		 xor	 edx, edx
  0009a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  000a4	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 723  : 			root->setChildIndex(root, -1);

  000aa	ba ff ff ff ff	 mov	 edx, -1
  000af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  000b9	ff 50 78	 call	 QWORD PTR [rax+120]

; 724  : 
; 725  :             // The root we were given was a nil node, wiht one child, which means it has
; 726  :             // been abandoned and would be lost in the node factory. However
; 727  :             // nodes can be flagged as resuable to prevent this terrible waste
; 728  :             //
; 729  :             saveRoot->reuse(saveRoot);

  000bc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR saveRoot$[rsp]
  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR saveRoot$[rsp]
  000c6	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
$LN5@rulePostPr:
$LN4@rulePostPr:
$LN2@rulePostPr:

; 730  : 		}
; 731  : 	}
; 732  : 
; 733  : 	return root;

  000cc	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]

; 734  : }

  000d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
rulePostProcessing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgBecomeRoot
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
newRootTree$ = 72
oldRootTree$ = 80
dbgBecomeRoot PROC					; COMDAT

; 692  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 693  : 	pANTLR3_BASE_TREE t;
; 694  : 	
; 695  : 	t = becomeRoot(adaptor, newRootTree, oldRootTree);

  00028	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRootTree$[rsp]
  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRootTree$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00037	e8 00 00 00 00	 call	 becomeRoot
  0003c	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 696  : 
; 697  : 	adaptor->debugger->becomeRoot(adaptor->debugger, newRootTree, oldRootTree);

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRootTree$[rsp]
  0004f	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRootTree$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00059	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005d	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 698  : 
; 699  : 	return t;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 700  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
dbgBecomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT becomeRoot
_TEXT	SEGMENT
saveRoot$ = 32
adaptor$ = 64
newRootTree$ = 72
oldRootTree$ = 80
becomeRoot PROC						; COMDAT

; 621  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 622  :     pANTLR3_BASE_TREE saveRoot;
; 623  : 
; 624  : 	/* Protect against tree rewrites if we are in some sort of error
; 625  : 	 * state, but have tried to recover. In C we can end up with a null pointer
; 626  : 	 * for a tree that was not produced.
; 627  : 	 */
; 628  : 	if	(newRootTree == NULL)

  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR newRootTree$[rsp], 0
  0002e	75 0a		 jne	 SHORT $LN2@becomeRoot

; 629  : 	{
; 630  : 		return	oldRootTree;

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  00035	e9 cb 00 00 00	 jmp	 $LN1@becomeRoot
$LN2@becomeRoot:

; 631  : 	}
; 632  : 
; 633  : 	/* root is just the new tree as is if there is no
; 634  : 	 * current root tree.
; 635  : 	 */
; 636  : 	if	(oldRootTree == NULL)

  0003a	48 83 7c 24 50
	00		 cmp	 QWORD PTR oldRootTree$[rsp], 0
  00040	75 0a		 jne	 SHORT $LN3@becomeRoot

; 637  : 	{
; 638  : 		return	newRootTree;

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00047	e9 b9 00 00 00	 jmp	 $LN1@becomeRoot
$LN3@becomeRoot:

; 639  : 	}
; 640  : 
; 641  : 	/* Produce ^(nil real-node)
; 642  : 	 */
; 643  : 	if	(newRootTree->isNilNode(newRootTree))

  0004c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00056	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	74 64		 je	 SHORT $LN4@becomeRoot

; 644  : 	{
; 645  : 		if	(newRootTree->getChildCount(newRootTree) > 1)

  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  0006d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00073	83 f8 01	 cmp	 eax, 1
  00076	76 21		 jbe	 SHORT $LN5@becomeRoot

; 646  : 		{
; 647  : 			/* TODO: Handle tree exceptions 
; 648  : 			 */
; 649  : 			ANTLR3_FPRINTF(stderr, "More than one node as root! TODO: Create tree exception handling\n");

  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TODO@
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 fprintf

; 650  : 			return newRootTree;

  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00097	eb 6c		 jmp	 SHORT $LN1@becomeRoot
$LN5@becomeRoot:

; 651  : 		}
; 652  : 
; 653  : 		/* The new root is the first child, keep track of the original newRoot
; 654  :          * because if it was a Nil Node, then we can reuse it now.
; 655  : 		 */
; 656  :         saveRoot    = newRootTree;

  00099	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  0009e	48 89 44 24 20	 mov	 QWORD PTR saveRoot$[rsp], rax

; 657  : 		newRootTree = newRootTree->getChild(newRootTree, 0);

  000a3	33 d2		 xor	 edx, edx
  000a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  000af	ff 50 70	 call	 QWORD PTR [rax+112]
  000b2	48 89 44 24 48	 mov	 QWORD PTR newRootTree$[rsp], rax

; 658  : 
; 659  :         // Reclaim the old nilNode()
; 660  :         //
; 661  :         saveRoot->reuse(saveRoot);

  000b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR saveRoot$[rsp]
  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR saveRoot$[rsp]
  000c1	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
$LN4@becomeRoot:

; 662  : 	}
; 663  : 
; 664  : 	/* Add old root into new root. addChild takes care of the case where oldRoot
; 665  : 	 * is a flat list (nill rooted tree). All children of oldroot are added to
; 666  : 	 * new root.
; 667  : 	 */
; 668  : 	newRootTree->addChild(newRootTree, oldRootTree);

  000c7	48 8b 54 24 50	 mov	 rdx, QWORD PTR oldRootTree$[rsp]
  000cc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  000d1	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]

; 669  : 
; 670  :     // If the oldroot tree was a nil node, then we know at this point
; 671  :     // it has become orphaned by the rewrite logic, so we tell it to do
; 672  :     // whatever it needs to do to be reused.
; 673  :     //
; 674  :     if  (oldRootTree->isNilNode(oldRootTree))

  000d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR oldRootTree$[rsp]
  000de	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  000e3	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  000e9	0f b6 c0	 movzx	 eax, al
  000ec	85 c0		 test	 eax, eax
  000ee	74 10		 je	 SHORT $LN6@becomeRoot

; 675  :     {
; 676  :         // We have taken an old Root Tree and appended all its children to the new
; 677  :         // root. In addition though it was a nil node, which means the generated code
; 678  :         // will not reuse it again, so we will reclaim it here. First we want to zero out
; 679  :         // any pointers it was carrying around. We are just the baseTree handler so we
; 680  :         // don't know necessarilly know how to do this for the real node, we just ask the tree itself
; 681  :         // to do it.
; 682  :         //
; 683  :         oldRootTree->reuse(oldRootTree);

  000f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR oldRootTree$[rsp]
  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  000fa	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
$LN6@becomeRoot:

; 684  :     }
; 685  : 	/* Always returns new root structure
; 686  : 	 */
; 687  : 	return	newRootTree;

  00100	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
$LN1@becomeRoot:

; 688  : 
; 689  : }

  00105	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgAddChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
dbgAddChild PROC					; COMDAT

; 557  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 558  : 	if	(t != NULL && child != NULL)

  00028	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002e	74 3c		 je	 SHORT $LN2@dbgAddChil
  00030	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00036	74 34		 je	 SHORT $LN2@dbgAddChil

; 559  : 	{
; 560  : 		t->addChild(t, child);

  00038	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00042	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00047	ff 50 30	 call	 QWORD PTR [rax+48]

; 561  : 		adaptor->debugger->addChild(adaptor->debugger, t, child);

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00053	4c 8b 44 24 40	 mov	 r8, QWORD PTR child$[rsp]
  00058	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00062	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00066	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
$LN2@dbgAddChil:

; 562  : 	}
; 563  : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
dbgAddChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT addChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
addChild PROC						; COMDAT

; 549  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 550  : 	if	(t != NULL && child != NULL)

  00028	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002e	74 1a		 je	 SHORT $LN2@addChild
  00030	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@addChild

; 551  : 	{
; 552  : 		t->addChild(t, child);

  00038	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00042	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00047	ff 50 30	 call	 QWORD PTR [rax+48]
$LN2@addChild:

; 553  : 	}
; 554  : }

  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dupTreeTT
_TEXT	SEGMENT
newTree$ = 32
child$ = 40
newSubTree$ = 48
n$ = 56
i$ = 60
adaptor$ = 80
t$ = 88
parent$ = 96
dupTreeTT PROC						; COMDAT

; 468  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 469  : 	pANTLR3_BASE_TREE	newTree;
; 470  : 	pANTLR3_BASE_TREE	child;
; 471  : 	pANTLR3_BASE_TREE	newSubTree;
; 472  : 	ANTLR3_UINT32		n;
; 473  : 	ANTLR3_UINT32		i;
; 474  : 
; 475  : 	if	(t == NULL)

  00028	48 83 7c 24 58
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002e	75 07		 jne	 SHORT $LN5@dupTreeTT

; 476  : 	{
; 477  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	e9 e1 00 00 00	 jmp	 $LN1@dupTreeTT
$LN5@dupTreeTT:

; 478  : 	}
; 479  : 	newTree = t->dupNode(t);

  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t$[rsp]
  0003c	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  00041	ff 50 58	 call	 QWORD PTR [rax+88]
  00044	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 480  : 
; 481  : 	// Ensure new subtree root has parent/child index set
; 482  : 	//
; 483  : 	adaptor->setChildIndex		(adaptor, newTree, t->getChildIndex(t));

  00049	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t$[rsp]
  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  00053	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00059	44 8b c0	 mov	 r8d, eax
  0005c	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006b	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 484  : 	adaptor->setParent			(adaptor, newTree, parent);

  00071	4c 8b 44 24 60	 mov	 r8, QWORD PTR parent$[rsp]
  00076	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  00085	ff 50 48	 call	 QWORD PTR [rax+72]

; 485  : 	n = adaptor->getChildCount	(adaptor, t);

  00088	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  0008d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  00097	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  0009d	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 486  : 
; 487  : 	for	(i=0; i < n; i++)

  000a1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a9	eb 0a		 jmp	 SHORT $LN4@dupTreeTT
$LN2@dupTreeTT:
  000ab	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  000af	ff c0		 inc	 eax
  000b1	89 44 24 3c	 mov	 DWORD PTR i$[rsp], eax
$LN4@dupTreeTT:
  000b5	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  000b9	39 44 24 3c	 cmp	 DWORD PTR i$[rsp], eax
  000bd	73 54		 jae	 SHORT $LN3@dupTreeTT

; 488  : 	{
; 489  : 		child = adaptor->getChild		(adaptor, t, i);

  000bf	44 8b 44 24 3c	 mov	 r8d, DWORD PTR i$[rsp]
  000c4	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  000d3	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000d9	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 490  : 		newSubTree = adaptor->dupTreeTT	(adaptor, child, t);

  000de	4c 8b 44 24 58	 mov	 r8, QWORD PTR t$[rsp]
  000e3	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000ed	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  000f2	ff 50 30	 call	 QWORD PTR [rax+48]
  000f5	48 89 44 24 30	 mov	 QWORD PTR newSubTree$[rsp], rax

; 491  : 		adaptor->addChild				(adaptor, newTree, newSubTree);

  000fa	4c 8b 44 24 30	 mov	 r8, QWORD PTR newSubTree$[rsp]
  000ff	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  00104	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  0010e	ff 50 38	 call	 QWORD PTR [rax+56]

; 492  : 	}

  00111	eb 98		 jmp	 SHORT $LN2@dupTreeTT
$LN3@dupTreeTT:

; 493  : 	return	newTree;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
$LN1@dupTreeTT:

; 494  : }

  00118	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
dupTreeTT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgDupTree
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tree$ = 72
dbgDupTree PROC						; COMDAT

; 521  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 522  : 	pANTLR3_BASE_TREE t;
; 523  : 
; 524  : 	// Call the normal dup tree mechanism first
; 525  : 	//
; 526  : 	t = adaptor->dupTreeTT(adaptor, tree, NULL);

  00023	45 33 c0	 xor	 r8d, r8d
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00035	ff 50 30	 call	 QWORD PTR [rax+48]
  00038	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 527  : 
; 528  : 	// In order to tell the debugger what we have just done, we now
; 529  : 	// simulate the tree building mechanism. THis will fire
; 530  : 	// lots of debugging events to the client and look like we
; 531  : 	// duped the tree..
; 532  : 	//
; 533  : 	simulateTreeConstruction(adaptor, t);

  0003d	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00047	e8 00 00 00 00	 call	 simulateTreeConstruction

; 534  : 
; 535  : 	return t;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 536  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
dbgDupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dupTree
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
dupTree	PROC						; COMDAT

; 462  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 463  : 	return	adaptor->dupTreeTT(adaptor, t, NULL);

  00023	45 33 c0	 xor	 r8d, r8d
  00026	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00035	ff 50 30	 call	 QWORD PTR [rax+48]

; 464  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
dupTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgNil
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
dbgNil	PROC						; COMDAT

; 448  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 449  : 	pANTLR3_BASE_TREE t;
; 450  : 
; 451  : 	t = adaptor->create				(adaptor, NULL);

  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002a	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00030	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 452  : 	adaptor->debugger->createNode	(adaptor->debugger, t);

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003e	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00048	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004c	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 453  : 
; 454  : 	return	t;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 455  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
dbgNil	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT nilNode
_TEXT	SEGMENT
adaptor$ = 48
nilNode	PROC						; COMDAT

; 442  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 443  : 	return	adaptor->create(adaptor, NULL);

  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002a	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 444  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
nilNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT antlr3BaseTreeAdaptorInit
_TEXT	SEGMENT
adaptor$ = 16
debugger$ = 24
antlr3BaseTreeAdaptorInit PROC				; COMDAT

; 81   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 82   : 	// Initialize the interface
; 83   : 	//
; 84   : 	if	(debugger == NULL)

  0000b	48 83 7c 24 18
	00		 cmp	 QWORD PTR debugger$[rsp], 0
  00011	0f 85 9e 00 00
	00		 jne	 $LN2@antlr3Base

; 85   : 	{
; 86   : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR)) 								

  00017	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nilNode
  00023	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 87   : 																				nilNode;
; 88   : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))								

  00027	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00033	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 89   : 																				addChild;
; 90   : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))				

  00037	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRoot
  00043	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 91   : 																				becomeRoot;
; 92   : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))	

  00047	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChildToken
  00053	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 93   : 																				addChildToken;
; 94   : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  00057	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRootToken
  00063	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 95   : 																				becomeRootToken;
; 96   : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  00067	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeToken
  00073	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 97   : 																				createTypeToken;
; 98   : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  0007a	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeTokenText
  00086	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 99   : 																				createTypeTokenText;
; 100  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  0008d	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeText
  00099	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 101  : 																				createTypeText;
; 102  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))		 				

  000a0	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  000ac	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 103  : 																				dupTree;
; 104  : 	}

  000b0	e9 a7 00 00 00	 jmp	 $LN3@antlr3Base
$LN2@antlr3Base:

; 105  : 	else
; 106  : 	{
; 107  : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR))

  000b5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgNil
  000c1	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 108  :                                                                                 dbgNil;
; 109  : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000c5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgAddChild
  000d1	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 110  :                                                                                 dbgAddChild;
; 111  : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000d5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgBecomeRoot
  000e1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 112  : 																				dbgBecomeRoot;
; 113  : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))

  000e5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgAddChildToken
  000f1	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 114  :                                                                                 dbgAddChildToken;
; 115  : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000f5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgBecomeRootToken
  00101	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 116  :                                                                                 dbgBecomeRootToken;
; 117  : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  00105	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeToken
  00111	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 118  :                                                                                 dbgCreateTypeToken;
; 119  : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  00118	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeTokenText
  00124	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 120  :                                                                                 dbgCreateTypeTokenText;
; 121  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  0012b	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeText
  00137	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 122  :                                                                                 dbgCreateTypeText;
; 123  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0013e	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgDupTree
  0014a	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 124  :                                                                                 dbgDupTree;
; 125  : 		debugger->adaptor				= adaptor;

  0014e	48 8b 44 24 18	 mov	 rax, QWORD PTR debugger$[rsp]
  00153	48 8b 4c 24 10	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00158	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN3@antlr3Base:

; 126  : 	}
; 127  : 
; 128  : 	adaptor->dupTreeTT				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTreeTT
  00168	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 129  :                                                                                 dupTreeTT;
; 130  : 	adaptor->rulePostProcessing		=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rulePostProcessing
  00178	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 131  :                                                                                 rulePostProcessing;
; 132  : 	adaptor->getType				=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  00188	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 133  :                                                                                 getType;
; 134  : 	adaptor->setType				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  0018f	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setType
  0019b	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 135  : 																				setType;
; 136  : 	adaptor->getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  001a2	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  001ae	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 137  :                                                                                 getText;
; 138  : 	adaptor->setText8				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_UINT8))

  001b5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText8
  001c1	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 139  : 																				setText8;
; 140  : 	adaptor->setText				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_STRING))

  001c8	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText
  001d4	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 141  :                                                                                 setText;
; 142  : 	adaptor->getChild				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  001db	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  001e7	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 143  :                                                                                 getChild;
; 144  : 	adaptor->getChildCount			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  001ee	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  001fa	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 145  :                                                                                 getChildCount;
; 146  : 	adaptor->getUniqueID			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00201	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getUniqueID
  0020d	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 147  :                                                                                 getUniqueID;
; 148  : 	adaptor->isNilNode				=  (ANTLR3_BOOLEAN (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00214	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:isNilNode
  00220	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 149  :                                                                                 isNilNode;
; 150  : 
; 151  : 	adaptor->makeDot				=  (pANTLR3_STRING  (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00224	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:makeDot
  00230	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 152  : 																				makeDot;
; 153  : 	
; 154  : 	/* Remaining functions filled in by the caller.
; 155  : 	 */
; 156  : 	return;
; 157  : }

  00237	5f		 pop	 rdi
  00238	c3		 ret	 0
antlr3BaseTreeAdaptorInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00049	e8 00 00 00 00	 call	 _vsprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00049	e8 00 00 00 00	 call	 _vfprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 838  : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
