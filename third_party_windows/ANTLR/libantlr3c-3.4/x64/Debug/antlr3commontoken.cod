; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3CommonTokenNew
PUBLIC	antlr3TokenFactoryNew
PUBLIC	antlr3SetTokenAPI
PUBLIC	??_C@_05FLDDOMNH@?$DMEOF?$DO?$AA@		; `string'
PUBLIC	??_C@_08NEOOKDGC@?$FLIndex?3?5?$AA@		; `string'
PUBLIC	??_C@_09LBBAKIIA@?5?$CIStart?3?5?$AA@		; `string'
PUBLIC	??_C@_07LGAFOPAI@?9Stop?3?5?$AA@		; `string'
PUBLIC	??_C@_04KDEICOAP@?$CJ?5?$DN?8?$AA@		; `string'
PUBLIC	??_C@_08KMKDFHHP@?8?0?5type?$DM?$AA@		; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5?$AA@			; `string'
PUBLIC	??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_02KCKGHPCA@?$CJ?5?$AA@			; `string'
PUBLIC	??_C@_06FIEBOLOH@Line?3?5?$AA@			; `string'
PUBLIC	??_C@_09PNCFGGF@?5LinePos?3?$AA@		; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTokenNew DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$antlr3CommonTokenNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TokenFactoryNew DD imagerel $LN4
	DD	imagerel $LN4+235
	DD	imagerel $unwind$antlr3TokenFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3SetTokenAPI DD imagerel $LN3
	DD	imagerel $LN3+366
	DD	imagerel $unwind$antlr3SetTokenAPI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+363
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText DD imagerel setText
	DD	imagerel setText+39
	DD	imagerel $unwind$setText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText8 DD imagerel setText8
	DD	imagerel setText8+133
	DD	imagerel $unwind$setText8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+15
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setType DD imagerel setType
	DD	imagerel setType+23
	DD	imagerel $unwind$setType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+16
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setLine DD imagerel setLine
	DD	imagerel setLine+24
	DD	imagerel $unwind$setLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+16
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setCharPositionInLine DD imagerel setCharPositionInLine
	DD	imagerel setCharPositionInLine+24
	DD	imagerel $unwind$setCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChannel DD imagerel getChannel
	DD	imagerel getChannel+16
	DD	imagerel $unwind$getChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChannel DD imagerel setChannel
	DD	imagerel setChannel+24
	DD	imagerel $unwind$setChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenIndex DD imagerel getTokenIndex
	DD	imagerel getTokenIndex+17
	DD	imagerel $unwind$getTokenIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenIndex DD imagerel setTokenIndex
	DD	imagerel setTokenIndex+27
	DD	imagerel $unwind$setTokenIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getStartIndex DD imagerel getStartIndex
	DD	imagerel getStartIndex+84
	DD	imagerel $unwind$getStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setStartIndex DD imagerel setStartIndex
	DD	imagerel setStartIndex+27
	DD	imagerel $unwind$setStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getStopIndex DD imagerel getStopIndex
	DD	imagerel getStopIndex+17
	DD	imagerel $unwind$getStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setStopIndex DD imagerel setStopIndex
	DD	imagerel setStopIndex+27
	DD	imagerel $unwind$setStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toString DD imagerel toString
	DD	imagerel toString+581
	DD	imagerel $unwind$toString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factoryClose DD imagerel factoryClose
	DD	imagerel factoryClose+334
	DD	imagerel $unwind$factoryClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newToken DD imagerel newToken
	DD	imagerel newToken+84
	DD	imagerel $unwind$newToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setInputStream DD imagerel setInputStream
	DD	imagerel setInputStream+85
	DD	imagerel $unwind$setInputStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factoryReset DD imagerel factoryReset
	DD	imagerel factoryReset+58
	DD	imagerel $unwind$factoryReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPool DD imagerel newPool
	DD	imagerel newPool+179
	DD	imagerel $unwind$newPool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPoolToken DD imagerel newPoolToken
	DD	imagerel newPoolToken+243
	DD	imagerel $unwind$newPoolToken
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09PNCFGGF@?5LinePos?3?$AA@
CONST	SEGMENT
??_C@_09PNCFGGF@?5LinePos?3?$AA@ DB ' LinePos:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIEBOLOH@Line?3?5?$AA@
CONST	SEGMENT
??_C@_06FIEBOLOH@Line?3?5?$AA@ DB 'Line: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCKGHPCA@?$CJ?5?$AA@
CONST	SEGMENT
??_C@_02KCKGHPCA@?$CJ?5?$AA@ DB ') ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5?$AA@
CONST	SEGMENT
??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5?$AA@ DB '(channel = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5?$AA@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5?$AA@ DB '> ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMKDFHHP@?8?0?5type?$DM?$AA@
CONST	SEGMENT
??_C@_08KMKDFHHP@?8?0?5type?$DM?$AA@ DB ''', type<', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDEICOAP@?$CJ?5?$DN?8?$AA@
CONST	SEGMENT
??_C@_04KDEICOAP@?$CJ?5?$DN?8?$AA@ DB ') =''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGAFOPAI@?9Stop?3?5?$AA@
CONST	SEGMENT
??_C@_07LGAFOPAI@?9Stop?3?5?$AA@ DB '-Stop: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBBAKIIA@?5?$CIStart?3?5?$AA@
CONST	SEGMENT
??_C@_09LBBAKIIA@?5?$CIStart?3?5?$AA@ DB ' (Start: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEOOKDGC@?$FLIndex?3?5?$AA@
CONST	SEGMENT
??_C@_08NEOOKDGC@?$FLIndex?3?5?$AA@ DB '[Index: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLDDOMNH@?$DMEOF?$DO?$AA@
CONST	SEGMENT
??_C@_05FLDDOMNH@?$DMEOF?$DO?$AA@ DB '<EOF>', 00H	; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPoolToken DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPool DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factoryReset DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setInputStream DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newToken DD 021501H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factoryClose DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toString DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setStopIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getStopIndex DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setStartIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getStartIndex DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenIndex DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChannel DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChannel DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setCharPositionInLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setType DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText8 DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3SetTokenAPI DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TokenFactoryNew DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTokenNew DD 021c01H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT newPoolToken
_TEXT	SEGMENT
token$ = 32
tv89 = 40
factory$ = 64
newPoolToken PROC					; COMDAT

; 192  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 193  :     pANTLR3_COMMON_TOKEN token;
; 194  : 
; 195  :     /* See if we need a new token pool before allocating a new
; 196  :      * one
; 197  :      */
; 198  :     if (factory->nextToken >= ANTLR3_FACTORY_POOL_SIZE)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00023	81 78 10 00 04
	00 00		 cmp	 DWORD PTR [rax+16], 1024 ; 00000400H
  0002a	72 0a		 jb	 SHORT $LN2@newPoolTok

; 199  :     {
; 200  :         /* We ran out of tokens in the current pool, so we need a new pool
; 201  :          */
; 202  :         newPool(factory);

  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00031	e8 00 00 00 00	 call	 newPool
$LN2@newPoolTok:

; 203  :     }
; 204  : 
; 205  :     /* Assuming everything went well (we are trying for performance here so doing minimal
; 206  :      * error checking. Then we can work out what the pointer is to the next token.
; 207  :      */
; 208  :     token = factory->pools[factory->thisPool] + factory->nextToken;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0003b	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00044	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00047	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  0004c	8b 52 10	 mov	 edx, DWORD PTR [rdx+16]
  0004f	48 69 d2 08 01
	00 00		 imul	 rdx, rdx, 264		; 00000108H
  00056	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  0005a	48 8b c2	 mov	 rax, rdx
  0005d	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 209  :     factory->nextToken++;

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00067	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006a	ff c0		 inc	 eax
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00071	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 210  : 
; 211  :     /* We have our token pointer now, so we can initialize it to the predefined model.
; 212  :      * We only need do this though if the token is not already initialized, we just check
; 213  :      * an api function pointer for this as they are allocated via calloc.
; 214  :      */
; 215  :     if  (token->setStartIndex == NULL)

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00079	48 83 b8 e8 00
	00 00 00	 cmp	 QWORD PTR [rax+232], 0
  00081	75 65		 jne	 SHORT $LN3@newPoolTok

; 216  :     {
; 217  :         antlr3SetTokenAPI(token);

  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00088	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 218  : 
; 219  :         // It is factory made, and we need to copy the string factory pointer
; 220  :         //
; 221  :         token->factoryMade  = ANTLR3_TRUE;

  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00092	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 222  :         token->strFactory   = factory->input == NULL ? NULL : factory->input->strFactory;

  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0009b	48 83 b8 20 01
	00 00 00	 cmp	 QWORD PTR [rax+288], 0
  000a3	75 0b		 jne	 SHORT $LN5@newPoolTok
  000a5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
  000ae	eb 15		 jmp	 SHORT $LN6@newPoolTok
$LN5@newPoolTok:
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000b5	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  000bc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c0	48 89 44 24 28	 mov	 QWORD PTR tv89[rsp], rax
$LN6@newPoolTok:
  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv89[rsp]
  000cf	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 223  :         token->input        = factory->input;

  000d3	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000dd	48 8b 89 20 01
	00 00		 mov	 rcx, QWORD PTR [rcx+288]
  000e4	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN3@newPoolTok:

; 224  :     }
; 225  : 
; 226  :     /* And we are done
; 227  :      */
; 228  :     return token;

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]

; 229  : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
newPoolToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT newPool
_TEXT	SEGMENT
factory$ = 48
newPool	PROC						; COMDAT

; 153  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 154  :     /* Increment factory count
; 155  :      */
; 156  :     factory->thisPool++;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c0		 inc	 eax
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 157  : 
; 158  :     // If we were reusing this token factory then we may already have a pool
; 159  :     // allocated. If we exceeded the max avaible then we must allocate a new
; 160  :     // one.
; 161  :     if  (factory->thisPool > factory->maxPool)

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0003d	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00040	7e 5f		 jle	 SHORT $LN2@newPool

; 162  :     {
; 163  :         /* Ensure we have enough pointers allocated
; 164  :          */
; 165  :         factory->pools = (pANTLR3_COMMON_TOKEN *)

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00047	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004a	ff c0		 inc	 eax
  0004c	48 98		 cdqe
  0004e	48 c1 e0 03	 shl	 rax, 3
  00052	8b c0		 mov	 eax, eax
  00054	8b d0		 mov	 edx, eax
  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0005b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00069	48 89 01	 mov	 QWORD PTR [rcx], rax

; 166  : 		         ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
; 167  : 					    (ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TOKEN *))	/* Memory for new pool pointers */
; 168  : 					    );
; 169  : 
; 170  :         /* Allocate a new pool for the factory
; 171  :          */
; 172  :         factory->pools[factory->thisPool]	=

  0006c	ba 00 20 04 00	 mov	 edx, 270336		; 00042000H
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00081	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  00085	48 8b 54 24 30	 mov	 rdx, QWORD PTR factory$[rsp]
  0008a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0008d	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 173  : 			        (pANTLR3_COMMON_TOKEN) 
; 174  : 				    ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN) * ANTLR3_FACTORY_POOL_SIZE));
; 175  : 
; 176  :         // We now have a new pool and can track it as the maximum we have created so far
; 177  :         //
; 178  :         factory->maxPool = factory->thisPool;

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0009b	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0009e	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN2@newPool:

; 179  :     }
; 180  : 
; 181  :     /* Reset the counters
; 182  :      */
; 183  :     factory->nextToken	= 0;

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  000a6	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 184  :   
; 185  :     /* Done
; 186  :      */
; 187  :     return;
; 188  : }

  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
newPool	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT factoryReset
_TEXT	SEGMENT
factory$ = 48
factoryReset PROC					; COMDAT

; 233  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 234  :     // Just start again with pool #0 when we are
; 235  :     // called.
; 236  :     //
; 237  :     factory->thisPool   = -1;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00023	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 238  :     newPool(factory);

  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0002f	e8 00 00 00 00	 call	 newPool

; 239  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
factoryReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setInputStream
_TEXT	SEGMENT
factory$ = 16
input$ = 24
setInputStream PROC					; COMDAT

; 138  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 139  :     factory->input          =  input;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  00015	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 140  :     factory->unTruc.input   =  input;

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00021	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  00026	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 141  : 	if	(input != NULL)

  0002a	48 83 7c 24 18
	00		 cmp	 QWORD PTR input$[rsp], 0
  00030	74 14		 je	 SHORT $LN2@setInputSt

; 142  : 	{
; 143  : 		factory->unTruc.strFactory	= input->strFactory;

  00032	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00037	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  0003c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 144  : 	}

  00044	eb 0d		 jmp	 SHORT $LN3@setInputSt
$LN2@setInputSt:

; 145  : 	else
; 146  : 	{
; 147  : 		factory->unTruc.strFactory = NULL;

  00046	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  0004b	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN3@setInputSt:

; 148  :     }
; 149  : }

  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
setInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT newToken
_TEXT	SEGMENT
token$ = 32
newToken PROC						; COMDAT

; 305  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 0c 00 00 00	 mov	 ecx, 12
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd

; 306  :     pANTLR3_COMMON_TOKEN    token;
; 307  : 
; 308  :     /* Allocate memory for this
; 309  :      */
; 310  :     token   = (pANTLR3_COMMON_TOKEN) ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN)));

  00015	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00025	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 311  : 
; 312  :     if	(token == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@newToken

; 313  :     {
; 314  : 	return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	eb 18		 jmp	 SHORT $LN1@newToken
$LN2@newToken:

; 315  :     }
; 316  : 
; 317  :     // Install the API
; 318  :     //
; 319  :     antlr3SetTokenAPI(token);

  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0003b	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 320  :     token->factoryMade = ANTLR3_FALSE;

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00045	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 321  : 
; 322  :     return  token;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
$LN1@newToken:

; 323  : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
newToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT factoryClose
_TEXT	SEGMENT
pool$ = 32
poolCount$ = 40
limit$ = 44
token$ = 48
check$ = 56
tv74 = 64
factory$ = 96
factoryClose PROC					; COMDAT

; 243  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 244  :     pANTLR3_COMMON_TOKEN    pool;
; 245  :     ANTLR3_INT32	    poolCount;
; 246  :     ANTLR3_UINT32	    limit;
; 247  :     ANTLR3_UINT32	    token;
; 248  :     pANTLR3_COMMON_TOKEN    check;
; 249  : 
; 250  :     /* We iterate the token pools one at a time
; 251  :      */
; 252  :     for	(poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  0001e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  00026	eb 0a		 jmp	 SHORT $LN4@factoryClo
$LN2@factoryClo:
  00028	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  0002c	ff c0		 inc	 eax
  0002e	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN4@factoryClo:
  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  0003e	0f 8f eb 00 00
	00		 jg	 $LN3@factoryClo

; 253  :     {
; 254  : 	/* Pointer to current pool
; 255  : 	 */
; 256  : 	pool	= factory->pools[poolCount];

  00044	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00049	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00055	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 257  : 
; 258  : 	/* Work out how many tokens we need to check in this pool.
; 259  : 	 */
; 260  : 	limit	= (poolCount == factory->thisPool ? factory->nextToken : ANTLR3_FACTORY_POOL_SIZE);

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0005f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00062	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00066	75 0e		 jne	 SHORT $LN11@factoryClo
  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0006d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00070	89 44 24 40	 mov	 DWORD PTR tv74[rsp], eax
  00074	eb 08		 jmp	 SHORT $LN12@factoryClo
$LN11@factoryClo:
  00076	c7 44 24 40 00
	04 00 00	 mov	 DWORD PTR tv74[rsp], 1024 ; 00000400H
$LN12@factoryClo:
  0007e	8b 44 24 40	 mov	 eax, DWORD PTR tv74[rsp]
  00082	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 261  : 	
; 262  : 	/* Marginal condition, we might be at the start of a brand new pool
; 263  : 	 * where the nextToken is 0 and nothing has been allocated.
; 264  : 	 */
; 265  : 	if  (limit > 0)

  00086	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  0008b	76 71		 jbe	 SHORT $LN8@factoryClo

; 266  : 	{
; 267  : 	    /* We have some tokens allocated from this pool
; 268  : 	     */
; 269  : 	    for (token = 0; token < limit; token++)

  0008d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR token$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN7@factoryClo
$LN5@factoryClo:
  00097	8b 44 24 30	 mov	 eax, DWORD PTR token$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 30	 mov	 DWORD PTR token$[rsp], eax
$LN7@factoryClo:
  000a1	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  000a5	39 44 24 30	 cmp	 DWORD PTR token$[rsp], eax
  000a9	73 53		 jae	 SHORT $LN6@factoryClo

; 270  : 	    {
; 271  : 		/* Next one in the chain
; 272  : 		 */
; 273  : 		check	= pool + token;

  000ab	8b 44 24 30	 mov	 eax, DWORD PTR token$[rsp]
  000af	48 69 c0 08 01
	00 00		 imul	 rax, rax, 264		; 00000108H
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  000bb	48 03 c8	 add	 rcx, rax
  000be	48 8b c1	 mov	 rax, rcx
  000c1	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 274  : 
; 275  : 		/* If the programmer made this a custom token, then
; 276  : 		 * see if we need to call their free routine.
; 277  : 		 */
; 278  : 		if  (check->custom != NULL && check->freeCustom != NULL)

  000c6	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000cb	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000d0	74 2a		 je	 SHORT $LN9@factoryClo
  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000d7	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000dc	74 1e		 je	 SHORT $LN9@factoryClo

; 279  : 		{
; 280  : 		    check->freeCustom(check->custom);

  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000e3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000e7	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000ec	ff 50 70	 call	 QWORD PTR [rax+112]

; 281  : 		    check->custom = NULL;

  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000f4	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN9@factoryClo:

; 282  : 		}
; 283  : 	    }

  000fc	eb 99		 jmp	 SHORT $LN5@factoryClo
$LN6@factoryClo:
$LN8@factoryClo:

; 284  : 	}
; 285  : 
; 286  : 	/* We can now free this pool allocation
; 287  : 	 */
; 288  : 	ANTLR3_FREE(factory->pools[poolCount]);

  000fe	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00103	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00108	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0010b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 289  : 	factory->pools[poolCount] = NULL;

  00115	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  0011a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0011f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00122	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 290  :     }

  0012a	e9 f9 fe ff ff	 jmp	 $LN2@factoryClo
$LN3@factoryClo:

; 291  : 
; 292  :     /* All the pools are deallocated we can free the pointers to the pools
; 293  :      * now.
; 294  :      */
; 295  :     ANTLR3_FREE(factory->pools);

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00134	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 296  : 
; 297  :     /* Finally, we can free the space for the factory itself
; 298  :      */
; 299  :     ANTLR3_FREE(factory);

  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 300  : }

  00148	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0014c	5f		 pop	 rdi
  0014d	c3		 ret	 0
factoryClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT toString
_TEXT	SEGMENT
text$ = 32
outtext$ = 40
token$ = 64
toString PROC						; COMDAT

; 535  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 536  :     pANTLR3_STRING  text;
; 537  :     pANTLR3_STRING  outtext;
; 538  : 
; 539  :     text    =	token->getText(token);

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00028	ff 50 78	 call	 QWORD PTR [rax+120]
  0002b	48 89 44 24 20	 mov	 QWORD PTR text$[rsp], rax

; 540  :     
; 541  :     if	(text == NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR text$[rsp], 0
  00036	75 07		 jne	 SHORT $LN2@toString

; 542  :     {
; 543  : 		return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 00 02 00 00	 jmp	 $LN1@toString
$LN2@toString:

; 544  :     }
; 545  : 
; 546  : 	if	(text->factory == NULL)

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  00044	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00048	75 0a		 jne	 SHORT $LN3@toString

; 547  : 	{
; 548  : 		return text;		// This usally means it is the EOF token

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  0004f	e9 eb 01 00 00	 jmp	 $LN1@toString
$LN3@toString:

; 549  : 	}
; 550  : 
; 551  :     /* A new empty string to assemble all the stuff in
; 552  :      */
; 553  :     outtext = text->factory->newRaw(text->factory);

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR text$[rsp]
  00061	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00064	ff 50 10	 call	 QWORD PTR [rax+16]
  00067	48 89 44 24 28	 mov	 QWORD PTR outtext$[rsp], rax

; 554  : 
; 555  :     /* Now we use our handy dandy string utility to assemble the
; 556  :      * the reporting string
; 557  :      * return "[@"+getTokenIndex()+","+start+":"+stop+"='"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
; 558  :      */
; 559  :     outtext->append8(outtext, "[Index: ");

  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NEOOKDGC@?$FLIndex?3?5?$AA@
  00073	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0007d	ff 50 38	 call	 QWORD PTR [rax+56]

; 560  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getTokenIndex(token));

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0008a	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00090	8b d0		 mov	 edx, eax
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0009c	ff 50 78	 call	 QWORD PTR [rax+120]

; 561  :     outtext->append8(outtext, " (Start: ");

  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LBBAKIIA@?5?$CIStart?3?5?$AA@
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000b0	ff 50 38	 call	 QWORD PTR [rax+56]

; 562  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStartIndex(token));

  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  000bd	ff 90 e0 00 00
	00		 call	 QWORD PTR [rax+224]
  000c3	8b d0		 mov	 edx, eax
  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000cf	ff 50 78	 call	 QWORD PTR [rax+120]

; 563  :     outtext->append8(outtext, "-Stop: ");

  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LGAFOPAI@?9Stop?3?5?$AA@
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000de	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000e3	ff 50 38	 call	 QWORD PTR [rax+56]

; 564  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStopIndex(token));

  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  000eb	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  000f0	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  000f6	8b d0		 mov	 edx, eax
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00102	ff 50 78	 call	 QWORD PTR [rax+120]

; 565  :     outtext->append8(outtext, ") ='");

  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KDEICOAP@?$CJ?5?$DN?8?$AA@
  0010c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00111	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00116	ff 50 38	 call	 QWORD PTR [rax+56]

; 566  :     outtext->appendS(outtext, text);

  00119	48 8b 54 24 20	 mov	 rdx, QWORD PTR text$[rsp]
  0011e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00128	ff 50 58	 call	 QWORD PTR [rax+88]

; 567  :     outtext->append8(outtext, "', type<");

  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KMKDFHHP@?8?0?5type?$DM?$AA@
  00132	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0013c	ff 50 38	 call	 QWORD PTR [rax+56]

; 568  :     outtext->addi   (outtext, token->type);

  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00144	8b 10		 mov	 edx, DWORD PTR [rax]
  00146	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00150	ff 50 78	 call	 QWORD PTR [rax+120]

; 569  :     outtext->append8(outtext, "> ");

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LLMPMKNF@?$DO?5?$AA@
  0015a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0015f	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00164	ff 50 38	 call	 QWORD PTR [rax+56]

; 570  : 
; 571  :     if	(token->getChannel(token) > ANTLR3_TOKEN_DEFAULT_CHANNEL)

  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  0016c	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00171	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00177	85 c0		 test	 eax, eax
  00179	76 47		 jbe	 SHORT $LN4@toString

; 572  :     {
; 573  : 		outtext->append8(outtext, "(channel = ");

  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5?$AA@
  00182	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00187	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0018c	ff 50 38	 call	 QWORD PTR [rax+56]

; 574  : 		outtext->addi	(outtext, (ANTLR3_INT32)token->getChannel(token));

  0018f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00194	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00199	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0019f	8b d0		 mov	 edx, eax
  001a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001a6	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001ab	ff 50 78	 call	 QWORD PTR [rax+120]

; 575  : 		outtext->append8(outtext, ") ");

  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KCKGHPCA@?$CJ?5?$AA@
  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001bf	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@toString:

; 576  :     }
; 577  : 
; 578  :     outtext->append8(outtext, "Line: ");

  001c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FIEBOLOH@Line?3?5?$AA@
  001c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001ce	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001d3	ff 50 38	 call	 QWORD PTR [rax+56]

; 579  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getLine(token));

  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  001db	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  001e0	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  001e6	8b d0		 mov	 edx, eax
  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001f2	ff 50 78	 call	 QWORD PTR [rax+120]

; 580  :     outtext->append8(outtext, " LinePos:");

  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PNCFGGF@?5LinePos?3?$AA@
  001fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00201	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00206	ff 50 38	 call	 QWORD PTR [rax+56]

; 581  :     outtext->addi   (outtext, token->getCharPositionInLine(token));

  00209	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00213	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00219	8b d0		 mov	 edx, eax
  0021b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00220	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00225	ff 50 78	 call	 QWORD PTR [rax+120]

; 582  :     outtext->addc   (outtext, ']');

  00228	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  0022d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00232	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00237	ff 50 70	 call	 QWORD PTR [rax+112]

; 583  : 
; 584  :     return  outtext;

  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
$LN1@toString:

; 585  : }

  0023f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00243	5f		 pop	 rdi
  00244	c3		 ret	 0
toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setStopIndex
_TEXT	SEGMENT
token$ = 16
stop$ = 24
setStopIndex PROC					; COMDAT

; 530  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 531  :     token->stop	= stop;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR stop$[rsp]
  00015	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 532  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getStopIndex
_TEXT	SEGMENT
token$ = 16
getStopIndex PROC					; COMDAT

; 525  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 526  :     return  token->stop;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]

; 527  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setStartIndex
_TEXT	SEGMENT
token$ = 16
start$ = 24
setStartIndex PROC					; COMDAT

; 520  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 521  :     token->start    = start;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR start$[rsp]
  00015	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 522  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getStartIndex
_TEXT	SEGMENT
tv69 = 0
token$ = 32
getStartIndex PROC					; COMDAT

; 515  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 516  : 	return  token->start == -1 ? (ANTLR3_MARKER)(token->input->data) : token->start;

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00023	48 83 78 38 ff	 cmp	 QWORD PTR [rax+56], -1
  00028	75 13		 jne	 SHORT $LN3@getStartIn
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
  0003b	eb 0d		 jmp	 SHORT $LN4@getStartIn
$LN3@getStartIn:
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00042	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00046	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@getStartIn:
  0004a	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]

; 517  : }

  0004e	48 83 c4 10	 add	 rsp, 16
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
getStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setTokenIndex
_TEXT	SEGMENT
token$ = 16
index$ = 24
setTokenIndex PROC					; COMDAT

; 510  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 511  :     token->index    = index;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR index$[rsp]
  00015	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 512  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getTokenIndex
_TEXT	SEGMENT
token$ = 16
getTokenIndex PROC					; COMDAT

; 505  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 506  :     return  token->index;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]

; 507  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setChannel
_TEXT	SEGMENT
token$ = 16
channel$ = 24
setChannel PROC						; COMDAT

; 500  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 501  :     token->channel  = channel;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR channel$[rsp]
  00013	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 502  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getChannel
_TEXT	SEGMENT
token$ = 16
getChannel PROC						; COMDAT

; 495  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 496  :     return  token->channel;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 24	 mov	 eax, DWORD PTR [rax+36]

; 497  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setCharPositionInLine
_TEXT	SEGMENT
token$ = 16
pos$ = 24
setCharPositionInLine PROC				; COMDAT

; 490  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 491  :     token->charPosition = pos;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR pos$[rsp]
  00013	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 492  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
token$ = 16
getCharPositionInLine PROC				; COMDAT

; 485  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 486  :     return  token->charPosition;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 20	 mov	 eax, DWORD PTR [rax+32]

; 487  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setLine
_TEXT	SEGMENT
token$ = 16
line$ = 24
setLine	PROC						; COMDAT

; 480  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 481  :     token->line = line;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR line$[rsp]
  00013	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 482  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getLine
_TEXT	SEGMENT
token$ = 16
getLine	PROC						; COMDAT

; 475  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 476  :     return  token->line;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 477  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setType
_TEXT	SEGMENT
token$ = 16
type$ = 24
setType	PROC						; COMDAT

; 470  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 471  :     token->type = type;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR type$[rsp]
  00013	89 08		 mov	 DWORD PTR [rax], ecx

; 472  : }

  00015	5f		 pop	 rdi
  00016	c3		 ret	 0
setType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getType
_TEXT	SEGMENT
token$ = 16
getType	PROC						; COMDAT

; 465  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 466  :     return  token->type;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 00		 mov	 eax, DWORD PTR [rax]

; 467  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setText8
_TEXT	SEGMENT
tv66 = 32
token$ = 64
text$ = 72
setText8 PROC						; COMDAT

; 416  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 417  : 	// No text to set, so ignore
; 418  : 	//
; 419  : 	if	(text == NULL) return;

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR text$[rsp], 0
  00029	75 02		 jne	 SHORT $LN4@setText8
  0002b	eb 52		 jmp	 SHORT $LN1@setText8
$LN4@setText8:

; 420  : 
; 421  : 	switch	(token->textState)

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00032	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00035	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00039	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003e	72 25		 jb	 SHORT $LN6@setText8
  00040	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00045	76 02		 jbe	 SHORT $LN5@setText8
  00047	eb 1c		 jmp	 SHORT $LN6@setText8
$LN5@setText8:

; 422  : 	{
; 423  : 		case	ANTLR3_TEXT_NONE:
; 424  : 		case	ANTLR3_TEXT_CHARP:	// Caller must free before setting again, if it needs to be freed
; 425  : 
; 426  : 			// Nothing in there yet, or just a char *, so just set the
; 427  : 			// text as a pointer
; 428  : 			//
; 429  : 			token->textState		= ANTLR3_TEXT_CHARP;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0004e	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 430  : 			token->tokText.chars	= (pANTLR3_UCHAR)text;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR text$[rsp]
  0005f	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 431  : 			break;

  00063	eb 1a		 jmp	 SHORT $LN2@setText8
$LN6@setText8:

; 432  : 
; 433  : 		default:
; 434  : 
; 435  : 			// It was already a pANTLR3_STRING, so just override it
; 436  : 			//
; 437  : 			token->tokText.text->set8(token->tokText.text, (const char *)text);

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0006a	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0006e	48 8b 54 24 48	 mov	 rdx, QWORD PTR text$[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00078	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0007c	ff 50 28	 call	 QWORD PTR [rax+40]
$LN2@setText8:
$LN1@setText8:

; 438  : 			break;
; 439  : 	}
; 440  : 
; 441  : 	// We are done 
; 442  : 	//
; 443  : 	return;
; 444  : }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT setText
_TEXT	SEGMENT
token$ = 16
text$ = 24
setText	PROC						; COMDAT

; 452  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 453  : 	// Merely replaces and existing pre-defined text with the supplied
; 454  : 	// string
; 455  : 	//
; 456  : 	token->textState	= ANTLR3_TEXT_STRING;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 457  : 	token->tokText.text	= text;

  00017	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0001c	48 8b 4c 24 18	 mov	 rcx, QWORD PTR text$[rsp]
  00021	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 458  : 
; 459  : 	/* We are done 
; 460  : 	*/
; 461  : 	return;
; 462  : }

  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
setText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT getText
_TEXT	SEGMENT
tv65 = 32
tv131 = 40
tv142 = 48
token$ = 80
getText	PROC						; COMDAT

; 352  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 353  : 	switch (token->textState)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00023	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00026	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0002a	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  0002f	74 1c		 je	 SHORT $LN5@getText
  00031	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00036	74 02		 je	 SHORT $LN4@getText
  00038	eb 6e		 jmp	 SHORT $LN8@getText
$LN4@getText:

; 354  : 	{
; 355  : 		case ANTLR3_TEXT_STRING:
; 356  : 
; 357  : 			// Someone already created a string for this token, so we just
; 358  : 			// use it.
; 359  : 			//
; 360  : 			return	token->tokText.text;

  0003a	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0003f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00043	e9 1d 01 00 00	 jmp	 $LN1@getText

; 361  : 			break;

  00048	e9 18 01 00 00	 jmp	 $LN2@getText
$LN5@getText:

; 362  :     
; 363  : 		case ANTLR3_TEXT_CHARP:
; 364  : 
; 365  : 			// We had a straight text pointer installed, now we
; 366  : 			// must convert it to a string. Note we have to do this here
; 367  : 			// or otherwise setText8() will just install the same char*
; 368  : 			//
; 369  : 			if	(token->strFactory != NULL)

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00052	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00057	74 43		 je	 SHORT $LN6@getText

; 370  : 			{
; 371  : 				token->tokText.text	= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)token->tokText.chars);

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00067	48 8b 51 50	 mov	 rdx, QWORD PTR [rcx+80]
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00070	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00074	ff 50 38	 call	 QWORD PTR [rax+56]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  0007c	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 372  : 				token->textState	= ANTLR3_TEXT_STRING;

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00085	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 373  : 				return token->tokText.text;

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00091	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00095	e9 cb 00 00 00	 jmp	 $LN1@getText

; 374  : 			}

  0009a	eb 07		 jmp	 SHORT $LN7@getText
$LN6@getText:

; 375  : 			else
; 376  : 			{
; 377  : 				// We cannot do anything here
; 378  : 				//
; 379  : 				return NULL;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 c2 00 00 00	 jmp	 $LN1@getText
$LN7@getText:

; 380  : 			}
; 381  : 			break;

  000a3	e9 bd 00 00 00	 jmp	 $LN2@getText
$LN8@getText:

; 382  : 
; 383  : 		default:
; 384  : 
; 385  : 			// EOF is a special case
; 386  : 			//
; 387  : 			if (token->type == ANTLR3_TOKEN_EOF)

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000ad	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  000b0	75 51		 jne	 SHORT $LN9@getText

; 388  : 			{
; 389  : 				token->tokText.text				= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)"<EOF>");

  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000b7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLDDOMNH@?$DMEOF?$DO?$AA@
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000c7	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000cb	ff 50 38	 call	 QWORD PTR [rax+56]
  000ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000d3	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 390  : 				token->textState				= ANTLR3_TEXT_STRING;

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000dc	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 391  : 				token->tokText.text->factory	= token->strFactory;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000e8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000f1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 392  : 				return token->tokText.text;

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000fd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00101	eb 62		 jmp	 SHORT $LN1@getText
$LN9@getText:

; 393  : 			}
; 394  : 
; 395  : 
; 396  : 			// We had nothing installed in the token, create a new string
; 397  : 			// from the input stream
; 398  : 			//
; 399  : 
; 400  : 			if	(token->input != NULL)

  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00108	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0010d	74 54		 je	 SHORT $LN10@getText

; 401  : 			{
; 402  : 			
; 403  : 				return	token->input->substr(	token->input, 

  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00119	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  0011f	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00129	48 8b 54 24 50	 mov	 rdx, QWORD PTR token$[rsp]
  0012e	ff 92 e0 00 00
	00		 call	 QWORD PTR [rdx+224]
  00134	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00139	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0013d	48 89 4c 24 30	 mov	 QWORD PTR tv142[rsp], rcx
  00142	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv131[rsp]
  00147	4c 8b c2	 mov	 r8, rdx
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00152	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00156	48 8b 44 24 30	 mov	 rax, QWORD PTR tv142[rsp]
  0015b	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00161	eb 02		 jmp	 SHORT $LN1@getText
$LN10@getText:

; 404  : 												token->getStartIndex(token), 
; 405  :  												token->getStopIndex(token)
; 406  : 											);
; 407  : 			}
; 408  : 
; 409  : 			// Nothing to return, there is no input stream
; 410  : 			//
; 411  : 			return NULL;

  00163	33 c0		 xor	 eax, eax
$LN2@getText:
$LN1@getText:

; 412  : 			break;
; 413  : 	}
; 414  : }

  00165	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00169	5f		 pop	 rdi
  0016a	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT antlr3SetTokenAPI
_TEXT	SEGMENT
token$ = 16
antlr3SetTokenAPI PROC					; COMDAT

; 327  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 328  :     token->getText		    = getText;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  00012	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 329  :     token->setText		    = setText;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText
  00022	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 330  :     token->setText8		    = setText8;

  00029	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText8
  00035	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 331  :     token->getType		    = getType;

  0003c	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  00048	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 332  :     token->setType		    = setType;

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setType
  0005b	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 333  :     token->getLine		    = getLine;

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  0006e	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 334  :     token->setLine		    = setLine;

  00075	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setLine
  00081	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 335  :     token->setLine		    = setLine;

  00088	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setLine
  00094	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 336  :     token->getCharPositionInLine    = getCharPositionInLine;

  0009b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  000a7	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 337  :     token->setCharPositionInLine    = setCharPositionInLine;

  000ae	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharPositionInLine
  000ba	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 338  :     token->getChannel		    = getChannel;

  000c1	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChannel
  000cd	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 339  :     token->setChannel		    = setChannel;

  000d4	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChannel
  000e0	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 340  :     token->getTokenIndex	    = getTokenIndex;

  000e7	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenIndex
  000f3	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 341  :     token->setTokenIndex	    = setTokenIndex;

  000fa	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenIndex
  00106	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 342  :     token->getStartIndex	    = getStartIndex;

  0010d	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getStartIndex
  00119	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 343  :     token->setStartIndex	    = setStartIndex;

  00120	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setStartIndex
  0012c	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 344  :     token->getStopIndex		    = getStopIndex;

  00133	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getStopIndex
  0013f	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 345  :     token->setStopIndex		    = setStopIndex;

  00146	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setStopIndex
  00152	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 346  :     token->toString		    = toString;

  00159	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toString
  00165	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 347  : 
; 348  :     return;
; 349  : }

  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
antlr3SetTokenAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT antlr3TokenFactoryNew
_TEXT	SEGMENT
factory$ = 32
input$ = 64
antlr3TokenFactoryNew PROC				; COMDAT

; 93   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 94   :     pANTLR3_TOKEN_FACTORY   factory;
; 95   : 
; 96   :     /* allocate memory
; 97   :      */
; 98   :     factory	= (pANTLR3_TOKEN_FACTORY) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_TOKEN_FACTORY));

  0001e	b9 48 01 00 00	 mov	 ecx, 328		; 00000148H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 99   : 
; 100  :     if	(factory == NULL)

  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00034	75 07		 jne	 SHORT $LN2@antlr3Toke

; 101  :     {
; 102  : 	return	NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 a8 00 00 00	 jmp	 $LN1@antlr3Toke
$LN2@antlr3Toke:

; 103  :     }
; 104  : 
; 105  :     /* Install factory API
; 106  :      */
; 107  :     factory->newToken	    = newPoolToken;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPoolToken
  00049	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 108  :     factory->close	    = factoryClose;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:factoryClose
  0005c	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 109  :     factory->setInputStream = setInputStream;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setInputStream
  0006f	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 110  :     factory->reset          = factoryReset;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:factoryReset
  00082	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 111  :     
; 112  :     /* Allocate the initial pool
; 113  :      */
; 114  :     factory->thisPool	= -1;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0008e	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 115  :     factory->pools      = NULL;

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0009a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 116  :     factory->maxPool    = -1;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000a6	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [rax+12], -1

; 117  :     newPool(factory);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000b2	e8 00 00 00 00	 call	 newPool

; 118  : 
; 119  :     /* Factory space is good, we now want to initialize our cheating token
; 120  :      * which one it is initialized is the model for all tokens we manufacture
; 121  :      */
; 122  :     antlr3SetTokenAPI(&factory->unTruc);

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000bc	48 83 c0 18	 add	 rax, 24
  000c0	48 8b c8	 mov	 rcx, rax
  000c3	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 123  : 
; 124  :     /* Set some initial variables for future copying
; 125  :      */
; 126  :     factory->unTruc.factoryMade	= ANTLR3_TRUE;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000cd	c6 40 1c 01	 mov	 BYTE PTR [rax+28], 1

; 127  : 
; 128  :     // Input stream
; 129  :     //
; 130  :     setInputStream(factory, input);

  000d1	48 8b 54 24 40	 mov	 rdx, QWORD PTR input$[rsp]
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000db	e8 00 00 00 00	 call	 setInputStream

; 131  :     
; 132  :     return  factory;

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Toke:

; 133  : 
; 134  : }

  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
antlr3TokenFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontoken.c
;	COMDAT antlr3CommonTokenNew
_TEXT	SEGMENT
token$ = 32
ttype$ = 64
antlr3CommonTokenNew PROC				; COMDAT

; 74   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 75   : 	pANTLR3_COMMON_TOKEN    token;
; 76   : 
; 77   : 	// Create a raw token with the interface installed
; 78   : 	//
; 79   : 	token   = newToken();

  0001c	e8 00 00 00 00	 call	 newToken
  00021	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 80   : 
; 81   : 	if	(token != NULL)

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  0002c	74 14		 je	 SHORT $LN2@antlr3Comm

; 82   : 	{
; 83   : 		token->setType(token, ttype);

  0002e	8b 54 24 40	 mov	 edx, DWORD PTR ttype$[rsp]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0003c	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN2@antlr3Comm:

; 84   : 	}
; 85   : 
; 86   : 	// All good
; 87   : 	//
; 88   : 	return  token;

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]

; 89   : }

  00047	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
antlr3CommonTokenNew ENDP
_TEXT	ENDS
END
