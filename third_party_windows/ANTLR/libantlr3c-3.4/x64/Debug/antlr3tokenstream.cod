; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3CommonTokenStreamSourceNew
PUBLIC	antlr3CommonTokenStreamNew
PUBLIC	antlr3CommonTokenDebugStreamSourceNew
PUBLIC	fillBufferExt
PUBLIC	antlr3TokenStreamNew
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3BitsetOf:PROC
EXTRN	antlr3BitsetList:PROC
EXTRN	antlr3ListNew:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	antlr3IntStreamNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTokenStreamSourceNew DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$antlr3CommonTokenStreamSourceNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTokenStreamNew DD imagerel $LN4
	DD	imagerel $LN4+713
	DD	imagerel $unwind$antlr3CommonTokenStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTokenDebugStreamSourceNew DD imagerel $LN3
	DD	imagerel $LN3+254
	DD	imagerel $unwind$antlr3CommonTokenDebugStreamSourceNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fillBufferExt DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$fillBufferExt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenTypeChannel DD imagerel setTokenTypeChannel
	DD	imagerel setTokenTypeChannel+127
	DD	imagerel $unwind$setTokenTypeChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$discardTokenType DD imagerel discardTokenType
	DD	imagerel discardTokenType+124
	DD	imagerel $unwind$discardTokenType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$discardOffChannel DD imagerel discardOffChannel
	DD	imagerel discardOffChannel+25
	DD	imagerel $unwind$discardOffChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokens DD imagerel getTokens
	DD	imagerel getTokens+66
	DD	imagerel $unwind$getTokens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenRange DD imagerel getTokenRange
	DD	imagerel getTokenRange+70
	DD	imagerel $unwind$getTokenRange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokensSet DD imagerel getTokensSet
	DD	imagerel getTokensSet+477
	DD	imagerel $unwind$getTokensSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokensList DD imagerel getTokensList
	DD	imagerel getTokensList+118
	DD	imagerel $unwind$getTokensList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokensType DD imagerel getTokensType
	DD	imagerel getTokensType+119
	DD	imagerel $unwind$getTokensType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+215
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tokLT DD	imagerel tokLT
	DD	imagerel tokLT+453
	DD	imagerel $unwind$tokLT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgTokLT DD imagerel dbgTokLT
	DD	imagerel dbgTokLT+82
	DD	imagerel $unwind$dbgTokLT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get DD	imagerel get
	DD	imagerel get+82
	DD	imagerel $unwind$get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenSource DD imagerel getTokenSource
	DD	imagerel getTokenSource+16
	DD	imagerel $unwind$getTokenSource
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenSource DD imagerel setTokenSource
	DD	imagerel setTokenSource+26
	DD	imagerel $unwind$setTokenSource
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toString DD imagerel toString
	DD	imagerel toString+110
	DD	imagerel $unwind$toString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStringSS DD imagerel toStringSS
	DD	imagerel toStringSS+302
	DD	imagerel $unwind$toStringSS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStringTT DD imagerel toStringTT
	DD	imagerel toStringTT+128
	DD	imagerel $unwind$toStringTT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setDebugListener DD imagerel setDebugListener
	DD	imagerel setDebugListener+172
	DD	imagerel $unwind$setDebugListener
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consume DD imagerel consume
	DD	imagerel consume+130
	DD	imagerel $unwind$consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgConsume DD imagerel dbgConsume
	DD	imagerel dbgConsume+280
	DD	imagerel $unwind$dbgConsume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LA DD	imagerel _LA
	DD	imagerel _LA+106
	DD	imagerel $unwind$_LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgLA DD	imagerel dbgLA
	DD	imagerel dbgLA+147
	DD	imagerel $unwind$dbgLA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mark DD	imagerel mark
	DD	imagerel mark+67
	DD	imagerel $unwind$mark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgMark DD imagerel dbgMark
	DD	imagerel dbgMark+114
	DD	imagerel $unwind$dbgMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$release DD imagerel release
	DD	imagerel release+13
	DD	imagerel $unwind$release
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$size DD	imagerel size
	DD	imagerel size+111
	DD	imagerel $unwind$size
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tindex DD imagerel tindex
	DD	imagerel tindex+71
	DD	imagerel $unwind$tindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindStream DD imagerel rewindStream
	DD	imagerel rewindStream+60
	DD	imagerel $unwind$rewindStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgRewindStream DD imagerel dbgRewindStream
	DD	imagerel dbgRewindStream+103
	DD	imagerel $unwind$dbgRewindStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindLast DD imagerel rewindLast
	DD	imagerel rewindLast+58
	DD	imagerel $unwind$rewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgRewindLast DD imagerel dbgRewindLast
	DD	imagerel dbgRewindLast+96
	DD	imagerel $unwind$dbgRewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$seek DD	imagerel seek
	DD	imagerel seek+79
	DD	imagerel $unwind$seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgSeek DD imagerel dbgSeek
	DD	imagerel dbgSeek+56
	DD	imagerel $unwind$dbgSeek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getSourceName DD imagerel getSourceName
	DD	imagerel getSourceName+27
	DD	imagerel $unwind$getSourceName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TokenStreamFree DD imagerel antlr3TokenStreamFree
	DD	imagerel antlr3TokenStreamFree+47
	DD	imagerel $unwind$antlr3TokenStreamFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CTSFree DD imagerel antlr3CTSFree
	DD	imagerel antlr3CTSFree+305
	DD	imagerel $unwind$antlr3CTSFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fillBuffer DD imagerel fillBuffer
	DD	imagerel fillBuffer+541
	DD	imagerel $unwind$fillBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$skipOffTokenChannels DD imagerel skipOffTokenChannels
	DD	imagerel skipOffTokenChannels+139
	DD	imagerel $unwind$skipOffTokenChannels
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$skipOffTokenChannelsReverse DD imagerel skipOffTokenChannelsReverse
	DD	imagerel skipOffTokenChannelsReverse+117
	DD	imagerel $unwind$skipOffTokenChannelsReverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LB DD	imagerel LB
	DD	imagerel LB+194
	DD	imagerel $unwind$LB
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TokenStreamNew DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$antlr3TokenStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeInitialHiddenTokens DD imagerel consumeInitialHiddenTokens
	DD	imagerel consumeInitialHiddenTokens+165
	DD	imagerel $unwind$consumeInitialHiddenTokens
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeInitialHiddenTokens DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TokenStreamNew DD 021501H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LB DD	022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skipOffTokenChannelsReverse DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skipOffTokenChannels DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fillBuffer DD 021e01H
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CTSFree DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TokenStreamFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getSourceName DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgSeek DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seek DD	022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgRewindLast DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindLast DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgRewindStream DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindStream DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tindex DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$size DD	021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$release DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgMark DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mark DD	021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgLA DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LA DD	022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgConsume DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consume DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setDebugListener DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStringTT DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStringSS DD 022701H
	DD	0700f9213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toString DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenSource DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenSource DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get DD	022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgTokLT DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tokLT DD 022201H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokensType DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokensList DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokensSet DD 022c01H
	DD	07014b218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenRange DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokens DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$discardOffChannel DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$discardTokenType DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenTypeChannel DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fillBufferExt DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTokenDebugStreamSourceNew DD 022601H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTokenStreamNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTokenStreamSourceNew DD 022101H
	DD	0700a520eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT consumeInitialHiddenTokens
_TEXT	SEGMENT
first$ = 32
i$ = 40
ts$ = 48
tv81 = 56
is$ = 80
consumeInitialHiddenTokens PROC				; COMDAT

; 417  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 418  : 	ANTLR3_MARKER	first;
; 419  : 	ANTLR3_INT32	i;
; 420  : 	pANTLR3_TOKEN_STREAM	ts;
; 421  : 
; 422  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 30	 mov	 QWORD PTR ts$[rsp], rax

; 423  : 	first	= is->index(is);

  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00036	ff 50 40	 call	 QWORD PTR [rax+64]
  00039	48 89 44 24 20	 mov	 QWORD PTR first$[rsp], rax

; 424  : 
; 425  : 	for	(i=0; i<first; i++)

  0003e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN4@consumeIni
$LN2@consumeIni:
  00048	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@consumeIni:
  00052	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00057	48 3b 44 24 20	 cmp	 rax, QWORD PTR first$[rsp]
  0005c	7d 38		 jge	 SHORT $LN3@consumeIni

; 426  : 	{
; 427  : 		ts->debugger->consumeHiddenToken(ts->debugger, ts->get(ts, i));

  0005e	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ts$[rsp]
  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR ts$[rsp]
  0006c	ff 50 30	 call	 QWORD PTR [rax+48]
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ts$[rsp]
  00074	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00078	48 89 4c 24 38	 mov	 QWORD PTR tv81[rsp], rcx
  0007d	48 8b d0	 mov	 rdx, rax
  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR ts$[rsp]
  00085	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00089	48 8b 44 24 38	 mov	 rax, QWORD PTR tv81[rsp]
  0008e	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 428  : 	}

  00094	eb b2		 jmp	 SHORT $LN2@consumeIni
$LN3@consumeIni:

; 429  : 
; 430  : 	ts->initialStreamState = ANTLR3_FALSE;

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR ts$[rsp]
  0009b	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 431  : 
; 432  : }

  0009f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
consumeInitialHiddenTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3TokenStreamNew
_TEXT	SEGMENT
stream$ = 32
antlr3TokenStreamNew PROC				; COMDAT

; 94   : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 0c 00 00 00	 mov	 ecx, 12
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd

; 95   :     pANTLR3_TOKEN_STREAM stream;
; 96   : 
; 97   :     // Memory for the interface structure
; 98   :     //
; 99   :     stream  = (pANTLR3_TOKEN_STREAM) ANTLR3_MALLOC(sizeof(ANTLR3_TOKEN_STREAM));

  00015	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00020	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 100  : 
; 101  :     if	(stream == NULL)

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0002b	75 04		 jne	 SHORT $LN2@antlr3Toke

; 102  :     {
; 103  : 		return	NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 15		 jmp	 SHORT $LN1@antlr3Toke
$LN2@antlr3Toke:

; 104  :     }
; 105  : 
; 106  :     // Install basic API 
; 107  :     //
; 108  :     stream->free    =  antlr3TokenStreamFree;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3TokenStreamFree
  0003d	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 109  : 
; 110  :     
; 111  :     return stream;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Toke:

; 112  : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
antlr3TokenStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT LB
_TEXT	SEGMENT
i$ = 32
n$ = 36
cts$ = 64
k$ = 72
LB	PROC						; COMDAT

; 455  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 456  :     ANTLR3_INT32 i;
; 457  :     ANTLR3_INT32 n;
; 458  : 
; 459  :     if (cts->p == -1)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  00027	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  0002b	75 0a		 jne	 SHORT $LN4@LB

; 460  :     {
; 461  :         fillBuffer(cts);

  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cts$[rsp]
  00032	e8 00 00 00 00	 call	 fillBuffer
$LN4@LB:

; 462  :     }
; 463  :     if (k == 0)

  00037	83 7c 24 48 00	 cmp	 DWORD PTR k$[rsp], 0
  0003c	75 04		 jne	 SHORT $LN5@LB

; 464  :     {
; 465  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 7a		 jmp	 SHORT $LN1@LB
$LN5@LB:

; 466  :     }
; 467  :     if ((cts->p - k) < 0)

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  00047	8b 4c 24 48	 mov	 ecx, DWORD PTR k$[rsp]
  0004b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0004e	2b c1		 sub	 eax, ecx
  00050	85 c0		 test	 eax, eax
  00052	7d 04		 jge	 SHORT $LN6@LB

; 468  :     {
; 469  :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	eb 64		 jmp	 SHORT $LN1@LB
$LN6@LB:

; 470  :     }
; 471  : 
; 472  :     i = cts->p;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  0005d	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00060	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 473  :     n = 1;

  00064	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR n$[rsp], 1
$LN2@LB:

; 474  : 
; 475  :     /* Need to find k good tokens, going backwards, skipping ones that are off channel
; 476  :      */
; 477  :     while (n <= (ANTLR3_INT32) k)

  0006c	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00070	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  00074	7f 22		 jg	 SHORT $LN3@LB

; 478  :     {
; 479  :         /* Skip off-channel tokens
; 480  :          */
; 481  : 
; 482  :         i = skipOffTokenChannelsReverse(cts, i - 1); /* leave p on valid token    */

  00076	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007a	ff c8		 dec	 eax
  0007c	8b d0		 mov	 edx, eax
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cts$[rsp]
  00083	e8 00 00 00 00	 call	 skipOffTokenChannelsReverse
  00088	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 483  :         n++;

  0008c	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 484  :     }

  00096	eb d4		 jmp	 SHORT $LN2@LB
$LN3@LB:

; 485  :     if (i < 0)

  00098	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0009d	7d 04		 jge	 SHORT $LN7@LB

; 486  :     {
; 487  :         return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	eb 19		 jmp	 SHORT $LN1@LB
$LN7@LB:

; 488  :     }
; 489  : 	// Here the token must be in the input vector. Rather then incut
; 490  : 	// function call penalty, we jsut return the pointer directly
; 491  : 	// from the vector
; 492  : 	//
; 493  : 	return  (pANTLR3_COMMON_TOKEN)cts->tokens->elements[i].element;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  000a8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ac	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b1	48 6b c9 10	 imul	 rcx, rcx, 16
  000b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b8	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
$LN1@LB:

; 494  : }

  000bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
LB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT skipOffTokenChannelsReverse
_TEXT	SEGMENT
tok$ = 0
tokenStream$ = 32
x$ = 40
skipOffTokenChannelsReverse PROC			; COMDAT

; 1056 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]
$LN2@skipOffTok:

; 1057 :     pANTLR3_COMMON_TOKEN tok;
; 1058 : 
; 1059 :     while (x >= 0)

  00022	83 7c 24 28 00	 cmp	 DWORD PTR x$[rsp], 0
  00027	7c 42		 jl	 SHORT $LN3@skipOffTok

; 1060 :     {
; 1061 :         tok =  (pANTLR3_COMMON_TOKEN)tokenStream->tokens->elements[x].element;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0002e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00032	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR x$[rsp]
  00037	48 6b c9 10	 imul	 rcx, rcx, 16
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00042	48 89 04 24	 mov	 QWORD PTR tok$[rsp], rax

; 1062 :         
; 1063 :         if ((tok->channel != tokenStream->channel))

  00046	48 8b 04 24	 mov	 rax, QWORD PTR tok$[rsp]
  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0004f	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00052	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  00055	74 0c		 je	 SHORT $LN4@skipOffTok

; 1064 :         {
; 1065 :             x--;

  00057	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  0005b	ff c8		 dec	 eax
  0005d	89 44 24 28	 mov	 DWORD PTR x$[rsp], eax

; 1066 :         }

  00061	eb 06		 jmp	 SHORT $LN5@skipOffTok
$LN4@skipOffTok:

; 1067 :         else
; 1068 :         {
; 1069 :             return x;

  00063	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  00067	eb 06		 jmp	 SHORT $LN1@skipOffTok
$LN5@skipOffTok:

; 1070 :         }
; 1071 :     }

  00069	eb b7		 jmp	 SHORT $LN2@skipOffTok
$LN3@skipOffTok:

; 1072 :     return x;

  0006b	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
$LN1@skipOffTok:

; 1073 : }

  0006f	48 83 c4 10	 add	 rsp, 16
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
skipOffTokenChannelsReverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT skipOffTokenChannels
_TEXT	SEGMENT
n$ = 0
tok$ = 8
tokenStream$ = 32
i$ = 40
skipOffTokenChannels PROC				; COMDAT

; 1032 : skipOffTokenChannels(pANTLR3_COMMON_TOKEN_STREAM tokenStream, ANTLR3_INT32 i) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1033 :     ANTLR3_INT32 n;
; 1034 :     pANTLR3_COMMON_TOKEN tok;
; 1035 : 
; 1036 :     n = tokenStream->tstream->istream->cachedSize;

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00031	89 04 24	 mov	 DWORD PTR n$[rsp], eax
$LN2@skipOffTok:

; 1037 : 
; 1038 :     while (i < n)

  00034	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00037	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0003b	7d 44		 jge	 SHORT $LN3@skipOffTok

; 1039 :     {
; 1040 :         tok =  (pANTLR3_COMMON_TOKEN)tokenStream->tokens->elements[i].element;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00042	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00046	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004b	48 6b c9 10	 imul	 rcx, rcx, 16
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00056	48 89 44 24 08	 mov	 QWORD PTR tok$[rsp], rax

; 1041 : 
; 1042 :         if (tok->channel!= tokenStream->channel)

  0005b	48 8b 44 24 08	 mov	 rax, QWORD PTR tok$[rsp]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00065	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00068	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  0006b	74 0c		 je	 SHORT $LN4@skipOffTok

; 1043 :         {
; 1044 :             i++;

  0006d	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00071	ff c0		 inc	 eax
  00073	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 1045 :         }

  00077	eb 06		 jmp	 SHORT $LN5@skipOffTok
$LN4@skipOffTok:

; 1046 :         else
; 1047 :         {
; 1048 :             return i;

  00079	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0007d	eb 06		 jmp	 SHORT $LN1@skipOffTok
$LN5@skipOffTok:

; 1049 :         }
; 1050 :     }

  0007f	eb b3		 jmp	 SHORT $LN2@skipOffTok
$LN3@skipOffTok:

; 1051 :     return i;

  00081	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
$LN1@skipOffTok:

; 1052 : }

  00085	48 83 c4 10	 add	 rsp, 16
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
skipOffTokenChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT fillBuffer
_TEXT	SEGMENT
index$ = 32
tok$ = 40
discard$ = 48
channelI$ = 56
tv190 = 64
tv189 = 72
tv188 = 80
tv183 = 88
tokenStream$ = 112
fillBuffer PROC						; COMDAT

; 950  : fillBuffer(pANTLR3_COMMON_TOKEN_STREAM tokenStream) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 18 00 00 00	 mov	 ecx, 24
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 951  :     ANTLR3_UINT32 index;
; 952  :     pANTLR3_COMMON_TOKEN tok;
; 953  :     ANTLR3_BOOLEAN discard;
; 954  :     void * channelI;
; 955  : 
; 956  :     /* Start at index 0 of course
; 957  :      */
; 958  :     index = 0;

  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0

; 959  : 
; 960  :     /* Pick out the next token from the token source
; 961  :      * Remember we just get a pointer (reference if you like) here
; 962  :      * and so if we store it anywhere, we don't set any pointers to auto free it.
; 963  :      */
; 964  :     tok = tokenStream->tstream->tokenSource->nextToken(tokenStream->tstream->tokenSource);

  00026	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00039	48 89 4c 24 40	 mov	 QWORD PTR tv190[rsp], rcx
  0003e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR tv190[rsp]
  00046	ff 10		 call	 QWORD PTR [rax]
  00048	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax
$LN2@fillBuffer:

; 965  : 
; 966  :     while (tok != NULL && tok->type != ANTLR3_TOKEN_EOF)

  0004d	48 83 7c 24 28
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00053	0f 84 7d 01 00
	00		 je	 $LN3@fillBuffer
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  0005e	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00061	0f 84 6f 01 00
	00		 je	 $LN3@fillBuffer

; 967  :     {
; 968  :         discard = ANTLR3_FALSE; /* Assume we are not discarding	*/

  00067	c6 44 24 30 00	 mov	 BYTE PTR discard$[rsp], 0

; 969  : 
; 970  :         /* I employ a bit of a trick, or perhaps hack here. Rather than
; 971  :          * store a pointer to a structure in the override map and discard set
; 972  :          * we store the value + 1 cast to a void *. Hence on systems where NULL = (void *)0
; 973  :          * we can distinguish "not being there" from "being channel or type 0"
; 974  :          */
; 975  : 
; 976  :         if (tokenStream->discardSet != NULL
; 977  :             && tokenStream->discardSet->get(tokenStream->discardSet, tok->getType(tok)) != NULL)

  0006c	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00071	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00076	74 42		 je	 SHORT $LN4@fillBuffer
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00082	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00088	8b c0		 mov	 eax, eax
  0008a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0008f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00093	48 89 4c 24 48	 mov	 QWORD PTR tv189[rsp], rcx
  00098	8b d0		 mov	 edx, eax
  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0009f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR tv189[rsp]
  000a8	ff 50 18	 call	 QWORD PTR [rax+24]
  000ab	48 85 c0	 test	 rax, rax
  000ae	74 0a		 je	 SHORT $LN4@fillBuffer

; 978  :         {
; 979  :             discard = ANTLR3_TRUE;

  000b0	c6 44 24 30 01	 mov	 BYTE PTR discard$[rsp], 1

; 980  :         }

  000b5	e9 95 00 00 00	 jmp	 $LN5@fillBuffer
$LN4@fillBuffer:

; 981  :         else if (   tokenStream->discardOffChannel == ANTLR3_TRUE
; 982  :                  && tok->getChannel(tok) != tokenStream->channel

  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  000bf	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  000c3	83 f8 01	 cmp	 eax, 1
  000c6	75 21		 jne	 SHORT $LN6@fillBuffer
  000c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  000cd	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  000d2	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  000d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  000dd	3b 41 28	 cmp	 eax, DWORD PTR [rcx+40]
  000e0	74 07		 je	 SHORT $LN6@fillBuffer

; 983  :                  )
; 984  :         {
; 985  :             discard = ANTLR3_TRUE;

  000e2	c6 44 24 30 01	 mov	 BYTE PTR discard$[rsp], 1

; 986  :         }

  000e7	eb 66		 jmp	 SHORT $LN7@fillBuffer
$LN6@fillBuffer:

; 987  :         else if (tokenStream->channelOverrides != NULL)

  000e9	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  000ee	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000f3	74 5a		 je	 SHORT $LN8@fillBuffer

; 988  :         {
; 989  :             /* See if this type is in the override map
; 990  :              */
; 991  :             channelI = tokenStream->channelOverrides->get(tokenStream->channelOverrides, tok->getType(tok) + 1);

  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  000ff	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00105	ff c0		 inc	 eax
  00107	8b c0		 mov	 eax, eax
  00109	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0010e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00112	48 89 4c 24 50	 mov	 QWORD PTR tv188[rsp], rcx
  00117	8b d0		 mov	 edx, eax
  00119	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0011e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00122	48 8b 44 24 50	 mov	 rax, QWORD PTR tv188[rsp]
  00127	ff 50 18	 call	 QWORD PTR [rax+24]
  0012a	48 89 44 24 38	 mov	 QWORD PTR channelI$[rsp], rax

; 992  : 
; 993  :             if (channelI != NULL)

  0012f	48 83 7c 24 38
	00		 cmp	 QWORD PTR channelI$[rsp], 0
  00135	74 18		 je	 SHORT $LN9@fillBuffer

; 994  :             {
; 995  :                 /* Override found
; 996  :                  */
; 997  :                 tok->setChannel(tok, ANTLR3_UINT32_CAST(channelI) - 1);

  00137	8b 44 24 38	 mov	 eax, DWORD PTR channelI$[rsp]
  0013b	ff c8		 dec	 eax
  0013d	8b d0		 mov	 edx, eax
  0013f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00149	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
$LN9@fillBuffer:
$LN8@fillBuffer:
$LN7@fillBuffer:
$LN5@fillBuffer:

; 998  :             }
; 999  :         }
; 1000 : 
; 1001 :         /* If not discarding it, add it to the list at the current index
; 1002 :          */
; 1003 :         if (discard == ANTLR3_FALSE)

  0014f	0f b6 44 24 30	 movzx	 eax, BYTE PTR discard$[rsp]
  00154	85 c0		 test	 eax, eax
  00156	75 52		 jne	 SHORT $LN10@fillBuffer

; 1004 :         {
; 1005 :             /* Add it, indicating that we will delete it and the table should not
; 1006 :              */
; 1007 :             tok->setTokenIndex(tok, index);

  00158	8b 44 24 20	 mov	 eax, DWORD PTR index$[rsp]
  0015c	8b d0		 mov	 edx, eax
  0015e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00168	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]

; 1008 :             tokenStream->p++;

  0016e	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00173	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00176	ff c0		 inc	 eax
  00178	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0017d	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1009 :             tokenStream->tokens->add(tokenStream->tokens, (void *) tok, NULL);

  00180	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00185	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00189	45 33 c0	 xor	 r8d, r8d
  0018c	48 8b 54 24 28	 mov	 rdx, QWORD PTR tok$[rsp]
  00191	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00196	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0019a	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 1010 :             index++;

  001a0	8b 44 24 20	 mov	 eax, DWORD PTR index$[rsp]
  001a4	ff c0		 inc	 eax
  001a6	89 44 24 20	 mov	 DWORD PTR index$[rsp], eax
$LN10@fillBuffer:

; 1011 :         }
; 1012 : 
; 1013 :         tok = tokenStream->tstream->tokenSource->nextToken(tokenStream->tstream->tokenSource);

  001aa	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  001b7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ba	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001bd	48 89 4c 24 58	 mov	 QWORD PTR tv183[rsp], rcx
  001c2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c5	48 8b 44 24 58	 mov	 rax, QWORD PTR tv183[rsp]
  001ca	ff 10		 call	 QWORD PTR [rax]
  001cc	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax

; 1014 :     }

  001d1	e9 77 fe ff ff	 jmp	 $LN2@fillBuffer
$LN3@fillBuffer:

; 1015 : 
; 1016 :     /* Cache the size so we don't keep doing indirect method calls. We do this as
; 1017 :      * early as possible so that anything after this may utilize the cached value.
; 1018 :      */
; 1019 :     tokenStream->tstream->istream->cachedSize = tokenStream->tokens->count;

  001d6	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  001db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  001e4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001e7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001ee	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1020 : 
; 1021 :     /* Set the consume pointer to the first token that is on our channel
; 1022 :      */
; 1023 :     tokenStream->p = 0;

  001f1	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  001f6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1024 :     tokenStream->p = skipOffTokenChannels(tokenStream, tokenStream->p);

  001fd	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00202	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00205	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0020a	e8 00 00 00 00	 call	 skipOffTokenChannels
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00214	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1025 : 
; 1026 : }

  00217	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0021b	5f		 pop	 rdi
  0021c	c3		 ret	 0
fillBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3CTSFree
_TEXT	SEGMENT
tv143 = 32
stream$ = 64
antlr3CTSFree PROC					; COMDAT

; 122  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 123  : 	// We only free up our subordinate interfaces if they belong
; 124  : 	// to us, otherwise we let whoever owns them deal with them.
; 125  : 	//
; 126  : 	if	(stream->tstream->super == stream)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0002b	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0002f	75 62		 jne	 SHORT $LN2@antlr3CTSF

; 127  : 	{
; 128  : 		if	(stream->tstream->istream->super == stream->tstream)

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00049	75 35		 jne	 SHORT $LN3@antlr3CTSF

; 129  : 		{
; 130  : 			stream->tstream->istream->free(stream->tstream->istream);

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00050	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00058	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0005f	48 89 4c 24 20	 mov	 QWORD PTR tv143[rsp], rcx
  00064	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR tv143[rsp]
  0006d	ff 50 78	 call	 QWORD PTR [rax+120]

; 131  : 			stream->tstream->istream = NULL;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN3@antlr3CTSF:

; 132  : 		}
; 133  : 		stream->tstream->free(stream->tstream);

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0008d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00090	ff 50 68	 call	 QWORD PTR [rax+104]
$LN2@antlr3CTSF:

; 134  : 	}
; 135  : 
; 136  : 	// Now we free our own resources
; 137  : 	//
; 138  : 	if	(stream->tokens != NULL)

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00098	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0009d	74 25		 je	 SHORT $LN4@antlr3CTSF

; 139  : 	{
; 140  : 		stream->tokens->free(stream->tokens);

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000a4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000ad	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b1	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 141  : 		stream->tokens	= NULL;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000bc	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN4@antlr3CTSF:

; 142  : 	}
; 143  : 	if	(stream->discardSet != NULL)

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000c9	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000ce	74 22		 je	 SHORT $LN5@antlr3CTSF

; 144  : 	{
; 145  : 		stream->discardSet->free(stream->discardSet);

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000d5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000de	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000e2	ff 50 08	 call	 QWORD PTR [rax+8]

; 146  : 		stream->discardSet  = NULL;

  000e5	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000ea	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN5@antlr3CTSF:

; 147  : 	}
; 148  : 	if	(stream->channelOverrides != NULL)

  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000f7	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000fc	74 22		 je	 SHORT $LN6@antlr3CTSF

; 149  : 	{
; 150  : 		stream->channelOverrides->free(stream->channelOverrides);

  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00103	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0010c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00110	ff 50 08	 call	 QWORD PTR [rax+8]

; 151  : 		stream->channelOverrides = NULL;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00118	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN6@antlr3CTSF:

; 152  : 	}
; 153  : 
; 154  : 	// Free our memory now
; 155  : 	//
; 156  : 	ANTLR3_FREE(stream);

  00120	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 157  : }

  0012b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012f	5f		 pop	 rdi
  00130	c3		 ret	 0
antlr3CTSFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3TokenStreamFree
_TEXT	SEGMENT
stream$ = 48
antlr3TokenStreamFree PROC				; COMDAT

; 116  : {   

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 117  :     ANTLR3_FREE(stream);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 118  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
antlr3TokenStreamFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getSourceName
_TEXT	SEGMENT
is$ = 16
getSourceName PROC					; COMDAT

; 1084 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1085 : 	// Slightly convoluted as we must trace back to the lexer's input source
; 1086 : 	// via the token source. The streamName that is here is not initialized
; 1087 : 	// because this is a token stream, not a file or string stream, which are the
; 1088 : 	// only things that have a context for a source name.
; 1089 : 	//
; 1090 : 	return ((pANTLR3_TOKEN_STREAM)(is->super))->tokenSource->fileName;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR is$[rsp]
  0000b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]

; 1091 : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
getSourceName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgSeek
_TEXT	SEGMENT
is$ = 48
index$ = 56
dbgSeek	PROC						; COMDAT

; 939  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 940  : 	// TODO: Implement seek in debugger when Ter adds it to Java
; 941  : 	//
; 942  : 	seek(is, index);

  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR index$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  0002d	e8 00 00 00 00	 call	 seek

; 943  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
dbgSeek	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT seek
_TEXT	SEGMENT
cts$ = 0
ts$ = 8
is$ = 32
index$ = 40
seek	PROC						; COMDAT

; 928  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 929  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 930  :     pANTLR3_TOKEN_STREAM	ts;
; 931  : 
; 932  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 08	 mov	 QWORD PTR ts$[rsp], rax

; 933  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR ts$[rsp]
  00036	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003a	48 89 04 24	 mov	 QWORD PTR cts$[rsp], rax

; 934  : 
; 935  :     cts->p  = (ANTLR3_UINT32)index;

  0003e	48 8b 04 24	 mov	 rax, QWORD PTR cts$[rsp]
  00042	8b 4c 24 28	 mov	 ecx, DWORD PTR index$[rsp]
  00046	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 936  : }

  00049	48 83 c4 10	 add	 rsp, 16
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
seek	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgRewindLast
_TEXT	SEGMENT
ts$ = 32
is$ = 64
dbgRewindLast PROC					; COMDAT

; 895  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 896  : 	pANTLR3_TOKEN_STREAM	ts;
; 897  : 
; 898  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 899  : 
; 900  : 	ts->debugger->rewindLast(ts->debugger);

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00031	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0003a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003e	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 901  : 
; 902  :     is->rewind(is, is->lastMarker);

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00049	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00057	ff 50 48	 call	 QWORD PTR [rax+72]

; 903  : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
dbgRewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT rewindLast
_TEXT	SEGMENT
is$ = 48
rewindLast PROC						; COMDAT

; 906  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 907  :     is->rewind(is, is->lastMarker);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00031	ff 50 48	 call	 QWORD PTR [rax+72]

; 908  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgRewindStream
_TEXT	SEGMENT
ts$ = 32
is$ = 64
marker$ = 72
dbgRewindStream PROC					; COMDAT

; 916  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 917  :     pANTLR3_TOKEN_STREAM	ts;
; 918  : 
; 919  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 920  : 
; 921  : 	ts->debugger->rewind(ts->debugger, marker);

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00036	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR marker$[rsp]
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00044	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00048	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 922  : 
; 923  :     is->seek(is, (ANTLR3_UINT32)(marker));

  0004e	8b 44 24 48	 mov	 eax, DWORD PTR marker$[rsp]
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0005e	ff 50 60	 call	 QWORD PTR [rax+96]

; 924  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
dbgRewindStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT rewindStream
_TEXT	SEGMENT
is$ = 48
marker$ = 56
rewindStream PROC					; COMDAT

; 911  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 912  :     is->seek(is, (ANTLR3_UINT32)(marker));

  00023	8b 44 24 38	 mov	 eax, DWORD PTR marker$[rsp]
  00027	8b d0		 mov	 edx, eax
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00033	ff 50 60	 call	 QWORD PTR [rax+96]

; 913  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
rewindStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT tindex
_TEXT	SEGMENT
cts$ = 0
ts$ = 8
is$ = 32
tindex	PROC						; COMDAT

; 883  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 884  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 885  :     pANTLR3_TOKEN_STREAM	ts;
; 886  : 
; 887  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 08	 mov	 QWORD PTR ts$[rsp], rax

; 888  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0002c	48 8b 44 24 08	 mov	 rax, QWORD PTR ts$[rsp]
  00031	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00035	48 89 04 24	 mov	 QWORD PTR cts$[rsp], rax

; 889  : 
; 890  :     return  cts->p;

  00039	48 8b 04 24	 mov	 rax, QWORD PTR cts$[rsp]
  0003d	48 63 40 30	 movsxd	 rax, DWORD PTR [rax+48]

; 891  : }

  00041	48 83 c4 10	 add	 rsp, 16
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
tindex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT size
_TEXT	SEGMENT
cts$ = 0
ts$ = 8
is$ = 32
size	PROC						; COMDAT

; 866  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 867  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 868  :     pANTLR3_TOKEN_STREAM	ts;
; 869  : 
; 870  :     if (is->cachedSize > 0)

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00027	76 0a		 jbe	 SHORT $LN2@size

; 871  :     {
; 872  : 	return  is->cachedSize;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0002e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00031	eb 36		 jmp	 SHORT $LN1@size
$LN2@size:

; 873  :     }
; 874  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00038	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003c	48 89 44 24 08	 mov	 QWORD PTR ts$[rsp], rax

; 875  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR ts$[rsp]
  00046	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004a	48 89 04 24	 mov	 QWORD PTR cts$[rsp], rax

; 876  : 
; 877  :     is->cachedSize =  cts->tokens->count;

  0004e	48 8b 04 24	 mov	 rax, QWORD PTR cts$[rsp]
  00052	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR is$[rsp]
  0005b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0005e	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 878  :     return  is->cachedSize;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00066	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
$LN1@size:

; 879  : }

  00069	48 83 c4 10	 add	 rsp, 16
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
size	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT release
_TEXT	SEGMENT
is$ = 16
mark$ = 24
release	PROC						; COMDAT

; 860  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 861  :     return;
; 862  : }

  0000b	5f		 pop	 rdi
  0000c	c3		 ret	 0
release	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgMark
_TEXT	SEGMENT
ts$ = 32
is$ = 64
dbgMark	PROC						; COMDAT

; 847  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 848  :     pANTLR3_TOKEN_STREAM    ts;
; 849  :    
; 850  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 851  : 	
; 852  : 	is->lastMarker = is->index(is);

  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00036	ff 50 40	 call	 QWORD PTR [rax+64]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0003e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 853  : 	ts->debugger->mark(ts->debugger, is->lastMarker);

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00047	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00050	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00059	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005d	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]

; 854  : 
; 855  :     return  is->lastMarker;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00068	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 856  : }

  0006c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
dbgMark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT mark
_TEXT	SEGMENT
is$ = 48
mark	PROC						; COMDAT

; 838  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 839  :     is->lastMarker = is->index(is);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00028	ff 50 40	 call	 QWORD PTR [rax+64]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  00030	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 840  :     return  is->lastMarker;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 841  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgLA
_TEXT	SEGMENT
ts$ = 32
tv81 = 40
is$ = 64
i$ = 72
dbgLA	PROC						; COMDAT

; 823  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 824  :     pANTLR3_TOKEN_STREAM    ts;
; 825  :    
; 826  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 827  : 
; 828  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00035	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00039	83 f8 01	 cmp	 eax, 1
  0003c	75 0a		 jne	 SHORT $LN2@dbgLA

; 829  : 	{
; 830  : 		consumeInitialHiddenTokens(is);

  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00043	e8 00 00 00 00	 call	 consumeInitialHiddenTokens
$LN2@dbgLA:

; 831  : 	}
; 832  : 	ts->debugger->LT(ts->debugger, i, tokLT(ts, i));

  00048	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00051	e8 00 00 00 00	 call	 tokLT
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0005b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005f	48 89 4c 24 28	 mov	 QWORD PTR tv81[rsp], rcx
  00064	4c 8b c0	 mov	 r8, rax
  00067	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00070	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR tv81[rsp]
  00079	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 833  : 	return	_LA(is, i);

  0007f	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00088	e8 00 00 00 00	 call	 _LA

; 834  : }

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
dbgLA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT _LA
_TEXT	SEGMENT
ts$ = 32
tok$ = 40
is$ = 64
i$ = 72
_LA	PROC						; COMDAT

; 801  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 802  : 	pANTLR3_TOKEN_STREAM    ts;
; 803  : 	pANTLR3_COMMON_TOKEN    tok;
; 804  : 
; 805  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 806  : 
; 807  : 	tok	    =  ts->_LT(ts, i);

  00030	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  0003e	ff 50 28	 call	 QWORD PTR [rax+40]
  00041	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax

; 808  : 
; 809  : 	if	(tok != NULL)

  00046	48 83 7c 24 28
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0004c	74 14		 je	 SHORT $LN2@LA

; 810  : 	{
; 811  : 		return	tok->getType(tok);

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00058	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0005e	eb 04		 jmp	 SHORT $LN1@LA

; 812  : 	}

  00060	eb 02		 jmp	 SHORT $LN3@LA
$LN2@LA:

; 813  : 	else
; 814  : 	{
; 815  : 		return	ANTLR3_TOKEN_INVALID;

  00062	33 c0		 xor	 eax, eax
$LN3@LA:
$LN1@LA:

; 816  : 	}
; 817  : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
_LA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgConsume
_TEXT	SEGMENT
ts$ = 32
a$ = 40
b$ = 48
t$ = 56
i$1 = 64
tv131 = 72
is$ = 96
dbgConsume PROC						; COMDAT

; 621  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 622  : 	pANTLR3_TOKEN_STREAM	ts;
; 623  : 	ANTLR3_MARKER			a;
; 624  : 	ANTLR3_MARKER			b;
; 625  : 	pANTLR3_COMMON_TOKEN	t;
; 626  : 
; 627  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 628  : 
; 629  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00031	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 0a		 jne	 SHORT $LN5@dbgConsume

; 630  : 	{
; 631  : 		consumeInitialHiddenTokens(is);

  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  0003f	e8 00 00 00 00	 call	 consumeInitialHiddenTokens
$LN5@dbgConsume:

; 632  : 	}
; 633  : 	
; 634  : 	a = is->index(is);		// Where are we right now?

  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  00049	48 8b 44 24 60	 mov	 rax, QWORD PTR is$[rsp]
  0004e	ff 50 40	 call	 QWORD PTR [rax+64]
  00051	48 89 44 24 28	 mov	 QWORD PTR a$[rsp], rax

; 635  : 	t = ts->_LT(ts, 1);		// Current token from stream

  00056	ba 01 00 00 00	 mov	 edx, 1
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00065	ff 50 28	 call	 QWORD PTR [rax+40]
  00068	48 89 44 24 38	 mov	 QWORD PTR t$[rsp], rax

; 636  : 
; 637  : 	consume(is);			// Standard consumer

  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  00072	e8 00 00 00 00	 call	 consume

; 638  : 
; 639  : 	b = is->index(is);		// Where are we after consuming 1 on channel token?

  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR is$[rsp]
  00081	ff 50 40	 call	 QWORD PTR [rax+64]
  00084	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax

; 640  : 
; 641  : 	ts->debugger->consumeToken(ts->debugger, t);	// Tell the debugger that we consumed the first token

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  0008e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00092	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0009c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a0	ff 50 78	 call	 QWORD PTR [rax+120]

; 642  : 
; 643  : 	if	(b>a+1)

  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  000a8	48 ff c0	 inc	 rax
  000ab	48 39 44 24 30	 cmp	 QWORD PTR b$[rsp], rax
  000b0	7e 60		 jle	 SHORT $LN6@dbgConsume

; 644  : 	{
; 645  : 		// The standard consume caused the index to advance by more than 1,
; 646  : 		// which can only happen if it skipped some off-channel tokens.
; 647  : 		// we need to tell the debugger about those tokens.
; 648  : 		//
; 649  : 		ANTLR3_MARKER	i;
; 650  : 
; 651  : 		for	(i = a+1; i<b; i++)

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  000b7	48 ff c0	 inc	 rax
  000ba	48 89 44 24 40	 mov	 QWORD PTR i$1[rsp], rax
  000bf	eb 0d		 jmp	 SHORT $LN4@dbgConsume
$LN2@dbgConsume:
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR i$1[rsp]
  000c6	48 ff c0	 inc	 rax
  000c9	48 89 44 24 40	 mov	 QWORD PTR i$1[rsp], rax
$LN4@dbgConsume:
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  000d3	48 39 44 24 40	 cmp	 QWORD PTR i$1[rsp], rax
  000d8	7d 38		 jge	 SHORT $LN3@dbgConsume

; 652  : 		{
; 653  : 			ts->debugger->consumeHiddenToken(ts->debugger, ts->get(ts, (ANTLR3_UINT32)i));

  000da	8b 54 24 40	 mov	 edx, DWORD PTR i$1[rsp]
  000de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  000e8	ff 50 30	 call	 QWORD PTR [rax+48]
  000eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  000f0	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000f4	48 89 4c 24 48	 mov	 QWORD PTR tv131[rsp], rcx
  000f9	48 8b d0	 mov	 rdx, rax
  000fc	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00101	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR tv131[rsp]
  0010a	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 654  : 		}

  00110	eb af		 jmp	 SHORT $LN2@dbgConsume
$LN3@dbgConsume:
$LN6@dbgConsume:

; 655  : 
; 656  : 	}
; 657  : }

  00112	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
dbgConsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT consume
_TEXT	SEGMENT
cts$ = 32
ts$ = 40
is$ = 64
consume	PROC						; COMDAT

; 601  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 602  : 	pANTLR3_COMMON_TOKEN_STREAM cts;
; 603  : 	pANTLR3_TOKEN_STREAM	ts;
; 604  : 
; 605  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 28	 mov	 QWORD PTR ts$[rsp], rax

; 606  : 	cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR ts$[rsp]
  00031	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00035	48 89 44 24 20	 mov	 QWORD PTR cts$[rsp], rax

; 607  : 
; 608  :         if	((ANTLR3_UINT32)cts->p < cts->tokens->count)

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR cts$[rsp]
  0003f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  00048	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004b	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  0004e	73 2c		 jae	 SHORT $LN2@consume

; 609  : 	{
; 610  : 		cts->p++;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR cts$[rsp]
  00055	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00058	ff c0		 inc	 eax
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  0005f	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 611  : 		cts->p	= skipOffTokenChannels(cts, cts->p);

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR cts$[rsp]
  00067	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  0006f	e8 00 00 00 00	 call	 skipOffTokenChannels
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  00079	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN2@consume:

; 612  : 	}
; 613  : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
consume	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT setDebugListener
_TEXT	SEGMENT
ts$ = 16
debugger$ = 24
setDebugListener PROC					; COMDAT

; 329  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 330  : 		// Install the debugger object
; 331  : 	//
; 332  : 	ts->debugger = debugger;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR debugger$[rsp]
  00015	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 333  : 
; 334  : 	// Override standard token stream methods with debugging versions
; 335  : 	//
; 336  : 	ts->initialStreamState	= ANTLR3_FALSE;

  00019	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  0001e	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 337  : 
; 338  : 	ts->_LT				= dbgTokLT;

  00022	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgTokLT
  0002e	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 339  : 
; 340  : 	ts->istream->consume		= dbgConsume;

  00032	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00037	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgConsume
  00042	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 341  : 	ts->istream->_LA			= dbgLA;

  00046	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  0004b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgLA
  00056	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 342  : 	ts->istream->mark			= dbgMark;

  0005a	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  0005f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgMark
  0006a	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 343  : 	ts->istream->rewind			= dbgRewindStream;

  0006e	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00073	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgRewindStream
  0007e	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 344  : 	ts->istream->rewindLast		= dbgRewindLast;

  00082	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00087	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgRewindLast
  00092	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 345  : 	ts->istream->seek			= dbgSeek;

  00096	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  0009b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSeek
  000a6	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 346  : }

  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
setDebugListener ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT toStringTT
_TEXT	SEGMENT
tv69 = 32
ts$ = 64
start$ = 72
stop$ = 80
toStringTT PROC						; COMDAT

; 581  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 582  : 	if	(start != NULL && stop != NULL)

  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR start$[rsp], 0
  0002e	74 48		 je	 SHORT $LN2@toStringTT
  00030	48 83 7c 24 50
	00		 cmp	 QWORD PTR stop$[rsp], 0
  00036	74 40		 je	 SHORT $LN2@toStringTT

; 583  : 	{
; 584  : 		return	ts->toStringSS(ts, (ANTLR3_UINT32)start->getTokenIndex(start), (ANTLR3_UINT32)stop->getTokenIndex(stop));

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR stop$[rsp]
  00042	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00048	48 89 44 24 20	 mov	 QWORD PTR tv69[rsp], rax
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  00052	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00057	ff 92 d0 00 00
	00		 call	 QWORD PTR [rdx+208]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv69[rsp]
  00062	44 8b c1	 mov	 r8d, ecx
  00065	8b d0		 mov	 edx, eax
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ts$[rsp]
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR ts$[rsp]
  00071	ff 50 50	 call	 QWORD PTR [rax+80]
  00074	eb 04		 jmp	 SHORT $LN1@toStringTT

; 585  : 	}

  00076	eb 02		 jmp	 SHORT $LN3@toStringTT
$LN2@toStringTT:

; 586  : 	else
; 587  : 	{
; 588  : 		return	NULL;

  00078	33 c0		 xor	 eax, eax
$LN3@toStringTT:
$LN1@toStringTT:

; 589  : 	}
; 590  : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
toStringTT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT toStringSS
_TEXT	SEGMENT
string$ = 32
tsource$ = 40
tok$ = 48
i$ = 56
cts$ = 64
ts$ = 96
start$ = 104
stop$ = 112
toStringSS PROC						; COMDAT

; 536  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 14 00 00 00	 mov	 ecx, 20
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 537  :     pANTLR3_STRING string;
; 538  :     pANTLR3_TOKEN_SOURCE tsource;
; 539  :     pANTLR3_COMMON_TOKEN tok;
; 540  :     ANTLR3_UINT32 i;
; 541  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 542  : 
; 543  :     cts = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR ts$[rsp]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00030	48 89 44 24 40	 mov	 QWORD PTR cts$[rsp], rax

; 544  : 
; 545  :     if (cts->p == -1)

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  0003a	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  0003e	75 0a		 jne	 SHORT $LN5@toStringSS

; 546  :     {
; 547  :         fillBuffer(cts);

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cts$[rsp]
  00045	e8 00 00 00 00	 call	 fillBuffer
$LN5@toStringSS:

; 548  :     }
; 549  :     if (stop >= ts->istream->size(ts->istream))

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR ts$[rsp]
  0004f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ts$[rsp]
  00058	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0005c	ff 50 68	 call	 QWORD PTR [rax+104]
  0005f	39 44 24 70	 cmp	 DWORD PTR stop$[rsp], eax
  00063	72 1b		 jb	 SHORT $LN6@toStringSS

; 550  :     {
; 551  :         stop = ts->istream->size(ts->istream) - 1;

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR ts$[rsp]
  0006a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ts$[rsp]
  00073	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00077	ff 50 68	 call	 QWORD PTR [rax+104]
  0007a	ff c8		 dec	 eax
  0007c	89 44 24 70	 mov	 DWORD PTR stop$[rsp], eax
$LN6@toStringSS:

; 552  :     }
; 553  : 
; 554  :     /* Who is giving us these tokens?
; 555  :      */
; 556  :     tsource = ts->getTokenSource(ts);

  00080	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ts$[rsp]
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR ts$[rsp]
  0008a	ff 50 38	 call	 QWORD PTR [rax+56]
  0008d	48 89 44 24 28	 mov	 QWORD PTR tsource$[rsp], rax

; 557  : 
; 558  :     if (tsource != NULL && cts->tokens != NULL)

  00092	48 83 7c 24 28
	00		 cmp	 QWORD PTR tsource$[rsp], 0
  00098	0f 84 88 00 00
	00		 je	 $LN7@toStringSS
  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR cts$[rsp]
  000a3	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000a8	74 7c		 je	 SHORT $LN7@toStringSS

; 559  :     {
; 560  :         /* Finally, let's get a string
; 561  :          */
; 562  :         string = tsource->strFactory->newRaw(tsource->strFactory);

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR tsource$[rsp]
  000af	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsource$[rsp]
  000b8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000bc	ff 50 10	 call	 QWORD PTR [rax+16]
  000bf	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 563  : 
; 564  :         for (i = start; i <= stop; i++)

  000c4	8b 44 24 68	 mov	 eax, DWORD PTR start$[rsp]
  000c8	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
  000cc	eb 0a		 jmp	 SHORT $LN4@toStringSS
$LN2@toStringSS:
  000ce	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@toStringSS:
  000d8	8b 44 24 70	 mov	 eax, DWORD PTR stop$[rsp]
  000dc	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  000e0	77 3d		 ja	 SHORT $LN3@toStringSS

; 565  :         {
; 566  :             tok = ts->get(ts, i);

  000e2	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ts$[rsp]
  000eb	48 8b 44 24 60	 mov	 rax, QWORD PTR ts$[rsp]
  000f0	ff 50 30	 call	 QWORD PTR [rax+48]
  000f3	48 89 44 24 30	 mov	 QWORD PTR tok$[rsp], rax

; 567  :             if (tok != NULL)

  000f8	48 83 7c 24 30
	00		 cmp	 QWORD PTR tok$[rsp], 0
  000fe	74 1d		 je	 SHORT $LN8@toStringSS

; 568  :             {
; 569  :                 string->appendS(string, tok->getText(tok));

  00100	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0010a	ff 50 78	 call	 QWORD PTR [rax+120]
  0010d	48 8b d0	 mov	 rdx, rax
  00110	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0011a	ff 50 58	 call	 QWORD PTR [rax+88]
$LN8@toStringSS:

; 570  :             }
; 571  :         }

  0011d	eb af		 jmp	 SHORT $LN2@toStringSS
$LN3@toStringSS:

; 572  : 
; 573  :         return string;

  0011f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00124	eb 02		 jmp	 SHORT $LN1@toStringSS
$LN7@toStringSS:

; 574  :     }
; 575  :     return NULL;

  00126	33 c0		 xor	 eax, eax
$LN1@toStringSS:

; 576  : 
; 577  : }

  00128	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0012c	5f		 pop	 rdi
  0012d	c3		 ret	 0
toStringSS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT toString
_TEXT	SEGMENT
cts$ = 32
ts$ = 64
toString PROC						; COMDAT

; 521  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 522  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 523  : 
; 524  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR ts$[rsp]
  00023	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00027	48 89 44 24 20	 mov	 QWORD PTR cts$[rsp], rax

; 525  : 
; 526  :     if	(cts->p == -1)

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR cts$[rsp]
  00031	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  00035	75 0a		 jne	 SHORT $LN2@toString

; 527  :     {
; 528  : 	fillBuffer(cts);

  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  0003c	e8 00 00 00 00	 call	 fillBuffer
$LN2@toString:

; 529  :     }
; 530  : 
; 531  :     return  ts->toStringSS(ts, 0, ts->istream->size(ts->istream));

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR ts$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ts$[rsp]
  0004f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00053	ff 50 68	 call	 QWORD PTR [rax+104]
  00056	44 8b c0	 mov	 r8d, eax
  00059	33 d2		 xor	 edx, edx
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ts$[rsp]
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR ts$[rsp]
  00065	ff 50 50	 call	 QWORD PTR [rax+80]

; 532  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT setTokenSource
_TEXT	SEGMENT
ts$ = 16
tokenSource$ = 24
setTokenSource PROC					; COMDAT

; 515  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 516  :     ts->tokenSource	= tokenSource;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tokenSource$[rsp]
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 517  : }

  00018	5f		 pop	 rdi
  00019	c3		 ret	 0
setTokenSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokenSource
_TEXT	SEGMENT
ts$ = 16
getTokenSource PROC					; COMDAT

; 508  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 509  :     return  ts->tokenSource;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 510  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getTokenSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT get
_TEXT	SEGMENT
cts$ = 32
ts$ = 64
i$ = 72
get	PROC						; COMDAT

; 498  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 499  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 500  : 
; 501  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR ts$[rsp]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 44 24 20	 mov	 QWORD PTR cts$[rsp], rax

; 502  : 
; 503  :     return  (pANTLR3_COMMON_TOKEN)(cts->tokens->get(cts->tokens, i));  /* Token index is zero based but vectors are 1 based */

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR cts$[rsp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cts$[rsp]
  00042	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00046	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 504  : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
get	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT dbgTokLT
_TEXT	SEGMENT
ts$ = 48
k$ = 56
dbgTokLT PROC						; COMDAT

; 438  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 439  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR ts$[rsp]
  00027	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 0e		 jne	 SHORT $LN2@dbgTokLT

; 440  : 	{
; 441  : 		consumeInitialHiddenTokens(ts->istream);

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR ts$[rsp]
  00035	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00039	e8 00 00 00 00	 call	 consumeInitialHiddenTokens
$LN2@dbgTokLT:

; 442  : 	}
; 443  : 	return tokLT(ts, k);

  0003e	8b 54 24 38	 mov	 edx, DWORD PTR k$[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ts$[rsp]
  00047	e8 00 00 00 00	 call	 tokLT

; 444  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
dbgTokLT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT tokLT
_TEXT	SEGMENT
i$ = 32
n$ = 36
cts$ = 40
teof$1 = 48
teof$2 = 56
ts$ = 80
k$ = 88
tokLT	PROC						; COMDAT

; 353  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 354  : 	ANTLR3_INT32    i;
; 355  : 	ANTLR3_INT32    n;
; 356  : 	pANTLR3_COMMON_TOKEN_STREAM cts;
; 357  : 
; 358  : 	cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 44 24 28	 mov	 QWORD PTR cts$[rsp], rax

; 359  : 
; 360  :         if	(k < 0)

  00030	83 7c 24 58 00	 cmp	 DWORD PTR k$[rsp], 0
  00035	7d 17		 jge	 SHORT $LN4@tokLT

; 361  : 	{
; 362  : 		return LB(cts, -k);

  00037	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  0003b	f7 d8		 neg	 eax
  0003d	8b d0		 mov	 edx, eax
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cts$[rsp]
  00044	e8 00 00 00 00	 call	 LB
  00049	e9 71 01 00 00	 jmp	 $LN1@tokLT
$LN4@tokLT:

; 363  : 	}
; 364  : 
; 365  : 	if	(cts->p == -1)

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR cts$[rsp]
  00053	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  00057	75 0a		 jne	 SHORT $LN5@tokLT

; 366  : 	{
; 367  : 		fillBuffer(cts);

  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cts$[rsp]
  0005e	e8 00 00 00 00	 call	 fillBuffer
$LN5@tokLT:

; 368  : 	}
; 369  : 
; 370  :         // Here we used to check for k == 0 and return 0, but this seems
; 371  :         // a superfluous check to me. LT(k=0) is therefore just undefined
; 372  :         // and we won't waste the clock cycles on the check
; 373  :         //
; 374  : 
; 375  : 	if	((cts->p + k - 1) >= (ANTLR3_INT32)ts->istream->cachedSize)

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR cts$[rsp]
  00068	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0006b	8b 4c 24 58	 mov	 ecx, DWORD PTR k$[rsp]
  0006f	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ts$[rsp]
  00078	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007c	3b 41 70	 cmp	 eax, DWORD PTR [rcx+112]
  0007f	7c 6b		 jl	 SHORT $LN6@tokLT

; 376  : 	{
; 377  : 		pANTLR3_COMMON_TOKEN    teof = &(ts->tokenSource->eofToken);

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00086	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00089	48 83 c0 10	 add	 rax, 16
  0008d	48 89 44 24 30	 mov	 QWORD PTR teof$1[rsp], rax

; 378  : 
; 379  : 		teof->setStartIndex (teof, ts->istream->index	    (ts->istream));

  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00097	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ts$[rsp]
  000a0	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a4	ff 50 40	 call	 QWORD PTR [rax+64]
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR teof$1[rsp]
  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR teof$1[rsp]
  000b4	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 380  : 		teof->setStopIndex  (teof, ts->istream->index	    (ts->istream));

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  000bf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ts$[rsp]
  000c8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000cc	ff 50 40	 call	 QWORD PTR [rax+64]
  000cf	48 8b d0	 mov	 rdx, rax
  000d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR teof$1[rsp]
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR teof$1[rsp]
  000dc	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]

; 381  : 		return  teof;

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR teof$1[rsp]
  000e7	e9 d3 00 00 00	 jmp	 $LN1@tokLT
$LN6@tokLT:

; 382  : 	}
; 383  : 
; 384  : 	i	= cts->p;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR cts$[rsp]
  000f1	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000f4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 385  : 	n	= 1;

  000f8	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR n$[rsp], 1
$LN2@tokLT:

; 386  : 
; 387  : 	/* Need to find k good tokens, skipping ones that are off channel
; 388  : 	*/
; 389  : 	while   ( n < k)

  00100	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  00104	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  00108	7d 22		 jge	 SHORT $LN3@tokLT

; 390  : 	{
; 391  : 		/* Skip off-channel tokens */
; 392  : 		i = skipOffTokenChannels(cts, i+1); /* leave p on valid token    */

  0010a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0010e	ff c0		 inc	 eax
  00110	8b d0		 mov	 edx, eax
  00112	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cts$[rsp]
  00117	e8 00 00 00 00	 call	 skipOffTokenChannels
  0011c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 393  : 		n++;

  00120	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00124	ff c0		 inc	 eax
  00126	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 394  : 	}

  0012a	eb d4		 jmp	 SHORT $LN2@tokLT
$LN3@tokLT:

; 395  : 	if	( (ANTLR3_UINT32) i >= ts->istream->cachedSize)

  0012c	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00131	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00135	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00138	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0013c	72 68		 jb	 SHORT $LN7@tokLT

; 396  : 	{
; 397  : 		pANTLR3_COMMON_TOKEN    teof = &(ts->tokenSource->eofToken);

  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00143	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00146	48 83 c0 10	 add	 rax, 16
  0014a	48 89 44 24 38	 mov	 QWORD PTR teof$2[rsp], rax

; 398  : 
; 399  : 		teof->setStartIndex (teof, ts->istream->index(ts->istream));

  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  00154	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00158	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ts$[rsp]
  0015d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00161	ff 50 40	 call	 QWORD PTR [rax+64]
  00164	48 8b d0	 mov	 rdx, rax
  00167	48 8b 4c 24 38	 mov	 rcx, QWORD PTR teof$2[rsp]
  0016c	48 8b 44 24 38	 mov	 rax, QWORD PTR teof$2[rsp]
  00171	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 400  : 		teof->setStopIndex  (teof, ts->istream->index(ts->istream));

  00177	48 8b 44 24 50	 mov	 rax, QWORD PTR ts$[rsp]
  0017c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00180	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ts$[rsp]
  00185	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00189	ff 50 40	 call	 QWORD PTR [rax+64]
  0018c	48 8b d0	 mov	 rdx, rax
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR teof$2[rsp]
  00194	48 8b 44 24 38	 mov	 rax, QWORD PTR teof$2[rsp]
  00199	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]

; 401  : 		return  teof;

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR teof$2[rsp]
  001a4	eb 19		 jmp	 SHORT $LN1@tokLT
$LN7@tokLT:

; 402  : 	}
; 403  : 
; 404  : 	// Here the token must be in the input vector. Rather then incur
; 405  : 	// function call penalty, we just return the pointer directly
; 406  : 	// from the vector
; 407  : 	//
; 408  : 	return  (pANTLR3_COMMON_TOKEN)cts->tokens->elements[i].element;

  001a6	48 8b 44 24 28	 mov	 rax, QWORD PTR cts$[rsp]
  001ab	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001b4	48 6b c9 10	 imul	 rcx, rcx, 16
  001b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bb	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
$LN1@tokLT:

; 409  : 	//return  (pANTLR3_COMMON_TOKEN)cts->tokens->get(cts->tokens, i);
; 410  : }

  001bf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c3	5f		 pop	 rdi
  001c4	c3		 ret	 0
tokLT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT reset
_TEXT	SEGMENT
cts$ = 48
reset	PROC						; COMDAT

; 164  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 165  : 
; 166  :     // Free any resources that ar most like specifc to the
; 167  :     // run we just did.
; 168  :     //
; 169  :     if	(cts->discardSet != NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  00023	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00028	74 22		 je	 SHORT $LN2@reset

; 170  :     {
; 171  :         cts->discardSet->free(cts->discardSet);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  0002f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cts$[rsp]
  00038	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0003c	ff 50 08	 call	 QWORD PTR [rax+8]

; 172  :         cts->discardSet  = NULL;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  00044	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN2@reset:

; 173  :     }
; 174  :     if	(cts->channelOverrides != NULL)

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  00051	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00056	74 22		 je	 SHORT $LN3@reset

; 175  :     {
; 176  :         cts->channelOverrides->free(cts->channelOverrides);

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  0005d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cts$[rsp]
  00066	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0006a	ff 50 08	 call	 QWORD PTR [rax+8]

; 177  :         cts->channelOverrides = NULL;

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  00072	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN3@reset:

; 178  :     }
; 179  : 
; 180  :     // Now, if there were any existing tokens in the stream,
; 181  :     // then we just reset the vector count so that it starts
; 182  :     // again. We must traverse the entries unfortunately as
; 183  :     // there may be free pointers for custom token types and
; 184  :     // so on. However that is just a quick NULL check on the
; 185  :     // vector entries.
; 186  :     //
; 187  :     if	(cts->tokens != NULL)

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  0007f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00084	74 1a		 je	 SHORT $LN4@reset

; 188  :     {
; 189  :         cts->tokens->clear(cts->tokens);

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  0008b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cts$[rsp]
  00094	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00098	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 190  :     }

  0009e	eb 10		 jmp	 SHORT $LN5@reset
$LN4@reset:

; 191  :     else
; 192  :     {
; 193  :         /* Install the token tracking tables
; 194  :          */
; 195  :         cts->tokens  = antlr3VectorNew(0);

  000a0	33 c9		 xor	 ecx, ecx
  000a2	e8 00 00 00 00	 call	 antlr3VectorNew
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cts$[rsp]
  000ac	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN5@reset:

; 196  :     }
; 197  : 
; 198  :     // Reset to defaults
; 199  :     //
; 200  :     cts->discardOffChannel  = ANTLR3_FALSE;

  000b0	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  000b5	c6 40 2c 00	 mov	 BYTE PTR [rax+44], 0

; 201  :     cts->channel            = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  000be	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 202  :     cts->p	            = -1;

  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR cts$[rsp]
  000ca	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [rax+48], -1

; 203  : }

  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokensType
_TEXT	SEGMENT
bitSet$ = 32
newlist$ = 40
tokenStream$ = 64
start$ = 72
stop$ = 80
type$ = 88
getTokensType PROC					; COMDAT

; 787  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 788  :     pANTLR3_BITSET  bitSet;
; 789  :     pANTLR3_LIST    newlist;
; 790  : 
; 791  :     bitSet  = antlr3BitsetOf(type, -1);

  0002c	ba ff ff ff ff	 mov	 edx, -1
  00031	8b 4c 24 58	 mov	 ecx, DWORD PTR type$[rsp]
  00035	e8 00 00 00 00	 call	 antlr3BitsetOf
  0003a	48 89 44 24 20	 mov	 QWORD PTR bitSet$[rsp], rax

; 792  :     newlist = tokenStream->getTokensSet(tokenStream, start, stop, bitSet);

  0003f	4c 8b 4c 24 20	 mov	 r9, QWORD PTR bitSet$[rsp]
  00044	44 8b 44 24 50	 mov	 r8d, DWORD PTR stop$[rsp]
  00049	8b 54 24 48	 mov	 edx, DWORD PTR start$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00057	ff 50 60	 call	 QWORD PTR [rax+96]
  0005a	48 89 44 24 28	 mov	 QWORD PTR newlist$[rsp], rax

; 793  : 
; 794  :     bitSet->free(bitSet);

  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitSet$[rsp]
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR bitSet$[rsp]
  00069	ff 50 70	 call	 QWORD PTR [rax+112]

; 795  : 
; 796  :     return  newlist;

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR newlist$[rsp]

; 797  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
getTokensType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokensList
_TEXT	SEGMENT
bitSet$ = 32
newlist$ = 40
tokenStream$ = 64
start$ = 72
stop$ = 80
list$ = 88
getTokensList PROC					; COMDAT

; 771  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 772  :     pANTLR3_BITSET  bitSet;
; 773  :     pANTLR3_LIST    newlist;
; 774  : 
; 775  :     bitSet  = antlr3BitsetList(list->table);

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR list$[rsp]
  00031	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00034	e8 00 00 00 00	 call	 antlr3BitsetList
  00039	48 89 44 24 20	 mov	 QWORD PTR bitSet$[rsp], rax

; 776  : 
; 777  :     newlist    = tokenStream->getTokensSet(tokenStream, start, stop, bitSet);

  0003e	4c 8b 4c 24 20	 mov	 r9, QWORD PTR bitSet$[rsp]
  00043	44 8b 44 24 50	 mov	 r8d, DWORD PTR stop$[rsp]
  00048	8b 54 24 48	 mov	 edx, DWORD PTR start$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00056	ff 50 60	 call	 QWORD PTR [rax+96]
  00059	48 89 44 24 28	 mov	 QWORD PTR newlist$[rsp], rax

; 778  : 
; 779  :     bitSet->free(bitSet);

  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitSet$[rsp]
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR bitSet$[rsp]
  00068	ff 50 70	 call	 QWORD PTR [rax+112]

; 780  : 
; 781  :     return  newlist;

  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR newlist$[rsp]

; 782  : 
; 783  : }

  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
getTokensList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokensSet
_TEXT	SEGMENT
filteredList$ = 32
i$ = 40
n$ = 44
tok$ = 48
tv165 = 56
tv162 = 64
tv159 = 72
tv139 = 80
tv149 = 84
tokenStream$ = 112
start$ = 120
stop$ = 128
types$ = 136
getTokensSet PROC					; COMDAT

; 721  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 18 00 00 00	 mov	 ecx, 24
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 722  :     pANTLR3_LIST	    filteredList;
; 723  :     ANTLR3_UINT32	    i;
; 724  :     ANTLR3_UINT32	    n;
; 725  :     pANTLR3_COMMON_TOKEN    tok;
; 726  : 
; 727  :     if	(tokenStream->p == -1)

  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00031	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  00035	75 0a		 jne	 SHORT $LN5@getTokensS

; 728  :     {
; 729  : 	fillBuffer(tokenStream);

  00037	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0003c	e8 00 00 00 00	 call	 fillBuffer
$LN5@getTokensS:

; 730  :     }
; 731  :     if	(stop > tokenStream->tstream->istream->size(tokenStream->tstream->istream))

  00041	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00055	48 89 4c 24 38	 mov	 QWORD PTR tv165[rsp], rcx
  0005a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0005e	48 8b 44 24 38	 mov	 rax, QWORD PTR tv165[rsp]
  00063	ff 50 68	 call	 QWORD PTR [rax+104]
  00066	39 84 24 80 00
	00 00		 cmp	 DWORD PTR stop$[rsp], eax
  0006d	76 2c		 jbe	 SHORT $LN6@getTokensS

; 732  :     {
; 733  : 	stop = tokenStream->tstream->istream->size(tokenStream->tstream->istream);

  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00074	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00083	48 89 4c 24 40	 mov	 QWORD PTR tv162[rsp], rcx
  00088	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR tv162[rsp]
  00091	ff 50 68	 call	 QWORD PTR [rax+104]
  00094	89 84 24 80 00
	00 00		 mov	 DWORD PTR stop$[rsp], eax
$LN6@getTokensS:

; 734  :     }
; 735  :     if	(start > stop)

  0009b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR stop$[rsp]
  000a2	39 44 24 78	 cmp	 DWORD PTR start$[rsp], eax
  000a6	76 07		 jbe	 SHORT $LN7@getTokensS

; 736  :     {
; 737  : 	return NULL;

  000a8	33 c0		 xor	 eax, eax
  000aa	e9 28 01 00 00	 jmp	 $LN1@getTokensS
$LN7@getTokensS:

; 738  :     }
; 739  : 
; 740  :     /* We have the range set, now we need to iterate through the
; 741  :      * installed tokens and create a new list with just the ones we want
; 742  :      * in it. We are just moving pointers about really.
; 743  :      */
; 744  :     filteredList    = antlr3ListNew((ANTLR3_UINT32)tokenStream->tstream->istream->size(tokenStream->tstream->istream));

  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  000b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  000bc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000bf	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c3	48 89 4c 24 48	 mov	 QWORD PTR tv159[rsp], rcx
  000c8	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000cc	48 8b 44 24 48	 mov	 rax, QWORD PTR tv159[rsp]
  000d1	ff 50 68	 call	 QWORD PTR [rax+104]
  000d4	8b c8		 mov	 ecx, eax
  000d6	e8 00 00 00 00	 call	 antlr3ListNew
  000db	48 89 44 24 20	 mov	 QWORD PTR filteredList$[rsp], rax

; 745  : 
; 746  :     for	(i = start, n = 0; i<= stop; i++)

  000e0	8b 44 24 78	 mov	 eax, DWORD PTR start$[rsp]
  000e4	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  000e8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  000f0	eb 0a		 jmp	 SHORT $LN4@getTokensS
$LN2@getTokensS:
  000f2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000f6	ff c0		 inc	 eax
  000f8	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@getTokensS:
  000fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR stop$[rsp]
  00103	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00107	0f 87 9e 00 00
	00		 ja	 $LN3@getTokensS

; 747  :     {
; 748  : 	tok = tokenStream->tstream->get(tokenStream->tstream, i);

  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00112	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00115	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00119	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0011e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00121	ff 50 30	 call	 QWORD PTR [rax+48]
  00124	48 89 44 24 30	 mov	 QWORD PTR tok$[rsp], rax

; 749  : 
; 750  : 	if  (	   types == NULL
; 751  : 		|| types->isMember(types, tok->getType(tok) == ANTLR3_TRUE)

  00129	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR types$[rsp], 0
  00132	74 45		 je	 SHORT $LN9@getTokensS
  00134	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  00139	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0013e	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00144	83 f8 01	 cmp	 eax, 1
  00147	75 0a		 jne	 SHORT $LN12@getTokensS
  00149	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  00151	eb 08		 jmp	 SHORT $LN13@getTokensS
$LN12@getTokensS:
  00153	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN13@getTokensS:
  0015b	8b 54 24 50	 mov	 edx, DWORD PTR tv139[rsp]
  0015f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR types$[rsp]
  00167	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR types$[rsp]
  0016f	ff 50 48	 call	 QWORD PTR [rax+72]
  00172	0f b6 c0	 movzx	 eax, al
  00175	85 c0		 test	 eax, eax
  00177	74 2d		 je	 SHORT $LN8@getTokensS
$LN9@getTokensS:

; 752  : 	    )
; 753  : 	{
; 754  : 	    filteredList->put(filteredList, n++, (void *)tok, NULL);

  00179	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  0017d	89 44 24 54	 mov	 DWORD PTR tv149[rsp], eax
  00181	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  00185	ff c0		 inc	 eax
  00187	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax
  0018b	8b 44 24 54	 mov	 eax, DWORD PTR tv149[rsp]
  0018f	45 33 c9	 xor	 r9d, r9d
  00192	4c 8b 44 24 30	 mov	 r8, QWORD PTR tok$[rsp]
  00197	8b d0		 mov	 edx, eax
  00199	48 8b 4c 24 20	 mov	 rcx, QWORD PTR filteredList$[rsp]
  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR filteredList$[rsp]
  001a3	ff 50 30	 call	 QWORD PTR [rax+48]
$LN8@getTokensS:

; 755  : 	}
; 756  :     }

  001a6	e9 47 ff ff ff	 jmp	 $LN2@getTokensS
$LN3@getTokensS:

; 757  :     
; 758  :     /* Did we get any then?
; 759  :      */
; 760  :     if	(filteredList->size(filteredList) == 0)

  001ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR filteredList$[rsp]
  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR filteredList$[rsp]
  001b5	ff 50 38	 call	 QWORD PTR [rax+56]
  001b8	85 c0		 test	 eax, eax
  001ba	75 16		 jne	 SHORT $LN10@getTokensS

; 761  :     {
; 762  : 	filteredList->free(filteredList);

  001bc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR filteredList$[rsp]
  001c1	48 8b 44 24 20	 mov	 rax, QWORD PTR filteredList$[rsp]
  001c6	ff 50 08	 call	 QWORD PTR [rax+8]

; 763  : 	filteredList	= NULL;

  001c9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR filteredList$[rsp], 0
$LN10@getTokensS:

; 764  :     }
; 765  : 
; 766  :     return  filteredList;

  001d2	48 8b 44 24 20	 mov	 rax, QWORD PTR filteredList$[rsp]
$LN1@getTokensS:

; 767  : }

  001d7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001db	5f		 pop	 rdi
  001dc	c3		 ret	 0
getTokensSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokenRange
_TEXT	SEGMENT
tokenStream$ = 48
start$ = 56
stop$ = 64
getTokenRange PROC					; COMDAT

; 712  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 713  :     return tokenStream->getTokensSet(tokenStream, start, stop, NULL);

  00027	45 33 c9	 xor	 r9d, r9d
  0002a	44 8b 44 24 40	 mov	 r8d, DWORD PTR stop$[rsp]
  0002f	8b 54 24 38	 mov	 edx, DWORD PTR start$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0003d	ff 50 60	 call	 QWORD PTR [rax+96]

; 714  : }                                                   

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
getTokenRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT getTokens
_TEXT	SEGMENT
tokenStream$ = 48
getTokens PROC						; COMDAT

; 701  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 702  :     if	(tokenStream->p == -1)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00023	83 78 30 ff	 cmp	 DWORD PTR [rax+48], -1
  00027	75 0a		 jne	 SHORT $LN2@getTokens

; 703  :     {
; 704  : 	fillBuffer(tokenStream);

  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0002e	e8 00 00 00 00	 call	 fillBuffer
$LN2@getTokens:

; 705  :     }
; 706  : 
; 707  :     return  tokenStream->tokens;

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00038	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 708  : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
getTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT discardOffChannel
_TEXT	SEGMENT
tokenStream$ = 16
discard$ = 24
discardOffChannel PROC					; COMDAT

; 695  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 696  :     tokenStream->discardOffChannel  = discard;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0000f	0f b6 4c 24 18	 movzx	 ecx, BYTE PTR discard$[rsp]
  00014	88 48 2c	 mov	 BYTE PTR [rax+44], cl

; 697  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
discardOffChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT discardTokenType
_TEXT	SEGMENT
tv71 = 32
tokenStream$ = 64
ttype$ = 72
discardTokenType PROC					; COMDAT

; 681  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 682  :     if	(tokenStream->discardSet == NULL)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  00027	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0002c	75 13		 jne	 SHORT $LN2@discardTok

; 683  :     {
; 684  : 	tokenStream->discardSet	= antlr3ListNew(31);

  0002e	b9 1f 00 00 00	 mov	 ecx, 31
  00033	e8 00 00 00 00	 call	 antlr3ListNew
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  0003d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN2@discardTok:

; 685  :     }
; 686  : 
; 687  :     /* We add one to the channel so we can distinguish NULL as being no entry in the
; 688  :      * table for a particular token type. We could use bitsets for this I suppose too.
; 689  :      */
; 690  :     tokenStream->discardSet->put(tokenStream->discardSet, ttype, ANTLR3_FUNC_PTR((ANTLR3_UINT32)ttype + 1), NULL);

  00041	8b 44 24 48	 mov	 eax, DWORD PTR ttype$[rsp]
  00045	ff c0		 inc	 eax
  00047	8b c0		 mov	 eax, eax
  00049	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR ttype$[rsp]
  0004e	48 8b 54 24 40	 mov	 rdx, QWORD PTR tokenStream$[rsp]
  00053	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00057	48 89 54 24 20	 mov	 QWORD PTR tv71[rsp], rdx
  0005c	45 33 c9	 xor	 r9d, r9d
  0005f	44 8b c0	 mov	 r8d, eax
  00062	48 8b d1	 mov	 rdx, rcx
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0006a	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00073	ff 50 30	 call	 QWORD PTR [rax+48]

; 691  : }

  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
discardTokenType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT setTokenTypeChannel
_TEXT	SEGMENT
tv71 = 32
tokenStream$ = 64
ttype$ = 72
channel$ = 80
setTokenTypeChannel PROC				; COMDAT

; 667  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 668  :     if	(tokenStream->channelOverrides == NULL)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0002c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00031	75 13		 jne	 SHORT $LN2@setTokenTy

; 669  :     {
; 670  : 	tokenStream->channelOverrides	= antlr3ListNew(10);

  00033	b9 0a 00 00 00	 mov	 ecx, 10
  00038	e8 00 00 00 00	 call	 antlr3ListNew
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00042	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN2@setTokenTy:

; 671  :     }
; 672  : 
; 673  :     /* We add one to the channel so we can distinguish NULL as being no entry in the
; 674  :      * table for a particular token type.
; 675  :      */
; 676  :     tokenStream->channelOverrides->put(tokenStream->channelOverrides, ttype, ANTLR3_FUNC_PTR((ANTLR3_UINT32)channel + 1), NULL);

  00046	8b 44 24 50	 mov	 eax, DWORD PTR channel$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	8b c0		 mov	 eax, eax
  0004e	8b 4c 24 48	 mov	 ecx, DWORD PTR ttype$[rsp]
  00052	48 8b 54 24 40	 mov	 rdx, QWORD PTR tokenStream$[rsp]
  00057	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0005b	48 89 54 24 20	 mov	 QWORD PTR tv71[rsp], rdx
  00060	45 33 c9	 xor	 r9d, r9d
  00063	44 8b c0	 mov	 r8d, eax
  00066	8b d1		 mov	 edx, ecx
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR tokenStream$[rsp]
  0006d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00076	ff 50 30	 call	 QWORD PTR [rax+48]

; 677  : }

  00079	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
setTokenTypeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT fillBufferExt
_TEXT	SEGMENT
tokenStream$ = 48
fillBufferExt PROC					; COMDAT

; 946  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 947  :     fillBuffer(tokenStream);

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tokenStream$[rsp]
  00023	e8 00 00 00 00	 call	 fillBuffer

; 948  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
fillBufferExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3CommonTokenDebugStreamSourceNew
_TEXT	SEGMENT
stream$ = 32
hint$ = 64
source$ = 72
debugger$ = 80
antlr3CommonTokenDebugStreamSourceNew PROC		; COMDAT

; 207  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 208  :     pANTLR3_COMMON_TOKEN_STREAM	stream;
; 209  : 
; 210  : 	// Create a standard token stream
; 211  : 	//
; 212  : 	stream = antlr3CommonTokenStreamSourceNew(hint, source);

  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR source$[rsp]
  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR hint$[rsp]
  0002f	e8 00 00 00 00	 call	 antlr3CommonTokenStreamSourceNew
  00034	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 213  : 
; 214  : 	// Install the debugger object
; 215  : 	//
; 216  : 	stream->tstream->debugger = debugger;

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR debugger$[rsp]
  00046	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 217  : 
; 218  : 	// Override standard token stream methods with debugging versions
; 219  : 	//
; 220  : 	stream->tstream->initialStreamState	= ANTLR3_FALSE;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 221  : 
; 222  : 	stream->tstream->_LT				= dbgTokLT;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0005b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgTokLT
  00065	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 223  : 
; 224  : 	stream->tstream->istream->consume		= dbgConsume;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgConsume
  0007c	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 225  : 	stream->tstream->istream->_LA			= dbgLA;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgLA
  00093	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 226  : 	stream->tstream->istream->mark			= dbgMark;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgMark
  000aa	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 227  : 	stream->tstream->istream->rewind		= dbgRewindStream;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgRewindStream
  000c1	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 228  : 	stream->tstream->istream->rewindLast	= dbgRewindLast;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgRewindLast
  000d8	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 229  : 	stream->tstream->istream->seek			= dbgSeek;

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSeek
  000ef	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 230  : 
; 231  : 	return stream;

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 232  : }

  000f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
antlr3CommonTokenDebugStreamSourceNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3CommonTokenStreamNew
_TEXT	SEGMENT
stream$ = 32
hint$ = 64
antlr3CommonTokenStreamNew PROC				; COMDAT

; 255  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 256  :     pANTLR3_COMMON_TOKEN_STREAM stream;
; 257  : 
; 258  :     /* Memory for the interface structure
; 259  :      */
; 260  :     stream  = (pANTLR3_COMMON_TOKEN_STREAM) ANTLR3_MALLOC(sizeof(ANTLR3_COMMON_TOKEN_STREAM));

  0001c	b9 88 00 00 00	 mov	 ecx, 136		; 00000088H
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 261  : 
; 262  :     if	(stream == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00032	75 07		 jne	 SHORT $LN2@antlr3Comm

; 263  :     {
; 264  : 	return	NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 88 02 00 00	 jmp	 $LN1@antlr3Comm
$LN2@antlr3Comm:

; 265  :     }
; 266  : 
; 267  :     /* Create space for the token stream interface
; 268  :      */
; 269  :     stream->tstream	    = antlr3TokenStreamNew();

  0003b	e8 00 00 00 00	 call	 antlr3TokenStreamNew
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 270  :     stream->tstream->super  =  stream;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00055	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 271  : 
; 272  :     /* Create space for the INT_STREAM interfacce
; 273  :      */
; 274  :     stream->tstream->istream		    =  antlr3IntStreamNew();

  00059	e8 00 00 00 00	 call	 antlr3IntStreamNew
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00063	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00066	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 275  :     stream->tstream->istream->super	    =  (stream->tstream);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00072	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  0007b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 276  :     stream->tstream->istream->type	    = ANTLR3_TOKENSTREAM;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008e	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 277  : 
; 278  :     /* Install the token tracking tables
; 279  :      */
; 280  :     stream->tokens  = antlr3VectorNew(0);

  00094	33 c9		 xor	 ecx, ecx
  00096	e8 00 00 00 00	 call	 antlr3VectorNew
  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  000a0	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 281  : 
; 282  :     /* Defaults
; 283  :      */
; 284  :     stream->p	    = -1;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000a9	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [rax+48], -1

; 285  : 
; 286  :     /* Install the common token stream API
; 287  :      */
; 288  :     stream->setTokenTypeChannel	    = setTokenTypeChannel;

  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenTypeChannel
  000bc	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 289  :     stream->discardTokenType	    = discardTokenType;

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:discardTokenType
  000cc	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 290  :     stream->discardOffChannelToks   = discardOffChannel;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:discardOffChannel
  000dc	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 291  :     stream->getTokens		    = getTokens;

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokens
  000ec	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 292  :     stream->getTokenRange	    = getTokenRange;

  000f0	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenRange
  000fc	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 293  :     stream->getTokensSet	    = getTokensSet;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokensSet
  0010c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 294  :     stream->getTokensList	    = getTokensList;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokensList
  0011c	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 295  :     stream->getTokensType	    = getTokensType;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokensType
  0012c	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 296  :     stream->reset                   = reset;

  00130	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  0013c	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 297  : 
; 298  :     /* Install the token stream API
; 299  :      */
; 300  :     stream->tstream->_LT			=  tokLT;

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00145	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tokLT
  0014f	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 301  :     stream->tstream->get			=  get;

  00153	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00158	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:get
  00162	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 302  :     stream->tstream->getTokenSource	        =  getTokenSource;

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0016b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenSource
  00175	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 303  :     stream->tstream->setTokenSource	        =  setTokenSource;

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0017e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenSource
  00188	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 304  :     stream->tstream->toString		        =  toString;

  0018c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00191	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toString
  0019b	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 305  :     stream->tstream->toStringSS		        =  toStringSS;

  0019f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStringSS
  001ae	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 306  :     stream->tstream->toStringTT		        =  toStringTT;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStringTT
  001c1	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 307  :     stream->tstream->setDebugListener           =  setDebugListener;

  001c5	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setDebugListener
  001d4	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 308  : 
; 309  :     /* Install INT_STREAM interface
; 310  :      */
; 311  :     stream->tstream->istream->_LA	=  _LA;

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_LA
  001eb	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 312  :     stream->tstream->istream->mark	=  mark;

  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mark
  00202	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 313  :     stream->tstream->istream->release	=  release;

  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0020b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:release
  00219	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 314  :     stream->tstream->istream->size	=  size;

  0021d	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00222	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00225	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:size
  00230	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 315  :     stream->tstream->istream->index	=  tindex;

  00234	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00239	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tindex
  00247	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 316  :     stream->tstream->istream->rewind	=  rewindStream;

  0024b	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00250	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00253	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindStream
  0025e	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 317  :     stream->tstream->istream->rewindLast=  rewindLast;

  00262	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00267	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindLast
  00275	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 318  :     stream->tstream->istream->seek	=  seek;

  00279	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0027e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00281	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:seek
  0028c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 319  :     stream->tstream->istream->consume	=  consume;

  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00295	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00298	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consume
  002a3	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 320  :     stream->tstream->istream->getSourceName = getSourceName;

  002a7	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  002ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002af	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getSourceName
  002ba	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 321  : 
; 322  :     return  stream;

  002be	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Comm:

; 323  : }

  002c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002c7	5f		 pop	 rdi
  002c8	c3		 ret	 0
antlr3CommonTokenStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3tokenstream.c
;	COMDAT antlr3CommonTokenStreamSourceNew
_TEXT	SEGMENT
stream$ = 32
hint$ = 64
source$ = 72
antlr3CommonTokenStreamSourceNew PROC			; COMDAT

; 236  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 237  :     pANTLR3_COMMON_TOKEN_STREAM	stream;
; 238  : 
; 239  :     stream = antlr3CommonTokenStreamNew(hint);

  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR hint$[rsp]
  00025	e8 00 00 00 00	 call	 antlr3CommonTokenStreamNew
  0002a	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 240  : 
; 241  :     stream->channel = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00034	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 242  :     
; 243  :     stream->channelOverrides	= NULL;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00040	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 244  :     stream->discardSet		= NULL;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004d	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 245  :     stream->discardOffChannel	= ANTLR3_FALSE;

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0005a	c6 40 2c 00	 mov	 BYTE PTR [rax+44], 0

; 246  : 
; 247  :     stream->tstream->setTokenSource(stream->tstream, source);

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 8b 54 24 48	 mov	 rdx, QWORD PTR source$[rsp]
  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00070	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00073	ff 50 40	 call	 QWORD PTR [rax+64]

; 248  : 
; 249  :     stream->free		=  antlr3CTSFree;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3CTSFree
  00082	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 250  :     return  stream;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 251  : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
antlr3CommonTokenStreamSourceNew ENDP
_TEXT	ENDS
END
