; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3BaseTreeNew
PUBLIC	??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5a@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5ar@ ; `string'
PUBLIC	??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB?$CB@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseTreeNew DD imagerel $LN3
	DD	imagerel $LN3+284
	DD	imagerel $unwind$antlr3BaseTreeNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+114
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+78
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+10
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+10
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getFirstChildWithType DD imagerel getFirstChildWithType
	DD	imagerel getFirstChildWithType+176
	DD	imagerel $unwind$getFirstChildWithType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+429
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChildren DD imagerel addChildren
	DD	imagerel addChildren+129
	DD	imagerel $unwind$addChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replaceChildren DD imagerel replaceChildren
	DD	imagerel replaceChildren+1129
	DD	imagerel $unwind$replaceChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freshenPACIndexesAll DD imagerel freshenPACIndexesAll
	DD	imagerel freshenPACIndexesAll+54
	DD	imagerel $unwind$freshenPACIndexesAll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freshenPACIndexes DD imagerel freshenPACIndexes
	DD	imagerel freshenPACIndexes+152
	DD	imagerel $unwind$freshenPACIndexes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChild DD imagerel setChild
	DD	imagerel setChild+111
	DD	imagerel $unwind$setChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deleteChild DD imagerel deleteChild
	DD	imagerel deleteChild+84
	DD	imagerel $unwind$deleteChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTree DD imagerel dupTree
	DD	imagerel dupTree+212
	DD	imagerel $unwind$dupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStringTree DD imagerel toStringTree
	DD	imagerel toStringTree+434
	DD	imagerel $unwind$toStringTree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB?$CB@
CONST	SEGMENT
??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB?$CB@ DB 'replac'
	DB	'eChildren: out of memory!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5ar@
CONST	SEGMENT
??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5ar@ DB 'replaceChild'
	DB	'ren call: Indexes are invalid; no children in list for %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5a@
CONST	SEGMENT
??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5a@ DB 'ANTLR3: A'
	DB	'n attempt was made to add a child list to itself!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStringTree DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTree DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deleteChild DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChild DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freshenPACIndexes DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freshenPACIndexesAll DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replaceChildren DD 033201H
	DD	012011bH
	DD	07014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChildren DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getFirstChildWithType DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseTreeNew DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT toStringTree
_TEXT	SEGMENT
string$ = 32
i$ = 40
n$ = 44
t$ = 48
tree$ = 80
toStringTree PROC					; COMDAT

; 289  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 290  : 	pANTLR3_STRING  string;
; 291  : 	ANTLR3_UINT32   i;
; 292  : 	ANTLR3_UINT32   n;
; 293  : 	pANTLR3_BASE_TREE   t;
; 294  : 
; 295  : 	if	(tree->children == NULL || tree->children->size(tree->children) == 0)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00023	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00028	74 1c		 je	 SHORT $LN6@toStringTr
  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0002f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00038	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003c	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00042	85 c0		 test	 eax, eax
  00044	75 15		 jne	 SHORT $LN5@toStringTr
$LN6@toStringTr:

; 296  : 	{
; 297  : 		return	tree->toString(tree);

  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00050	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]
  00056	e9 51 01 00 00	 jmp	 $LN1@toStringTr
$LN5@toStringTr:

; 298  : 	}
; 299  : 
; 300  : 	/* Need a new string with nothing at all in it.
; 301  : 	*/
; 302  : 	string	= tree->strFactory->newRaw(tree->strFactory);

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00060	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00064	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00069	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006d	ff 50 10	 call	 QWORD PTR [rax+16]
  00070	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 303  : 
; 304  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0007f	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 48		 jne	 SHORT $LN7@toStringTr

; 305  : 	{
; 306  : 		string->append8	(string, "(");

  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01ODHLEDKK@?$CI?$AA@
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0009d	ff 50 38	 call	 QWORD PTR [rax+56]

; 307  : 		string->appendS	(string, tree->toString(tree));

  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  000aa	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000bd	ff 50 58	 call	 QWORD PTR [rax+88]

; 308  : 		string->append8	(string, " ");

  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
  000c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000d1	ff 50 38	 call	 QWORD PTR [rax+56]
$LN7@toStringTr:

; 309  : 	}
; 310  : 	if	(tree->children != NULL)

  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  000d9	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000de	0f 84 98 00 00
	00		 je	 $LN8@toStringTr

; 311  : 	{
; 312  : 		n = tree->children->size(tree->children);

  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  000e9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  000f2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000f6	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  000fc	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 313  : 
; 314  : 		for	(i = 0; i < n; i++)

  00100	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00108	eb 0a		 jmp	 SHORT $LN4@toStringTr
$LN2@toStringTr:
  0010a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0010e	ff c0		 inc	 eax
  00110	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@toStringTr:
  00114	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  00118	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0011c	73 5e		 jae	 SHORT $LN3@toStringTr

; 315  : 		{   
; 316  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00123	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00127	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00130	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00134	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0013a	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax

; 317  : 
; 318  : 			if  (i > 0)

  0013f	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  00144	76 14		 jbe	 SHORT $LN9@toStringTr

; 319  : 			{
; 320  : 				string->append8(string, " ");

  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
  0014d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00152	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00157	ff 50 38	 call	 QWORD PTR [rax+56]
$LN9@toStringTr:

; 321  : 			}
; 322  : 			string->appendS(string, t->toStringTree(t));

  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t$[rsp]
  0015f	48 8b 44 24 30	 mov	 rax, QWORD PTR t$[rsp]
  00164	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0016a	48 8b d0	 mov	 rdx, rax
  0016d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00172	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00177	ff 50 58	 call	 QWORD PTR [rax+88]

; 323  : 		}

  0017a	eb 8e		 jmp	 SHORT $LN2@toStringTr
$LN3@toStringTr:
$LN8@toStringTr:

; 324  : 	}
; 325  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  0017c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00181	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00186	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0018c	0f b6 c0	 movzx	 eax, al
  0018f	85 c0		 test	 eax, eax
  00191	75 14		 jne	 SHORT $LN10@toStringTr

; 326  : 	{
; 327  : 		string->append8(string,")");

  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
  0019a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0019f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  001a4	ff 50 38	 call	 QWORD PTR [rax+56]
$LN10@toStringTr:

; 328  : 	}
; 329  : 
; 330  : 	return  string;

  001a7	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@toStringTr:

; 331  : }

  001ac	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001b0	5f		 pop	 rdi
  001b1	c3		 ret	 0
toStringTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT dupTree
_TEXT	SEGMENT
newTree$ = 32
i$ = 40
s$ = 44
t$1 = 48
newNode$2 = 56
tree$ = 80
dupTree	PROC						; COMDAT

; 258  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 259  : 	pANTLR3_BASE_TREE	newTree;
; 260  : 	ANTLR3_UINT32	i;
; 261  : 	ANTLR3_UINT32	s;
; 262  : 
; 263  : 	newTree = tree->dupNode	    (tree);

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00028	ff 50 58	 call	 QWORD PTR [rax+88]
  0002b	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 264  : 
; 265  : 	if	(tree->children != NULL)

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00035	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0003a	0f 84 89 00 00
	00		 je	 $LN5@dupTree

; 266  : 	{
; 267  : 		s	    = tree->children->size  (tree->children);

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0004e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00052	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00058	89 44 24 2c	 mov	 DWORD PTR s$[rsp], eax

; 268  : 
; 269  : 		for	(i = 0; i < s; i++)

  0005c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00064	eb 0a		 jmp	 SHORT $LN4@dupTree
$LN2@dupTree:
  00066	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@dupTree:
  00070	8b 44 24 2c	 mov	 eax, DWORD PTR s$[rsp]
  00074	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00078	73 4f		 jae	 SHORT $LN3@dupTree

; 270  : 		{
; 271  : 			pANTLR3_BASE_TREE    t;
; 272  : 			pANTLR3_BASE_TREE    newNode;
; 273  : 
; 274  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0008c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00090	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00096	48 89 44 24 30	 mov	 QWORD PTR t$1[rsp], rax

; 275  : 
; 276  : 			if  (t!= NULL)

  0009b	48 83 7c 24 30
	00		 cmp	 QWORD PTR t$1[rsp], 0
  000a1	74 24		 je	 SHORT $LN6@dupTree

; 277  : 			{
; 278  : 				newNode	    = t->dupTree(t);

  000a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t$1[rsp]
  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR t$1[rsp]
  000ad	ff 50 60	 call	 QWORD PTR [rax+96]
  000b0	48 89 44 24 38	 mov	 QWORD PTR newNode$2[rsp], rax

; 279  : 				newTree->addChild(newTree, newNode);

  000b5	48 8b 54 24 38	 mov	 rdx, QWORD PTR newNode$2[rsp]
  000ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newTree$[rsp]
  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  000c4	ff 50 30	 call	 QWORD PTR [rax+48]
$LN6@dupTree:

; 280  : 			}
; 281  : 		}

  000c7	eb 9d		 jmp	 SHORT $LN2@dupTree
$LN3@dupTree:
$LN5@dupTree:

; 282  : 	}
; 283  : 
; 284  : 	return newTree;

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]

; 285  : }

  000ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
dupTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT deleteChild
_TEXT	SEGMENT
tree$ = 48
i$ = 56
deleteChild PROC					; COMDAT

; 247  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 248  : 	if	( tree->children == NULL)

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00027	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002c	75 04		 jne	 SHORT $LN2@deleteChil

; 249  : 	{
; 250  : 		return	NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 1c		 jmp	 SHORT $LN1@deleteChil
$LN2@deleteChil:

; 251  : 	}
; 252  : 
; 253  : 	return  tree->children->remove(tree->children, i);

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00037	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003b	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00044	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00048	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
$LN1@deleteChil:

; 254  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT setChild
_TEXT	SEGMENT
tree$ = 64
i$ = 72
child$ = 80
setChild PROC						; COMDAT

; 237  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 238  : 	if	(tree->children == NULL)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0002c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00031	75 0d		 jne	 SHORT $LN2@setChild

; 239  : 	{
; 240  : 		tree->createChildrenList(tree);

  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0003d	ff 50 40	 call	 QWORD PTR [rax+64]
$LN2@setChild:

; 241  : 	}
; 242  : 	tree->children->set(tree->children, i, child, NULL, ANTLR3_FALSE);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0004e	45 33 c9	 xor	 r9d, r9d
  00051	4c 8b 44 24 50	 mov	 r8, QWORD PTR child$[rsp]
  00056	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0005f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00063	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 243  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT freshenPACIndexes
_TEXT	SEGMENT
count$ = 32
c$ = 36
child$1 = 40
tree$ = 64
offset$ = 72
freshenPACIndexes PROC					; COMDAT

; 471  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 472  : 	ANTLR3_UINT32	count;
; 473  : 	ANTLR3_UINT32	c;
; 474  : 
; 475  : 	count	= tree->getChildCount(tree);		// How many children do we have 

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0002c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00032	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax

; 476  : 
; 477  : 	// Loop from the supplied index and set the indexes and parent
; 478  : 	//
; 479  : 	for	(c = offset; c < count; c++)

  00036	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0003a	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
  0003e	eb 0a		 jmp	 SHORT $LN4@freshenPAC
$LN2@freshenPAC:
  00040	8b 44 24 24	 mov	 eax, DWORD PTR c$[rsp]
  00044	ff c0		 inc	 eax
  00046	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
$LN4@freshenPAC:
  0004a	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  0004e	39 44 24 24	 cmp	 DWORD PTR c$[rsp], eax
  00052	73 3e		 jae	 SHORT $LN3@freshenPAC

; 480  : 	{
; 481  : 		pANTLR3_BASE_TREE	child;
; 482  : 
; 483  : 		child = tree->getChild(tree, c);

  00054	8b 54 24 24	 mov	 edx, DWORD PTR c$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00062	ff 50 70	 call	 QWORD PTR [rax+112]
  00065	48 89 44 24 28	 mov	 QWORD PTR child$1[rsp], rax

; 484  : 
; 485  : 		child->setChildIndex(child, c);

  0006a	8b 54 24 24	 mov	 edx, DWORD PTR c$[rsp]
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR child$1[rsp]
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR child$1[rsp]
  00078	ff 50 78	 call	 QWORD PTR [rax+120]

; 486  : 		child->setParent(child, tree);

  0007b	48 8b 54 24 40	 mov	 rdx, QWORD PTR tree$[rsp]
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR child$1[rsp]
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR child$1[rsp]
  0008a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 487  : 	}

  00090	eb ae		 jmp	 SHORT $LN2@freshenPAC
$LN3@freshenPAC:

; 488  : }

  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
freshenPACIndexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT freshenPACIndexesAll
_TEXT	SEGMENT
tree$ = 48
freshenPACIndexesAll PROC				; COMDAT

; 462  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 463  : 	tree->freshenPACIndexes(tree, 0);

  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0002a	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 464  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
freshenPACIndexesAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT replaceChildren
_TEXT	SEGMENT
replacingHowMany$ = 48
replacingWithHowMany$ = 52
numNewChildren$ = 56
delta$ = 60
i$ = 64
j$ = 68
newChildren$ = 72
freeNewChildren$ = 80
child$1 = 88
indexToDelete$2 = 96
numToInsert$3 = 100
tv68 = 104
tv223 = 112
tv221 = 120
tv220 = 128
parent$ = 160
startChildIndex$ = 168
stopChildIndex$ = 176
newTree$ = 184
replaceChildren PROC					; COMDAT

; 340  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]

; 341  : 	ANTLR3_INT32	replacingHowMany;		// How many nodes will go away
; 342  : 	ANTLR3_INT32	replacingWithHowMany;	// How many nodes will replace them
; 343  : 	ANTLR3_INT32	numNewChildren;			// Tracking variable
; 344  : 	ANTLR3_INT32	delta;					// Difference in new vs existing count
; 345  : 
; 346  : 	ANTLR3_INT32	i;
; 347  : 	ANTLR3_INT32	j;
; 348  : 
; 349  : 	pANTLR3_VECTOR	newChildren;			// Iterator for whatever we are going to add in
; 350  : 	ANTLR3_BOOLEAN	freeNewChildren;		// Whether we created the iterator locally or reused it
; 351  : 
; 352  : 	if	(parent->children == NULL)

  00032	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  0003a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0003f	75 43		 jne	 SHORT $LN17@replaceChi

; 353  : 	{
; 354  : 		ANTLR3_FPRINTF(stderr, "replaceChildren call: Indexes are invalid; no children in list for %s", parent->getText(parent)->chars);

  00041	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  00049	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00051	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00057	48 89 44 24 68	 mov	 QWORD PTR tv68[rsp], rax
  0005c	b9 02 00 00 00	 mov	 ecx, 2
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv68[rsp]
  0006c	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5ar@
  00077	48 8b c8	 mov	 rcx, rax
  0007a	e8 00 00 00 00	 call	 fprintf

; 355  : 		return;

  0007f	e9 dc 03 00 00	 jmp	 $LN1@replaceChi
$LN17@replaceChi:

; 356  : 	}
; 357  : 
; 358  : 	// Either use the existing list of children in the supplied nil node, or build a vector of the
; 359  : 	// tree we were given if it is not a nil node, then we treat both situations exactly the same
; 360  : 	//
; 361  : 	if	(newTree->isNilNode(newTree))

  00084	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR newTree$[rsp]
  0008c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR newTree$[rsp]
  00094	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0009a	0f b6 c0	 movzx	 eax, al
  0009d	85 c0		 test	 eax, eax
  0009f	74 18		 je	 SHORT $LN18@replaceChi

; 362  : 	{
; 363  : 		newChildren = newTree->children;

  000a1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR newTree$[rsp]
  000a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ad	48 89 44 24 48	 mov	 QWORD PTR newChildren$[rsp], rax

; 364  : 		freeNewChildren = ANTLR3_FALSE;		// We must NO free this memory

  000b2	c6 44 24 50 00	 mov	 BYTE PTR freeNewChildren$[rsp], 0

; 365  : 	}

  000b7	eb 5c		 jmp	 SHORT $LN19@replaceChi
$LN18@replaceChi:

; 366  : 	else
; 367  : 	{
; 368  : 		newChildren = antlr3VectorNew(1);

  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	e8 00 00 00 00	 call	 antlr3VectorNew
  000c3	48 89 44 24 48	 mov	 QWORD PTR newChildren$[rsp], rax

; 369  : 		if	(newChildren == NULL)

  000c8	48 83 7c 24 48
	00		 cmp	 QWORD PTR newChildren$[rsp], 0
  000ce	75 25		 jne	 SHORT $LN20@replaceChi

; 370  : 		{
; 371  : 			ANTLR3_FPRINTF(stderr, "replaceChildren: out of memory!!");

  000d0	b9 02 00 00 00	 mov	 ecx, 2
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB?$CB@
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 fprintf

; 372  : 			exit(1);

  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN20@replaceChi:

; 373  : 		}
; 374  : 		newChildren->add(newChildren, (void *)newTree, NULL);

  000f5	45 33 c0	 xor	 r8d, r8d
  000f8	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR newTree$[rsp]
  00100	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  0010a	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 375  : 
; 376  : 		freeNewChildren = ANTLR3_TRUE;		// We must free this memory

  00110	c6 44 24 50 01	 mov	 BYTE PTR freeNewChildren$[rsp], 1
$LN19@replaceChi:

; 377  : 	}
; 378  : 
; 379  : 	// Initialize
; 380  : 	//
; 381  : 	replacingHowMany		= stopChildIndex - startChildIndex + 1;

  00115	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR startChildIndex$[rsp]
  0011c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR stopChildIndex$[rsp]
  00123	2b c8		 sub	 ecx, eax
  00125	8b c1		 mov	 eax, ecx
  00127	ff c0		 inc	 eax
  00129	89 44 24 30	 mov	 DWORD PTR replacingHowMany$[rsp], eax

; 382  : 	replacingWithHowMany	= newChildren->size(newChildren);

  0012d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00132	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00137	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  0013d	89 44 24 34	 mov	 DWORD PTR replacingWithHowMany$[rsp], eax

; 383  : 	delta					= replacingHowMany - replacingWithHowMany;

  00141	8b 44 24 34	 mov	 eax, DWORD PTR replacingWithHowMany$[rsp]
  00145	8b 4c 24 30	 mov	 ecx, DWORD PTR replacingHowMany$[rsp]
  00149	2b c8		 sub	 ecx, eax
  0014b	8b c1		 mov	 eax, ecx
  0014d	89 44 24 3c	 mov	 DWORD PTR delta$[rsp], eax

; 384  : 	numNewChildren			= newChildren->size(newChildren);

  00151	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  0015b	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00161	89 44 24 38	 mov	 DWORD PTR numNewChildren$[rsp], eax

; 385  : 
; 386  : 	// If it is the same number of nodes, then do a direct replacement
; 387  : 	//
; 388  : 	if	(delta == 0)

  00165	83 7c 24 3c 00	 cmp	 DWORD PTR delta$[rsp], 0
  0016a	0f 85 a7 00 00
	00		 jne	 $LN21@replaceChi

; 389  : 	{
; 390  : 		pANTLR3_BASE_TREE	child;
; 391  : 
; 392  : 		// Same number of nodes
; 393  : 		//
; 394  : 		j	= 0;

  00170	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 395  : 		for	(i = startChildIndex; i <= stopChildIndex; i++)

  00178	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR startChildIndex$[rsp]
  0017f	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00183	eb 0a		 jmp	 SHORT $LN4@replaceChi
$LN2@replaceChi:
  00185	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00189	ff c0		 inc	 eax
  0018b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@replaceChi:
  0018f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR stopChildIndex$[rsp]
  00196	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0019a	7f 76		 jg	 SHORT $LN3@replaceChi

; 396  : 		{
; 397  : 			child = (pANTLR3_BASE_TREE) newChildren->get(newChildren, j);

  0019c	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  001a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  001a5	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  001aa	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  001b0	48 89 44 24 58	 mov	 QWORD PTR child$1[rsp], rax

; 398  : 			parent->children->set(parent->children, i, child, NULL, ANTLR3_FALSE);

  001b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  001bd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c1	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001c6	45 33 c9	 xor	 r9d, r9d
  001c9	4c 8b 44 24 58	 mov	 r8, QWORD PTR child$1[rsp]
  001ce	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  001d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  001da	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001de	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 399  : 			child->setParent(child, parent);

  001e4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  001ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR child$1[rsp]
  001f1	48 8b 44 24 58	 mov	 rax, QWORD PTR child$1[rsp]
  001f6	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 400  : 			child->setChildIndex(child, i);

  001fc	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00200	48 8b 4c 24 58	 mov	 rcx, QWORD PTR child$1[rsp]
  00205	48 8b 44 24 58	 mov	 rax, QWORD PTR child$1[rsp]
  0020a	ff 50 78	 call	 QWORD PTR [rax+120]

; 401  : 		}

  0020d	e9 73 ff ff ff	 jmp	 $LN2@replaceChi
$LN3@replaceChi:

; 402  : 	}

  00212	e9 0a 02 00 00	 jmp	 $LN22@replaceChi
$LN21@replaceChi:

; 403  : 	else if (delta > 0)

  00217	83 7c 24 3c 00	 cmp	 DWORD PTR delta$[rsp], 0
  0021c	0f 8e f2 00 00
	00		 jle	 $LN23@replaceChi

; 404  : 	{
; 405  : 		ANTLR3_UINT32	indexToDelete;
; 406  : 
; 407  : 		// Less nodes than there were before
; 408  : 		// reuse what we have then delete the rest
; 409  : 		//
; 410  : 		for	(j = 0; j < numNewChildren; j++)

  00222	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0022a	eb 0a		 jmp	 SHORT $LN7@replaceChi
$LN5@replaceChi:
  0022c	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  00230	ff c0		 inc	 eax
  00232	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN7@replaceChi:
  00236	8b 44 24 38	 mov	 eax, DWORD PTR numNewChildren$[rsp]
  0023a	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  0023e	7d 5a		 jge	 SHORT $LN6@replaceChi

; 411  : 		{
; 412  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  00240	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  00244	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00249	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  0024e	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00254	8b 4c 24 44	 mov	 ecx, DWORD PTR j$[rsp]
  00258	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  0025f	03 d1		 add	 edx, ecx
  00261	8b ca		 mov	 ecx, edx
  00263	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  0026b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0026f	48 89 54 24 70	 mov	 QWORD PTR tv223[rsp], rdx
  00274	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00279	45 33 c9	 xor	 r9d, r9d
  0027c	4c 8b c0	 mov	 r8, rax
  0027f	8b d1		 mov	 edx, ecx
  00281	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00289	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0028d	48 8b 44 24 70	 mov	 rax, QWORD PTR tv223[rsp]
  00292	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 413  : 		}

  00298	eb 92		 jmp	 SHORT $LN5@replaceChi
$LN6@replaceChi:

; 414  : 
; 415  : 		// We just delete the same index position until done
; 416  : 		//
; 417  : 		indexToDelete = startChildIndex + numNewChildren;

  0029a	8b 44 24 38	 mov	 eax, DWORD PTR numNewChildren$[rsp]
  0029e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR startChildIndex$[rsp]
  002a5	03 c8		 add	 ecx, eax
  002a7	8b c1		 mov	 eax, ecx
  002a9	89 44 24 60	 mov	 DWORD PTR indexToDelete$2[rsp], eax

; 418  : 
; 419  : 		for	(j = indexToDelete; j <= (ANTLR3_INT32)stopChildIndex; j++)

  002ad	8b 44 24 60	 mov	 eax, DWORD PTR indexToDelete$2[rsp]
  002b1	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  002b5	eb 0a		 jmp	 SHORT $LN10@replaceChi
$LN8@replaceChi:
  002b7	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  002bb	ff c0		 inc	 eax
  002bd	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN10@replaceChi:
  002c1	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR stopChildIndex$[rsp]
  002c8	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  002cc	7f 24		 jg	 SHORT $LN9@replaceChi

; 420  : 		{
; 421  : 			parent->children->remove(parent->children, indexToDelete);

  002ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  002d6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002da	8b 54 24 60	 mov	 edx, DWORD PTR indexToDelete$2[rsp]
  002de	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  002e6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002ea	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]

; 422  : 		}

  002f0	eb c5		 jmp	 SHORT $LN8@replaceChi
$LN9@replaceChi:

; 423  : 
; 424  : 		parent->freshenPACIndexes(parent, startChildIndex);

  002f2	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  002f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  00301	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00309	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 425  : 	}

  0030f	e9 0d 01 00 00	 jmp	 $LN24@replaceChi
$LN23@replaceChi:

; 426  : 	else
; 427  : 	{
; 428  : 		ANTLR3_UINT32 numToInsert;
; 429  : 
; 430  : 		// More nodes than there were before
; 431  : 		// Use what we can, then start adding
; 432  : 		//
; 433  : 		for	(j = 0; j < replacingHowMany; j++)

  00314	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0031c	eb 0a		 jmp	 SHORT $LN13@replaceChi
$LN11@replaceChi:
  0031e	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  00322	ff c0		 inc	 eax
  00324	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN13@replaceChi:
  00328	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  0032c	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  00330	7d 5a		 jge	 SHORT $LN12@replaceChi

; 434  : 		{
; 435  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  00332	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  00336	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  0033b	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00340	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00346	8b 4c 24 44	 mov	 ecx, DWORD PTR j$[rsp]
  0034a	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  00351	03 d1		 add	 edx, ecx
  00353	8b ca		 mov	 ecx, edx
  00355	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  0035d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00361	48 89 54 24 78	 mov	 QWORD PTR tv221[rsp], rdx
  00366	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0036b	45 33 c9	 xor	 r9d, r9d
  0036e	4c 8b c0	 mov	 r8, rax
  00371	8b d1		 mov	 edx, ecx
  00373	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  0037b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0037f	48 8b 44 24 78	 mov	 rax, QWORD PTR tv221[rsp]
  00384	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 436  : 		}

  0038a	eb 92		 jmp	 SHORT $LN11@replaceChi
$LN12@replaceChi:

; 437  : 
; 438  : 		numToInsert = replacingWithHowMany - replacingHowMany;

  0038c	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  00390	8b 4c 24 34	 mov	 ecx, DWORD PTR replacingWithHowMany$[rsp]
  00394	2b c8		 sub	 ecx, eax
  00396	8b c1		 mov	 eax, ecx
  00398	89 44 24 64	 mov	 DWORD PTR numToInsert$3[rsp], eax

; 439  : 
; 440  : 		for	(j = replacingHowMany; j < replacingWithHowMany; j++)

  0039c	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  003a0	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  003a4	eb 0a		 jmp	 SHORT $LN16@replaceChi
$LN14@replaceChi:
  003a6	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  003aa	ff c0		 inc	 eax
  003ac	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN16@replaceChi:
  003b0	8b 44 24 34	 mov	 eax, DWORD PTR replacingWithHowMany$[rsp]
  003b4	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  003b8	7d 4a		 jge	 SHORT $LN15@replaceChi

; 441  : 		{
; 442  : 			parent->children->add(parent->children, newChildren->get(newChildren, j), NULL);

  003ba	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  003be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  003c3	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  003c8	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  003ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  003d6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003da	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv220[rsp], rcx
  003e2	45 33 c0	 xor	 r8d, r8d
  003e5	48 8b d0	 mov	 rdx, rax
  003e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  003f0	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv220[rsp]
  003fc	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 443  : 		}

  00402	eb a2		 jmp	 SHORT $LN14@replaceChi
$LN15@replaceChi:

; 444  : 
; 445  : 		parent->freshenPACIndexes(parent, startChildIndex);

  00404	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  0040b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  00413	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  0041b	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]
$LN24@replaceChi:
$LN22@replaceChi:

; 446  : 	}
; 447  : 
; 448  : 	if	(freeNewChildren == ANTLR3_TRUE)

  00421	0f b6 44 24 50	 movzx	 eax, BYTE PTR freeNewChildren$[rsp]
  00426	83 f8 01	 cmp	 eax, 1
  00429	75 35		 jne	 SHORT $LN25@replaceChi

; 449  : 	{
; 450  : 		ANTLR3_FREE(newChildren->elements);

  0042b	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00430	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00433	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 451  : 		newChildren->elements = NULL;

  00439	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  0043e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 452  : 		newChildren->size = 0;

  00445	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  0044a	48 c7 80 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+344], 0

; 453  : 		ANTLR3_FREE(newChildren);		// Will not free the nodes

  00455	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  0045a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@replaceChi:
$LN1@replaceChi:
$LN26@replaceChi:

; 454  : 	}
; 455  : }

  00460	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00467	5f		 pop	 rdi
  00468	c3		 ret	 0
replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT addChildren
_TEXT	SEGMENT
i$ = 32
s$ = 36
tree$ = 64
kids$ = 72
addChildren PROC					; COMDAT

; 223  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 224  : 	ANTLR3_UINT32    i;
; 225  : 	ANTLR3_UINT32    s;
; 226  : 
; 227  : 	s = kids->size(kids);

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR kids$[rsp]
  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR kids$[rsp]
  0002d	ff 50 38	 call	 QWORD PTR [rax+56]
  00030	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax

; 228  : 	for	(i = 0; i<s; i++)

  00034	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003c	eb 0a		 jmp	 SHORT $LN4@addChildre
$LN2@addChildre:
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00042	ff c0		 inc	 eax
  00044	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@addChildre:
  00048	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  0004c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00050	73 29		 jae	 SHORT $LN3@addChildre

; 229  : 	{
; 230  : 		tree->addChild(tree, (pANTLR3_BASE_TREE)(kids->get(kids, i+1)));

  00052	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00056	ff c0		 inc	 eax
  00058	8b c0		 mov	 eax, eax
  0005a	8b d0		 mov	 edx, eax
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR kids$[rsp]
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR kids$[rsp]
  00066	ff 50 18	 call	 QWORD PTR [rax+24]
  00069	48 8b d0	 mov	 rdx, rax
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00076	ff 50 30	 call	 QWORD PTR [rax+48]

; 231  : 	}

  00079	eb c3		 jmp	 SHORT $LN2@addChildre
$LN3@addChildre:

; 232  : }

  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
addChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT addChild
_TEXT	SEGMENT
n$ = 32
i$ = 36
entry$1 = 40
tree$ = 64
child$ = 72
addChild PROC						; COMDAT

; 145  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 146  : 	ANTLR3_UINT32   n;
; 147  : 	ANTLR3_UINT32   i;
; 148  : 
; 149  : 	if	(child == NULL)

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR child$[rsp], 0
  00029	75 05		 jne	 SHORT $LN5@addChild

; 150  : 	{
; 151  : 		return;

  0002b	e9 77 01 00 00	 jmp	 $LN1@addChild
$LN5@addChild:

; 152  : 	}
; 153  : 
; 154  : 	if	(child->isNilNode(child) == ANTLR3_TRUE)

  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00035	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  0003a	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00040	0f b6 c0	 movzx	 eax, al
  00043	83 f8 01	 cmp	 eax, 1
  00046	0f 85 19 01 00
	00		 jne	 $LN6@addChild

; 155  : 	{
; 156  : 		if  (child->children != NULL && child->children == tree->children)

  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00051	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00056	74 33		 je	 SHORT $LN8@addChild
  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00062	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00066	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0006a	75 1f		 jne	 SHORT $LN8@addChild

; 157  : 		{
; 158  : 			// TODO: Change to exception rather than ANTLR3_FPRINTF?
; 159  : 			//
; 160  : 			ANTLR3_FPRINTF(stderr, "ANTLR3: An attempt was made to add a child list to itself!\n");

  0006c	b9 02 00 00 00	 mov	 ecx, 2
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5a@
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fprintf

; 161  : 			return;

  00086	e9 1c 01 00 00	 jmp	 $LN1@addChild
$LN8@addChild:

; 162  : 		}
; 163  : 
; 164  :         // Add all of the children's children to this list
; 165  :         //
; 166  :         if (child->children != NULL)

  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00090	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00095	0f 84 c8 00 00
	00		 je	 $LN9@addChild

; 167  :         {
; 168  :             if (tree->children == NULL)

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  000a0	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000a5	75 2e		 jne	 SHORT $LN10@addChild

; 169  :             {
; 170  :                 // We are build ing the tree structure here, so we need not
; 171  :                 // worry about duplication of pointers as the tree node
; 172  :                 // factory will only clean up each node once. So we just
; 173  :                 // copy in the child's children pointer as the child is
; 174  :                 // a nil node (has not root itself).
; 175  :                 //
; 176  :                 tree->children = child->children;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  000ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  000b1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b5	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 177  :                 child->children = NULL;

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  000be	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 178  :                 freshenPACIndexesAll(tree);

  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  000cb	e8 00 00 00 00	 call	 freshenPACIndexesAll

; 179  :                 
; 180  :             }

  000d0	e9 8e 00 00 00	 jmp	 $LN11@addChild
$LN10@addChild:

; 181  :             else
; 182  :             {
; 183  :                 // Need to copy the children
; 184  :                 //
; 185  :                 n = child->children->size(child->children);

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  000da	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  000e3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e7	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  000ed	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 186  : 
; 187  :                 for (i = 0; i < n; i++)

  000f1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000f9	eb 0a		 jmp	 SHORT $LN4@addChild
$LN2@addChild:
  000fb	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@addChild:
  00105	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00109	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0010d	73 54		 jae	 SHORT $LN3@addChild

; 188  :                 {
; 189  :                     pANTLR3_BASE_TREE entry;
; 190  :                     entry = child->children->get(child->children, i);

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00114	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00118	8b 54 24 24	 mov	 edx, DWORD PTR i$[rsp]
  0011c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00121	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00125	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0012b	48 89 44 24 28	 mov	 QWORD PTR entry$1[rsp], rax

; 191  : 
; 192  :                     // ANTLR3 lists can be sparse, unlike Array Lists
; 193  :                     //
; 194  :                     if (entry != NULL)

  00130	48 83 7c 24 28
	00		 cmp	 QWORD PTR entry$1[rsp], 0
  00136	74 29		 je	 SHORT $LN12@addChild

; 195  :                     {
; 196  :                         tree->children->add(tree->children, entry, (void (ANTLR3_CDECL *) (void *))child->free);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0013d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00141	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00146	4c 8b 81 f8 00
	00 00		 mov	 r8, QWORD PTR [rcx+248]
  0014d	48 8b 54 24 28	 mov	 rdx, QWORD PTR entry$1[rsp]
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00157	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0015b	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]
$LN12@addChild:

; 197  :                     }
; 198  :                 }

  00161	eb 98		 jmp	 SHORT $LN2@addChild
$LN3@addChild:
$LN11@addChild:
$LN9@addChild:

; 199  :             }
; 200  : 		}
; 201  : 	}

  00163	eb 42		 jmp	 SHORT $LN7@addChild
$LN6@addChild:

; 202  : 	else
; 203  : 	{
; 204  : 		// Tree we are adding is not a Nil and might have children to copy
; 205  : 		//
; 206  : 		if  (tree->children == NULL)

  00165	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0016a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0016f	75 0d		 jne	 SHORT $LN13@addChild

; 207  : 		{
; 208  : 			// No children in the tree we are adding to, so create a new list on
; 209  : 			// the fly to hold them.
; 210  : 			//
; 211  : 			tree->createChildrenList(tree);

  00171	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00176	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0017b	ff 50 40	 call	 QWORD PTR [rax+64]
$LN13@addChild:

; 212  : 		}
; 213  : 
; 214  : 		tree->children->add(tree->children, child, (void (ANTLR3_CDECL *)(void *))child->free);

  0017e	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00183	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00187	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  0018c	4c 8b 81 f8 00
	00 00		 mov	 r8, QWORD PTR [rcx+248]
  00193	48 8b 54 24 48	 mov	 rdx, QWORD PTR child$[rsp]
  00198	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0019d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001a1	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]
$LN7@addChild:
$LN1@addChild:

; 215  : 		
; 216  : 	}
; 217  : }

  001a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ab	5f		 pop	 rdi
  001ac	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getFirstChildWithType
_TEXT	SEGMENT
i$ = 32
cs$ = 36
t$ = 40
tree$ = 64
type$ = 72
getFirstChildWithType PROC				; COMDAT

; 96   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 97   : 	ANTLR3_UINT32   i;
; 98   : 	ANTLR3_UINT32   cs;
; 99   : 
; 100  : 	pANTLR3_BASE_TREE	t;
; 101  : 	if	(tree->children != NULL)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00027	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002c	74 7a		 je	 SHORT $LN5@getFirstCh

; 102  : 	{
; 103  : 		cs	= tree->children->size(tree->children);

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00046	89 44 24 24	 mov	 DWORD PTR cs$[rsp], eax

; 104  : 		for	(i = 0; i < cs; i++)

  0004a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00052	eb 0a		 jmp	 SHORT $LN4@getFirstCh
$LN2@getFirstCh:
  00054	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@getFirstCh:
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR cs$[rsp]
  00062	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00066	73 40		 jae	 SHORT $LN3@getFirstCh

; 105  : 		{
; 106  : 			t = (pANTLR3_BASE_TREE) (tree->children->get(tree->children, i));

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0006d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00071	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0007a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007e	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00084	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 107  : 			if  (tree->getType(t) == type)

  00089	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00093	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00099	3b 44 24 48	 cmp	 eax, DWORD PTR type$[rsp]
  0009d	75 07		 jne	 SHORT $LN6@getFirstCh

; 108  : 			{
; 109  : 				return  (pANTLR3_BASE_TREE)t;

  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  000a4	eb 04		 jmp	 SHORT $LN1@getFirstCh
$LN6@getFirstCh:

; 110  : 			}
; 111  : 		}

  000a6	eb ac		 jmp	 SHORT $LN2@getFirstCh
$LN3@getFirstCh:
$LN5@getFirstCh:

; 112  : 	}
; 113  : 	return  NULL;

  000a8	33 c0		 xor	 eax, eax
$LN1@getFirstCh:

; 114  : }

  000aa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
getFirstChildWithType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getLine
_TEXT	SEGMENT
tree$ = 16
getLine	PROC						; COMDAT

; 91   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 92   : 	return  0;

  00006	33 c0		 xor	 eax, eax

; 93   : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
tree$ = 16
getCharPositionInLine PROC				; COMDAT

; 85   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 86   : 	return  0;

  00006	33 c0		 xor	 eax, eax

; 87   : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getChildCount
_TEXT	SEGMENT
tree$ = 48
getChildCount PROC					; COMDAT

; 132  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 133  : 	if	(tree->children == NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00023	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00028	75 06		 jne	 SHORT $LN2@getChildCo

; 134  : 	{
; 135  : 		return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 1a		 jmp	 SHORT $LN1@getChildCo

; 136  : 	}

  0002e	eb 18		 jmp	 SHORT $LN3@getChildCo
$LN2@getChildCo:

; 137  : 	else
; 138  : 	{
; 139  : 		return	tree->children->size(tree->children);

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0003e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00042	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
$LN3@getChildCo:
$LN1@getChildCo:

; 140  : 	}
; 141  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getChild
_TEXT	SEGMENT
tree$ = 48
i$ = 56
getChild PROC						; COMDAT

; 120  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 121  : 	if	(      tree->children == NULL
; 122  : 		|| i >= tree->children->size(tree->children))

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00027	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002c	74 1e		 je	 SHORT $LN3@getChild
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00046	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0004a	72 04		 jb	 SHORT $LN2@getChild
$LN3@getChild:

; 123  : 	{
; 124  : 		return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 1c		 jmp	 SHORT $LN1@getChild
$LN2@getChild:

; 125  : 	}
; 126  : 	return  tree->children->get(tree->children, i);

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00055	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00059	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00062	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00066	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
$LN1@getChild:

; 127  : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT antlr3BaseTreeNew
_TEXT	SEGMENT
tree$ = 16
antlr3BaseTreeNew PROC					; COMDAT

; 59   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 60   : 	/* api */
; 61   : 	tree->getChild				= getChild;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  00012	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 62   : 	tree->getChildCount			= getChildCount;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  00022	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 63   : 	tree->addChild				= (void (*)(pANTLR3_BASE_TREE, void *))(addChild);

  00029	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00035	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 64   : 	tree->addChildren			= addChildren;

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChildren
  00045	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 65   : 	tree->setChild				= setChild;

  00049	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChild
  00055	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 66   : 	tree->deleteChild			= deleteChild;

  0005c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:deleteChild
  00068	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 67   : 	tree->dupTree				= dupTree;

  0006c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  00078	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 68   : 	tree->toStringTree			= toStringTree;

  0007c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStringTree
  00088	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 69   : 	tree->getCharPositionInLine	= getCharPositionInLine;

  0008f	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  0009b	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 70   : 	tree->getLine				= getLine;

  0009f	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  000ab	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 71   : 	tree->replaceChildren		= replaceChildren;

  000b2	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:replaceChildren
  000be	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 72   : 	tree->freshenPACIndexesAll	= freshenPACIndexesAll;

  000c2	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freshenPACIndexesAll
  000ce	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 73   : 	tree->freshenPACIndexes		= freshenPACIndexes;

  000d5	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freshenPACIndexes
  000e1	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 74   : 	tree->getFirstChildWithType	= (void *(*)(pANTLR3_BASE_TREE, ANTLR3_UINT32))(getFirstChildWithType);

  000e8	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getFirstChildWithType
  000f4	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 75   : 	tree->children				= NULL;

  000fb	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00100	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 76   : 	tree->strFactory			= NULL;

  00108	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0010d	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 77   : 
; 78   : 	/* Rest must be filled in by caller.
; 79   : 	*/
; 80   : 	return  tree;

  00115	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]

; 81   : }

  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
antlr3BaseTreeNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00049	e8 00 00 00 00	 call	 _vfprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 838  : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
