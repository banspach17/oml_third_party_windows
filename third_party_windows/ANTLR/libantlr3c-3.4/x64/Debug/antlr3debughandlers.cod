; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3DebugListenerNew
PUBLIC	antlr3DebugListenerNewPort
PUBLIC	serializeText
PUBLIC	serializeToken
PUBLIC	serializeNode
PUBLIC	??_C@_09ILMAJDDB@ANTLR?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clien@ ; `string'
PUBLIC	??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and?5@ ; `string'
PUBLIC	??_C@_02KINNFLEC@?7?$CC?$AA@			; `string'
PUBLIC	??_C@_03IEFOOEDL@?$CF0A?$AA@			; `string'
PUBLIC	??_C@_03PJCJBAHO@?$CF0D?$AA@			; `string'
PUBLIC	??_C@_03MMIJIMKH@?$CF25?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0O@CLDGECJA@consumeToken?7?$AA@		; `string'
PUBLIC	??_C@_0BE@GEGFGNHF@consumeHiddenToken?7?$AA@	; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_C@_03LFAOPKED@LT?7?$AA@			; `string'
PUBLIC	??_C@_08JOJCKFBH@mark?7?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@DJLPLDGG@rewind?7?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_07EBOLPGDK@rewind?6?$AA@			; `string'
PUBLIC	??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0N@DCBHEMKM@beginResync?6?$AA@		; `string'
PUBLIC	??_C@_0L@KHCEOHOJ@endResync?6?$AA@		; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7?$AA@ ; `string'
PUBLIC	??_C@_0L@KANKBBAE@terminate?6?$AA@		; `string'
PUBLIC	??_C@_0N@CLFGHGNF@consumeNode?7?$AA@		; `string'
PUBLIC	??_C@_03KELPNMOF@LN?7?$AA@			; `string'
PUBLIC	??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5?$AA@ ; `string'
PUBLIC	??_C@_0L@OOIEOANM@errorNode?7?$AA@		; `string'
PUBLIC	??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6?$AA@ ; `string'
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	accept:PROC
EXTRN	bind:PROC
EXTRN	closesocket:PROC
EXTRN	htonl:PROC
EXTRN	htons:PROC
EXTRN	listen:PROC
EXTRN	recv:PROC
EXTRN	send:PROC
EXTRN	setsockopt:PROC
EXTRN	shutdown:PROC
EXTRN	socket:PROC
EXTRN	WSAStartup:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3DebugListenerNew DD imagerel $LN4
	DD	imagerel $LN4+672
	DD	imagerel $unwind$antlr3DebugListenerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$handshake DD imagerel handshake
	DD	imagerel handshake+643
	DD	imagerel $unwind$handshake
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterRule DD imagerel enterRule
	DD	imagerel enterRule+155
	DD	imagerel $unwind$enterRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterAlt DD imagerel enterAlt
	DD	imagerel enterAlt+141
	DD	imagerel $unwind$enterAlt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitRule DD imagerel exitRule
	DD	imagerel exitRule+155
	DD	imagerel $unwind$exitRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterSubRule DD imagerel enterSubRule
	DD	imagerel enterSubRule+141
	DD	imagerel $unwind$enterSubRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitSubRule DD imagerel exitSubRule
	DD	imagerel exitSubRule+141
	DD	imagerel $unwind$exitSubRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterDecision DD imagerel enterDecision
	DD	imagerel enterDecision+141
	DD	imagerel $unwind$enterDecision
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitDecision DD imagerel exitDecision
	DD	imagerel exitDecision+141
	DD	imagerel $unwind$exitDecision
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeToken DD imagerel consumeToken
	DD	imagerel consumeToken+120
	DD	imagerel $unwind$consumeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeHiddenToken DD imagerel consumeHiddenToken
	DD	imagerel consumeHiddenToken+120
	DD	imagerel $unwind$consumeHiddenToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LT DD	imagerel LT
	DD	imagerel LT+174
	DD	imagerel $unwind$LT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mark DD	imagerel mark
	DD	imagerel mark+156
	DD	imagerel $unwind$mark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindMark DD imagerel rewindMark
	DD	imagerel rewindMark+156
	DD	imagerel $unwind$rewindMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindLast DD imagerel rewindLast
	DD	imagerel rewindLast+53
	DD	imagerel $unwind$rewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginBacktrack DD imagerel beginBacktrack
	DD	imagerel beginBacktrack+141
	DD	imagerel $unwind$beginBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endBacktrack DD imagerel endBacktrack
	DD	imagerel endBacktrack+157
	DD	imagerel $unwind$endBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$location DD imagerel location
	DD	imagerel location+154
	DD	imagerel $unwind$location
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recognitionException DD imagerel recognitionException
	DD	imagerel recognitionException+188
	DD	imagerel $unwind$recognitionException
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginResync DD imagerel beginResync
	DD	imagerel beginResync+53
	DD	imagerel $unwind$beginResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endResync DD imagerel endResync
	DD	imagerel endResync+53
	DD	imagerel $unwind$endResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$semanticPredicate DD imagerel semanticPredicate
	DD	imagerel semanticPredicate+533
	DD	imagerel $unwind$semanticPredicate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$commence DD imagerel commence
	DD	imagerel commence+8
	DD	imagerel $unwind$commence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$terminate DD imagerel terminate
	DD	imagerel terminate+63
	DD	imagerel $unwind$terminate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeNode DD imagerel consumeNode
	DD	imagerel consumeNode+139
	DD	imagerel $unwind$consumeNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LTT DD	imagerel LTT
	DD	imagerel LTT+185
	DD	imagerel $unwind$LTT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nilNode DD imagerel nilNode
	DD	imagerel nilNode+175
	DD	imagerel $unwind$nilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$errorNode DD imagerel errorNode
	DD	imagerel errorNode+353
	DD	imagerel $unwind$errorNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createNode DD imagerel createNode
	DD	imagerel createNode+392
	DD	imagerel $unwind$createNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createNodeTok DD imagerel createNodeTok
	DD	imagerel createNodeTok+238
	DD	imagerel $unwind$createNodeTok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRoot DD imagerel becomeRoot
	DD	imagerel becomeRoot+252
	DD	imagerel $unwind$becomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+252
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenBoundaries DD imagerel setTokenBoundaries
	DD	imagerel setTokenBoundaries+204
	DD	imagerel $unwind$setTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ack DD	imagerel ack
	DD	imagerel ack+151
	DD	imagerel $unwind$ack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3DebugListenerNewPort DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$antlr3DebugListenerNewPort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sockSend DD imagerel sockSend
	DD	imagerel sockSend+156
	DD	imagerel $unwind$sockSend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$transmit DD imagerel transmit
	DD	imagerel transmit+83
	DD	imagerel $unwind$transmit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeText DD imagerel $LN13
	DD	imagerel $LN13+255
	DD	imagerel $unwind$serializeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeToken DD imagerel $LN4
	DD	imagerel $LN4+535
	DD	imagerel $unwind$serializeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeNode DD imagerel $LN7
	DD	imagerel $LN7+760
	DD	imagerel $unwind$serializeNode
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6?$AA@ DB 'becomeRoot', 09H
	DB	'%d', 09H, '%d', 09H, '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6?$AA@ DB 'addChild', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6?$AA@ DB 'becomeRoot', 09H, '%'
	DB	'd', 09H, '%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6?$AA@ DB 'createNode', 09H, '%'
	DB	'd', 09H, '%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOIEOANM@errorNode?7?$AA@
CONST	SEGMENT
??_C@_0L@OOIEOANM@errorNode?7?$AA@ DB 'errorNode', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5?$AA@
CONST	SEGMENT
??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5?$AA@ DB 'createNodeFromT'
	DB	'okenElements ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6?$AA@ DB 'nilNode', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KELPNMOF@LN?7?$AA@
CONST	SEGMENT
??_C@_03KELPNMOF@LN?7?$AA@ DB 'LN', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLFGHGNF@consumeNode?7?$AA@
CONST	SEGMENT
??_C@_0N@CLFGHGNF@consumeNode?7?$AA@ DB 'consumeNode', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KANKBBAE@terminate?6?$AA@
CONST	SEGMENT
??_C@_0L@KANKBBAE@terminate?6?$AA@ DB 'terminate', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7?$AA@
CONST	SEGMENT
??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7?$AA@ DB 'semanticPredicate', 09H
	DB	'%s', 09H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHCEOHOJ@endResync?6?$AA@
CONST	SEGMENT
??_C@_0L@KHCEOHOJ@endResync?6?$AA@ DB 'endResync', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCBHEMKM@beginResync?6?$AA@
CONST	SEGMENT
??_C@_0N@DCBHEMKM@beginResync?6?$AA@ DB 'beginResync', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6?$AA@ DB 'excep'
	DB	'tion', 09H, '%s', 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6?$AA@ DB 'location', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6?$AA@ DB 'endBacktrack', 09H
	DB	'%d', 09H, '%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6?$AA@ DB 'beginBacktrack', 09H, '%'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBOLPGDK@rewind?6?$AA@
CONST	SEGMENT
??_C@_07EBOLPGDK@rewind?6?$AA@ DB 'rewind', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJLPLDGG@rewind?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@DJLPLDGG@rewind?7?$CFd?6?$AA@ DB 'rewind', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOJCKFBH@mark?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_08JOJCKFBH@mark?7?$CFd?6?$AA@ DB 'mark', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFAOPKED@LT?7?$AA@
CONST	SEGMENT
??_C@_03LFAOPKED@LT?7?$AA@ DB 'LT', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEGFGNHF@consumeHiddenToken?7?$AA@
CONST	SEGMENT
??_C@_0BE@GEGFGNHF@consumeHiddenToken?7?$AA@ DB 'consumeHiddenToken', 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLDGECJA@consumeToken?7?$AA@
CONST	SEGMENT
??_C@_0O@CLDGECJA@consumeToken?7?$AA@ DB 'consumeToken', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6?$AA@ DB 'exitDecision', 09H, '%d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6?$AA@ DB 'enterDecision', 09H, '%'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6?$AA@ DB 'exitSubRule', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6?$AA@ DB 'enterSubRule', 09H, '%d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6?$AA@ DB 'exitRule', 09H, '%s', 09H
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6?$AA@ DB 'enterAlt', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6?$AA@ DB 'enterRule', 09H, '%'
	DB	's', 09H, '%s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMIJIMKH@?$CF25?$AA@
CONST	SEGMENT
??_C@_03MMIJIMKH@?$CF25?$AA@ DB '%25', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJCJBAHO@?$CF0D?$AA@
CONST	SEGMENT
??_C@_03PJCJBAHO@?$CF0D?$AA@ DB '%0D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEFOOEDL@?$CF0A?$AA@
CONST	SEGMENT
??_C@_03IEFOOEDL@?$CF0A?$AA@ DB '%0A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KINNFLEC@?7?$CC?$AA@
CONST	SEGMENT
??_C@_02KINNFLEC@?7?$CC?$AA@ DB 09H, '"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and?5@
CONST	SEGMENT
??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and?5@ DB 'Receiv'
	DB	'ed char count was %d, and last char received was %02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clien@
CONST	SEGMENT
??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clien@ DB 'Exiting debu'
	DB	'gger as remote client closed the socket', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6?$AA@ DB 'grammar "%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILMAJDDB@ANTLR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_09ILMAJDDB@ANTLR?5?$CFd?6?$AA@ DB 'ANTLR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeNode DD 022301H
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeToken DD 022301H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeText DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$transmit DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sockSend DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3DebugListenerNewPort DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ack DD	021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
ack$rtcVarDesc DD 024H
	DD	01H
	DQ	FLAT:ack$rtcName$0
	ORG $+48
ack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ack$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenBoundaries DD 034519H
	DD	01c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
setTokenBoundaries$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
setTokenBoundaries$rtcVarDesc DD 040H
	DD	080H
	DQ	FLAT:setTokenBoundaries$rtcName$0
	ORG $+48
setTokenBoundaries$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:setTokenBoundaries$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 034019H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addChild$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
addChild$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:addChild$rtcName$0
	ORG $+48
addChild$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addChild$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRoot DD 034019H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
becomeRoot$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
becomeRoot$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:becomeRoot$rtcName$0
	ORG $+48
becomeRoot$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:becomeRoot$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createNodeTok DD 034019H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
createNodeTok$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
createNodeTok$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:createNodeTok$rtcName$0
	ORG $+48
createNodeTok$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:createNodeTok$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createNode DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$errorNode DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nilNode DD 033b19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
nilNode$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
nilNode$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:nilNode$rtcName$0
	ORG $+48
nilNode$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:nilNode$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LTT DD	022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeNode DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$terminate DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$commence DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$semanticPredicate DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endResync DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginResync DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recognitionException DD 033b19H
	DD	02c0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
recognitionException$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
recognitionException$rtcVarDesc DD 040H
	DD	0100H
	DQ	FLAT:recognitionException$rtcName$0
	ORG $+48
recognitionException$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:recognitionException$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$location DD 033f19H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
location$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
location$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:location$rtcName$0
	ORG $+48
location$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:location$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endBacktrack DD 033f19H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
endBacktrack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
endBacktrack$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:endBacktrack$rtcName$0
	ORG $+48
endBacktrack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:endBacktrack$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginBacktrack DD 033a19H
	DD	01a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
beginBacktrack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
beginBacktrack$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:beginBacktrack$rtcName$0
	ORG $+48
beginBacktrack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:beginBacktrack$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindLast DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindMark DD 033b19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
rewindMark$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
rewindMark$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:rewindMark$rtcName$0
	ORG $+48
rewindMark$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:rewindMark$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mark DD	033b19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
mark$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
mark$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:mark$rtcName$0
	ORG $+48
mark$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:mark$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LT DD	022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeHiddenToken DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeToken DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitDecision DD 033a19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitDecision$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitDecision$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitDecision$rtcName$0
	ORG $+48
exitDecision$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitDecision$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterDecision DD 033a19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterDecision$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterDecision$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterDecision$rtcName$0
	ORG $+48
enterDecision$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterDecision$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitSubRule DD 033a19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitSubRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitSubRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitSubRule$rtcName$0
	ORG $+48
exitSubRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitSubRule$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterSubRule DD 033a19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterSubRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterSubRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterSubRule$rtcName$0
	ORG $+48
enterSubRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterSubRule$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitRule DD 034019H
	DD	04a0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitRule$rtcName$0
	ORG $+48
exitRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitRule$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterAlt DD 033a19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterAlt$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterAlt$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterAlt$rtcName$0
	ORG $+48
enterAlt$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterAlt$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterRule DD 034019H
	DD	04a0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterRule$rtcName$0
	ORG $+48
enterRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterRule$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handshake DD 033619H
	DD	07a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	03c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
handshake$rtcName$0 DB 063H
	DB	06cH
	DB	069H
	DB	065H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+1
handshake$rtcName$1 DB 073H
	DB	065H
	DB	072H
	DB	076H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
handshake$rtcName$2 DB 06dH
	DB	065H
	DB	073H
	DB	073H
	DB	061H
	DB	067H
	DB	065H
	DB	00H
handshake$rtcName$3 DB 073H
	DB	06fH
	DB	063H
	DB	06bH
	DB	061H
	DB	064H
	DB	064H
	DB	072H
	DB	05fH
	DB	06cH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+3
handshake$rtcName$4 DB 06fH
	DB	070H
	DB	074H
	DB	056H
	DB	061H
	DB	06cH
	DB	00H
	ORG $+1
handshake$rtcName$5 DB 077H
	DB	073H
	DB	061H
	DB	044H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+8
handshake$rtcVarDesc DD 0210H
	DD	0198H
	DQ	FLAT:handshake$rtcName$5
	DD	01e4H
	DD	04H
	DQ	FLAT:handshake$rtcName$4
	DD	01c4H
	DD	04H
	DQ	FLAT:handshake$rtcName$3
	DD	0b0H
	DD	0100H
	DQ	FLAT:handshake$rtcName$2
	DD	078H
	DD	010H
	DQ	FLAT:handshake$rtcName$1
	DD	048H
	DD	010H
	DQ	FLAT:handshake$rtcName$0
	ORG $+288
handshake$rtcFrameData DD 06H
	DD	00H
	DQ	FLAT:handshake$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3DebugListenerNew DD 021501H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeNode
_TEXT	SEGMENT
token$ = 32
tv245 = 40
tv241 = 48
tv238 = 56
tv235 = 64
tv233 = 72
tv227 = 80
delboy$ = 112
node$ = 120
serializeNode PROC					; COMDAT

; 465  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 466  : 	pANTLR3_COMMON_TOKEN	token;
; 467  : 
; 468  : 
; 469  : 	// Do we already have a serialization buffer?
; 470  : 	//
; 471  : 	if	(delboy->tokenString == NULL)

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00028	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002d	75 33		 jne	 SHORT $LN2@serializeN

; 472  : 	{
; 473  : 		// No, so create one, using the string factory that
; 474  : 		// the grammar name used, which is guaranteed to exist.
; 475  : 		// 64 bytes will do us here for starters. 
; 476  : 		//
; 477  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00034	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0003d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00041	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00044	48 89 4c 24 28	 mov	 QWORD PTR tv245[rsp], rcx
  00049	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR tv245[rsp]
  00056	ff 50 18	 call	 QWORD PTR [rax+24]
  00059	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@serializeN:

; 478  : 	}
; 479  : 
; 480  : 	// Empty string
; 481  : 	//
; 482  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  00062	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00072	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0007b	ff 50 20	 call	 QWORD PTR [rax+32]

; 483  : 
; 484  : 	// Protect against bugs/errors etc
; 485  : 	//
; 486  : 	if	(node == NULL)

  0007e	48 83 7c 24 78
	00		 cmp	 QWORD PTR node$[rsp], 0
  00084	75 0e		 jne	 SHORT $LN3@serializeN

; 487  : 	{
; 488  : 		return delboy->tokenString;

  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0008b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008f	e9 5e 02 00 00	 jmp	 $LN1@serializeN
$LN3@serializeN:

; 489  : 	}
; 490  : 
; 491  : 	// Now we serialize the elements of the node.Note that the debugger only
; 492  : 	// uses 32 bits.
; 493  : 	//
; 494  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00099	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0009d	ba 09 00 00 00	 mov	 edx, 9
  000a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000a7	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ab	ff 50 70	 call	 QWORD PTR [rax+112]

; 495  : 
; 496  : 	// Adaptor ID
; 497  : 	//
; 498  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, node));

  000ae	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000b3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000b7	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  000bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000c1	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000c5	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  000cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000d0	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000d4	48 89 4c 24 30	 mov	 QWORD PTR tv241[rsp], rcx
  000d9	8b d0		 mov	 edx, eax
  000db	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000e0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv241[rsp]
  000e9	ff 50 78	 call	 QWORD PTR [rax+120]

; 499  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000f1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f5	ba 09 00 00 00	 mov	 edx, 9
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ff	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00103	ff 50 70	 call	 QWORD PTR [rax+112]

; 500  : 
; 501  : 	// Type of the current token (which may be imaginary)
; 502  : 	//
; 503  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, node));

  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0010b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0010f	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00119	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0011d	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
  00123	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00128	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0012c	48 89 4c 24 38	 mov	 QWORD PTR tv238[rsp], rcx
  00131	8b d0		 mov	 edx, eax
  00133	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00138	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0013c	48 8b 44 24 38	 mov	 rax, QWORD PTR tv238[rsp]
  00141	ff 50 78	 call	 QWORD PTR [rax+120]

; 504  : 
; 505  : 	// See if we have an actual token or just an imaginary
; 506  : 	//
; 507  : 	token	= delboy->adaptor->getToken(delboy->adaptor, node);

  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00149	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0014d	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  00152	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00157	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0015b	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
  00161	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 508  : 
; 509  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00166	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0016b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0016f	ba 09 00 00 00	 mov	 edx, 9
  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00179	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0017d	ff 50 70	 call	 QWORD PTR [rax+112]

; 510  : 	if	(token != NULL)

  00180	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00186	74 7e		 je	 SHORT $LN4@serializeN

; 511  : 	{
; 512  : 		// Real token
; 513  : 		//
; 514  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getLine(token)));

  00188	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00192	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00198	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0019d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001a1	48 89 4c 24 40	 mov	 QWORD PTR tv235[rsp], rcx
  001a6	8b d0		 mov	 edx, eax
  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001ad	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv235[rsp]
  001b6	ff 50 78	 call	 QWORD PTR [rax+120]

; 515  : 		delboy->tokenString->addc(delboy->tokenString, ' ');

  001b9	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001be	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001c2	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  001cc	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001d0	ff 50 70	 call	 QWORD PTR [rax+112]

; 516  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getCharPositionInLine(token)));

  001d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  001dd	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  001e8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001ec	48 89 4c 24 48	 mov	 QWORD PTR tv233[rsp], rcx
  001f1	8b d0		 mov	 edx, eax
  001f3	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001f8	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001fc	48 8b 44 24 48	 mov	 rax, QWORD PTR tv233[rsp]
  00201	ff 50 78	 call	 QWORD PTR [rax+120]

; 517  : 	}

  00204	eb 4e		 jmp	 SHORT $LN5@serializeN
$LN4@serializeN:

; 518  : 	else
; 519  : 	{
; 520  : 		// Imaginary tokens have no location
; 521  : 		//
; 522  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  00206	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0020b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0020f	ba ff ff ff ff	 mov	 edx, -1
  00214	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00219	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0021d	ff 50 78	 call	 QWORD PTR [rax+120]

; 523  : 		delboy->tokenString->addc(delboy->tokenString, '\t');

  00220	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00225	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00229	ba 09 00 00 00	 mov	 edx, 9
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00233	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00237	ff 50 70	 call	 QWORD PTR [rax+112]

; 524  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  0023a	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0023f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00243	ba ff ff ff ff	 mov	 edx, -1
  00248	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0024d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00251	ff 50 78	 call	 QWORD PTR [rax+120]
$LN5@serializeN:

; 525  : 	}
; 526  : 
; 527  : 	// Start Index of the node
; 528  : 	//
; 529  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00259	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0025d	ba 09 00 00 00	 mov	 edx, 9
  00262	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00267	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0026b	ff 50 70	 call	 QWORD PTR [rax+112]

; 530  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_UINT32)(delboy->adaptor->getTokenStartIndex(delboy->adaptor, node)));

  0026e	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00273	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00277	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00281	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00285	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0028b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00290	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00294	48 89 4c 24 50	 mov	 QWORD PTR tv227[rsp], rcx
  00299	8b d0		 mov	 edx, eax
  0029b	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002a0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  002a4	48 8b 44 24 50	 mov	 rax, QWORD PTR tv227[rsp]
  002a9	ff 50 78	 call	 QWORD PTR [rax+120]

; 531  : 
; 532  : 	// Now send the text that the node represents.
; 533  : 	//
; 534  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, node));

  002ac	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002b1	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002b5	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  002ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  002bf	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002c3	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  002c9	48 8b d0	 mov	 rdx, rax
  002cc	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002d1	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  002d5	e8 00 00 00 00	 call	 serializeText

; 535  : 
; 536  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 537  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 538  : 	// must force encode it. We have a method to do this in the string class, but
; 539  : 	// there is no utf8 string implementation as of yet
; 540  : 	//
; 541  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  002da	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002df	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  002e8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002ec	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
$LN1@serializeN:

; 542  : }

  002f2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002f6	5f		 pop	 rdi
  002f7	c3		 ret	 0
serializeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeToken
_TEXT	SEGMENT
tv195 = 32
tv193 = 40
tv191 = 48
tv189 = 56
tv187 = 64
tv185 = 72
delboy$ = 96
t$ = 104
serializeToken PROC					; COMDAT

; 419  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 420  : 	// Do we already have a serialization buffer?
; 421  : 	//
; 422  : 	if	(delboy->tokenString == NULL)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00028	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002d	75 33		 jne	 SHORT $LN2@serializeT

; 423  : 	{
; 424  : 		// No, so create one, using the string factory that
; 425  : 		// the grammar name used, which is guaranteed to exist.
; 426  : 		// 64 bytes will do us here for starters. 
; 427  : 		//
; 428  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00034	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0003d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00041	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00044	48 89 4c 24 20	 mov	 QWORD PTR tv195[rsp], rcx
  00049	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR tv195[rsp]
  00056	ff 50 18	 call	 QWORD PTR [rax+24]
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@serializeT:

; 429  : 	}
; 430  : 
; 431  : 	// Empty string
; 432  : 	//
; 433  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  00062	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00072	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0007b	ff 50 20	 call	 QWORD PTR [rax+32]

; 434  : 
; 435  : 	// Now we serialize the elements of the token.Note that the debugger only
; 436  : 	// uses 32 bits.
; 437  : 	//
; 438  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getTokenIndex(t)));

  0007e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  00088	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00093	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00097	48 89 4c 24 28	 mov	 QWORD PTR tv193[rsp], rcx
  0009c	8b d0		 mov	 edx, eax
  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000a3	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR tv193[rsp]
  000ac	ff 50 78	 call	 QWORD PTR [rax+120]

; 439  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000b4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b8	ba 09 00 00 00	 mov	 edx, 9
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  000c2	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000c6	ff 50 70	 call	 QWORD PTR [rax+112]

; 440  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getType(t)));

  000c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  000ce	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  000d3	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  000de	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000e2	48 89 4c 24 30	 mov	 QWORD PTR tv191[rsp], rcx
  000e7	8b d0		 mov	 edx, eax
  000e9	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000ee	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000f2	48 8b 44 24 30	 mov	 rax, QWORD PTR tv191[rsp]
  000f7	ff 50 78	 call	 QWORD PTR [rax+120]

; 441  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000fa	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000ff	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00103	ba 09 00 00 00	 mov	 edx, 9
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0010d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00111	ff 50 70	 call	 QWORD PTR [rax+112]

; 442  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getChannel(t)));

  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00119	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  0011e	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00124	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00129	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0012d	48 89 4c 24 38	 mov	 QWORD PTR tv189[rsp], rcx
  00132	8b d0		 mov	 edx, eax
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00139	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0013d	48 8b 44 24 38	 mov	 rax, QWORD PTR tv189[rsp]
  00142	ff 50 78	 call	 QWORD PTR [rax+120]

; 443  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  0014a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0014e	ba 09 00 00 00	 mov	 edx, 9
  00153	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00158	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0015c	ff 50 70	 call	 QWORD PTR [rax+112]

; 444  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getLine(t)));

  0015f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00164	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  00169	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00174	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00178	48 89 4c 24 40	 mov	 QWORD PTR tv187[rsp], rcx
  0017d	8b d0		 mov	 edx, eax
  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00184	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR tv187[rsp]
  0018d	ff 50 78	 call	 QWORD PTR [rax+120]

; 445  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00190	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00195	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00199	ba 09 00 00 00	 mov	 edx, 9
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  001a3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001a7	ff 50 70	 call	 QWORD PTR [rax+112]

; 446  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getCharPositionInLine(t)));

  001aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  001af	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  001b4	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  001bf	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001c3	48 89 4c 24 48	 mov	 QWORD PTR tv185[rsp], rcx
  001c8	8b d0		 mov	 edx, eax
  001ca	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001cf	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001d3	48 8b 44 24 48	 mov	 rax, QWORD PTR tv185[rsp]
  001d8	ff 50 78	 call	 QWORD PTR [rax+120]

; 447  : 
; 448  : 	// Now send the text that the token represents.
; 449  : 	//
; 450  : 	serializeText(delboy->tokenString, t->getText(t));

  001db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  001e0	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  001e5	ff 50 78	 call	 QWORD PTR [rax+120]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001f0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001f4	e8 00 00 00 00	 call	 serializeText

; 451  : 
; 452  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 453  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 454  : 	// must force encode it. We have a method to do this in the string class, but
; 455  : 	// it returns malloc space that we must free afterwards.
; 456  : 	//
; 457  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  001f9	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001fe	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00202	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00207	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0020b	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 458  : }

  00211	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00215	5f		 pop	 rdi
  00216	c3		 ret	 0
serializeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeText
_TEXT	SEGMENT
c$ = 32
character$ = 36
tv75 = 40
buffer$ = 64
text$ = 72
serializeText PROC					; COMDAT

; 366  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 367  : 	ANTLR3_UINT32	c;
; 368  : 	ANTLR3_UCHAR	character;
; 369  : 
; 370  : 	// strings lead in with a "
; 371  : 	//
; 372  : 	buffer->append(buffer, "\t\"");

  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KINNFLEC@?7?$CC?$AA@
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  00034	ff 50 30	 call	 QWORD PTR [rax+48]

; 373  : 
; 374  : 	if	(text == NULL)

  00037	48 83 7c 24 48
	00		 cmp	 QWORD PTR text$[rsp], 0
  0003d	75 05		 jne	 SHORT $LN7@serializeT

; 375  : 	{
; 376  : 		return;

  0003f	e9 b5 00 00 00	 jmp	 $LN1@serializeT
$LN7@serializeT:

; 377  : 	}
; 378  : 
; 379  : 	// Now we replace linefeeds, newlines and the escape
; 380  : 	// leadin character '%' with their hex equivalents
; 381  : 	// prefixed by '%'
; 382  : 	//
; 383  : 	for	(c = 0; c < text->len; c++)

  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR c$[rsp], 0
  0004c	eb 0a		 jmp	 SHORT $LN4@serializeT
$LN2@serializeT:
  0004e	8b 44 24 20	 mov	 eax, DWORD PTR c$[rsp]
  00052	ff c0		 inc	 eax
  00054	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax
$LN4@serializeT:
  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR text$[rsp]
  0005d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00060	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  00064	0f 83 8f 00 00
	00		 jae	 $LN3@serializeT

; 384  : 	{
; 385  : 		switch	(character = text->charAt(text, c))

  0006a	8b 54 24 20	 mov	 edx, DWORD PTR c$[rsp]
  0006e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR text$[rsp]
  00073	48 8b 44 24 48	 mov	 rax, QWORD PTR text$[rsp]
  00078	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0007e	89 44 24 24	 mov	 DWORD PTR character$[rsp], eax
  00082	8b 44 24 24	 mov	 eax, DWORD PTR character$[rsp]
  00086	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  0008a	83 7c 24 28 0a	 cmp	 DWORD PTR tv75[rsp], 10
  0008f	74 10		 je	 SHORT $LN8@serializeT
  00091	83 7c 24 28 0d	 cmp	 DWORD PTR tv75[rsp], 13
  00096	74 1f		 je	 SHORT $LN9@serializeT
  00098	83 7c 24 28 5c	 cmp	 DWORD PTR tv75[rsp], 92	; 0000005cH
  0009d	74 2e		 je	 SHORT $LN10@serializeT
  0009f	eb 42		 jmp	 SHORT $LN11@serializeT
$LN8@serializeT:

; 386  : 		{
; 387  : 			case	'\n':
; 388  : 
; 389  : 				buffer->append(buffer, "%0A");

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03IEFOOEDL@?$CF0A?$AA@
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000b2	ff 50 30	 call	 QWORD PTR [rax+48]

; 390  : 				break;

  000b5	eb 3d		 jmp	 SHORT $LN5@serializeT
$LN9@serializeT:

; 391  : 
; 392  : 			case	'\r':
; 393  : 			
; 394  : 				buffer->append(buffer, "%0D");

  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03PJCJBAHO@?$CF0D?$AA@
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000c8	ff 50 30	 call	 QWORD PTR [rax+48]

; 395  : 				break;

  000cb	eb 27		 jmp	 SHORT $LN5@serializeT
$LN10@serializeT:

; 396  : 
; 397  : 			case	'\\':
; 398  : 
; 399  : 				buffer->append(buffer, "%25");

  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MMIJIMKH@?$CF25?$AA@
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000de	ff 50 30	 call	 QWORD PTR [rax+48]

; 400  : 				break;

  000e1	eb 11		 jmp	 SHORT $LN5@serializeT
$LN11@serializeT:

; 401  : 
; 402  : 				// Other characters: The Song Remains the Same.
; 403  : 				//
; 404  : 			default:
; 405  : 					
; 406  : 				buffer->addc(buffer, character);

  000e3	8b 54 24 24	 mov	 edx, DWORD PTR character$[rsp]
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000f1	ff 50 70	 call	 QWORD PTR [rax+112]
$LN5@serializeT:

; 407  : 				break;
; 408  : 		}
; 409  : 	}

  000f4	e9 55 ff ff ff	 jmp	 $LN2@serializeT
$LN3@serializeT:
$LN1@serializeT:

; 410  : }

  000f9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
serializeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT transmit
_TEXT	SEGMENT
delboy$ = 48
ptr$ = 56
transmit PROC						; COMDAT

; 324  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 325  : 	sockSend(delboy->socket, ptr, (int)strlen(ptr));

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	44 8b c0	 mov	 r8d, eax
  00030	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR delboy$[rsp]
  0003a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003e	e8 00 00 00 00	 call	 sockSend

; 326  : 	ack(delboy);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  00048	e8 00 00 00 00	 call	 ack

; 327  : }

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
transmit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT sockSend
_TEXT	SEGMENT
sent$ = 32
thisSend$ = 36
sock$ = 64
ptr$ = 72
len$ = 80
sockSend PROC						; COMDAT

; 166  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 167  : 	int		sent;
; 168  : 	int		thisSend;
; 169  : 
; 170  : 	sent	= 0;

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR sent$[rsp], 0
$LN2@sockSend:

; 171  : 		
; 172  : 	while	(sent < len)

  00030	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00034	39 44 24 20	 cmp	 DWORD PTR sent$[rsp], eax
  00038	7d 57		 jge	 SHORT $LN3@sockSend

; 173  : 	{
; 174  : 		// Send as many bytes as we can
; 175  : 		//
; 176  : 		thisSend =	send(sock, ptr, len - sent, 0);

  0003a	8b 44 24 20	 mov	 eax, DWORD PTR sent$[rsp]
  0003e	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00042	2b c8		 sub	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
  00046	45 33 c9	 xor	 r9d, r9d
  00049	44 8b c0	 mov	 r8d, eax
  0004c	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sock$[rsp]
  00056	e8 00 00 00 00	 call	 send
  0005b	89 44 24 24	 mov	 DWORD PTR thisSend$[rsp], eax

; 177  : 
; 178  : 		// Check for errors and tell the user if we got one
; 179  : 		//
; 180  : 		if	(thisSend	== -1)

  0005f	83 7c 24 24 ff	 cmp	 DWORD PTR thisSend$[rsp], -1
  00064	75 04		 jne	 SHORT $LN4@sockSend

; 181  : 		{
; 182  : 			return	ANTLR3_FALSE;

  00066	33 c0		 xor	 eax, eax
  00068	eb 2c		 jmp	 SHORT $LN1@sockSend
$LN4@sockSend:

; 183  : 		}
; 184  : 
; 185  : 		// Increment our offset by how many we were able to send
; 186  : 		//
; 187  : 		ptr			+= thisSend;

  0006a	48 63 44 24 24	 movsxd	 rax, DWORD PTR thisSend$[rsp]
  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ptr$[rsp]
  00074	48 03 c8	 add	 rcx, rax
  00077	48 8b c1	 mov	 rax, rcx
  0007a	48 89 44 24 48	 mov	 QWORD PTR ptr$[rsp], rax

; 188  : 		sent		+= thisSend;

  0007f	8b 44 24 24	 mov	 eax, DWORD PTR thisSend$[rsp]
  00083	8b 4c 24 20	 mov	 ecx, DWORD PTR sent$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 20	 mov	 DWORD PTR sent$[rsp], eax

; 189  : 	}

  0008f	eb 9f		 jmp	 SHORT $LN2@sockSend
$LN3@sockSend:

; 190  : 	return	ANTLR3_TRUE;

  00091	b8 01 00 00 00	 mov	 eax, 1
$LN1@sockSend:

; 191  : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
sockSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT antlr3DebugListenerNewPort
_TEXT	SEGMENT
delboy$ = 32
port$ = 64
antlr3DebugListenerNewPort PROC				; COMDAT

; 148  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 149  : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 150  : 
; 151  : 	delboy		 = antlr3DebugListenerNew();

  0001c	e8 00 00 00 00	 call	 antlr3DebugListenerNew
  00021	48 89 44 24 20	 mov	 QWORD PTR delboy$[rsp], rax

; 152  : 
; 153  : 	if	(delboy != NULL)

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR delboy$[rsp], 0
  0002c	74 0b		 je	 SHORT $LN2@antlr3Debu

; 154  : 	{
; 155  : 		delboy->port = port;

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00033	8b 4c 24 40	 mov	 ecx, DWORD PTR port$[rsp]
  00037	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@antlr3Debu:

; 156  : 	}
; 157  : 
; 158  : 	return delboy;

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]

; 159  : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
antlr3DebugListenerNewPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT ack
_TEXT	SEGMENT
buffer$ = 36
rCount$ = 52
delboy$ = 80
ack	PROC						; COMDAT

; 331  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
$LN4@ack:

; 332  : 	// Local buffer to read the next character in to
; 333  : 	//
; 334  : 	char	buffer;
; 335  : 	int		rCount;
; 336  : 
; 337  : 	// Ack terminates in a line feed, so we just wait for
; 338  : 	// one of those. Speed is not of the essence so we don't need
; 339  : 	// to buffer the input or anything.
; 340  : 	//
; 341  : 	do
; 342  : 	{
; 343  : 		rCount = recv(delboy->socket, &buffer, 1, 0);

  0001e	45 33 c9	 xor	 r9d, r9d
  00021	41 b8 01 00 00
	00		 mov	 r8d, 1
  00027	48 8d 54 24 24	 lea	 rdx, QWORD PTR buffer$[rsp]
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00031	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00035	e8 00 00 00 00	 call	 recv
  0003a	89 44 24 34	 mov	 DWORD PTR rCount$[rsp], eax

; 344  : 	}
; 345  : 	while	(rCount == 1 && buffer != '\n');

  0003e	83 7c 24 34 01	 cmp	 DWORD PTR rCount$[rsp], 1
  00043	75 0a		 jne	 SHORT $LN5@ack
  00045	0f be 44 24 24	 movsx	 eax, BYTE PTR buffer$[rsp]
  0004a	83 f8 0a	 cmp	 eax, 10
  0004d	75 cf		 jne	 SHORT $LN4@ack
$LN5@ack:

; 346  : 
; 347  : 	// If the socket ws closed on us, then we will get an error or
; 348  : 	// (with a graceful close), 0. We can assume the the debugger stopped for some reason
; 349  : 	// (such as Java crashing again). Therefore we just exit the program
; 350  : 	// completely if we don't get the terminating '\n' for the ack.
; 351  : 	//
; 352  : 	if	(rCount != 1)

  0004f	83 7c 24 34 01	 cmp	 DWORD PTR rCount$[rsp], 1
  00054	74 2c		 je	 SHORT $LN6@ack

; 353  : 	{
; 354  : 		ANTLR3_PRINTF("Exiting debugger as remote client closed the socket\n");

  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clien@
  0005d	e8 00 00 00 00	 call	 printf

; 355  : 		ANTLR3_PRINTF("Received char count was %d, and last char received was %02X\n", rCount, buffer);

  00062	0f be 44 24 24	 movsx	 eax, BYTE PTR buffer$[rsp]
  00067	44 8b c0	 mov	 r8d, eax
  0006a	8b 54 24 34	 mov	 edx, DWORD PTR rCount$[rsp]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and?5@
  00075	e8 00 00 00 00	 call	 printf

; 356  : 		exit(0);

  0007a	33 c9		 xor	 ecx, ecx
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN6@ack:
$LN7@ack:

; 357  : 	}
; 358  : }

  00082	48 8b cc	 mov	 rcx, rsp
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ack$rtcFrameData
  0008c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
ack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT setTokenBoundaries
_TEXT	SEGMENT
buffer$ = 64
__$ArrayPad$ = 208
delboy$ = 240
t$ = 248
tokenStartIndex$ = 256
tokenStopIndex$ = 264
setTokenBoundaries PROC					; COMDAT

; 1037 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003a	48 33 c4	 xor	 rax, rsp
  0003d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1038 : 	char	buffer[128];
; 1039 : 
; 1040 : 	sprintf(buffer, "becomeRoot\t%d\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, t),

  00045	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0004d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00051	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00059	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00061	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00065	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  0006b	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tokenStopIndex$[rsp]
  00072	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00076	44 8b 8c 24 00
	01 00 00	 mov	 r9d, DWORD PTR tokenStartIndex$[rsp]
  0007e	44 8b c0	 mov	 r8d, eax
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6?$AA@
  00088	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0008d	e8 00 00 00 00	 call	 sprintf

; 1041 : 												(ANTLR3_UINT32)tokenStartIndex,
; 1042 : 												(ANTLR3_UINT32)tokenStopIndex
; 1043 : 											);
; 1044 : 	transmit(delboy, buffer);

  00092	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00097	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0009f	e8 00 00 00 00	 call	 transmit

; 1045 : }

  000a4	48 8b cc	 mov	 rcx, rsp
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:setTokenBoundaries$rtcFrameData
  000ae	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000b3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000bb	48 33 cc	 xor	 rcx, rsp
  000be	e8 00 00 00 00	 call	 __security_check_cookie
  000c3	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT addChild
_TEXT	SEGMENT
buffer$ = 48
tv67 = 192
tv82 = 200
__$ArrayPad$ = 208
delboy$ = 240
root$ = 248
child$ = 256
addChild PROC						; COMDAT

; 1026 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1027 : 	char	buffer[128];
; 1028 : 
; 1029 : 	sprintf(buffer, "addChild\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, root),

  00040	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00048	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004c	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR child$[rsp]
  00054	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005c	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00060	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00066	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0006d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00075	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00079	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rcx
  00081	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR root$[rsp]
  00089	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00091	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00095	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv82[rsp]
  0009d	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  000a4	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv67[rsp]
  000ab	44 8b c9	 mov	 r9d, ecx
  000ae	44 8b c0	 mov	 r8d, eax
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6?$AA@
  000b8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000bd	e8 00 00 00 00	 call	 sprintf

; 1030 : 											delboy->adaptor->getUniqueID(delboy->adaptor, child)
; 1031 : 											);
; 1032 : 	transmit(delboy, buffer);

  000c2	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000c7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000cf	e8 00 00 00 00	 call	 transmit

; 1033 : }

  000d4	48 8b cc	 mov	 rcx, rsp
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addChild$rtcFrameData
  000de	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000eb	48 33 cc	 xor	 rcx, rsp
  000ee	e8 00 00 00 00	 call	 __security_check_cookie
  000f3	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT becomeRoot
_TEXT	SEGMENT
buffer$ = 48
tv67 = 192
tv82 = 200
__$ArrayPad$ = 208
delboy$ = 240
newRoot$ = 248
oldRoot$ = 256
becomeRoot PROC						; COMDAT

; 1014 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1015 : 	char	buffer[128];
; 1016 : 
; 1017 : 	sprintf(buffer, "becomeRoot\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, newRoot),

  00040	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00048	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004c	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR oldRoot$[rsp]
  00054	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005c	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00060	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00066	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0006d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00075	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00079	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rcx
  00081	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR newRoot$[rsp]
  00089	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00091	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00095	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv82[rsp]
  0009d	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  000a4	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv67[rsp]
  000ab	44 8b c9	 mov	 r9d, ecx
  000ae	44 8b c0	 mov	 r8d, eax
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6?$AA@
  000b8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000bd	e8 00 00 00 00	 call	 sprintf

; 1018 : 											delboy->adaptor->getUniqueID(delboy->adaptor, oldRoot)
; 1019 : 											);
; 1020 : 	transmit(delboy, buffer);

  000c2	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000c7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000cf	e8 00 00 00 00	 call	 transmit

; 1021 : }

  000d4	48 8b cc	 mov	 rcx, rsp
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:becomeRoot$rtcFrameData
  000de	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000eb	48 33 cc	 xor	 rcx, rsp
  000ee	e8 00 00 00 00	 call	 __security_check_cookie
  000f3	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT createNodeTok
_TEXT	SEGMENT
buffer$ = 48
tv66 = 192
tv80 = 200
__$ArrayPad$ = 208
delboy$ = 240
node$ = 248
token$ = 256
createNodeTok PROC					; COMDAT

; 1004 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1005 : 	char	buffer[128];
; 1006 : 
; 1007 : 	sprintf(buffer, "createNode\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, node), (ANTLR3_UINT32)token->getTokenIndex(token));

  00040	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00048	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00050	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00056	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
  0005e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00066	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0006a	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv80[rsp], rcx
  00072	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR node$[rsp]
  0007a	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00082	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00086	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv80[rsp]
  0008e	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  00095	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv66[rsp]
  0009d	44 8b c9	 mov	 r9d, ecx
  000a0	44 8b c0	 mov	 r8d, eax
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6?$AA@
  000aa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000af	e8 00 00 00 00	 call	 sprintf

; 1008 : 
; 1009 : 	transmit(delboy, buffer);

  000b4	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000b9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000c1	e8 00 00 00 00	 call	 transmit

; 1010 : }

  000c6	48 8b cc	 mov	 rcx, rsp
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:createNodeTok$rtcFrameData
  000d0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dd	48 33 cc	 xor	 rcx, rsp
  000e0	e8 00 00 00 00	 call	 __security_check_cookie
  000e5	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
createNodeTok ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT createNode
_TEXT	SEGMENT
tv170 = 32
tv167 = 40
tv164 = 48
delboy$ = 80
t$ = 88
createNode PROC						; COMDAT

; 917  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 918  : 	// Do we already have a serialization buffer?
; 919  : 	//
; 920  : 	if	(delboy->tokenString == NULL)

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00028	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002d	75 33		 jne	 SHORT $LN2@createNode

; 921  : 	{
; 922  : 		// No, so create one, using the string factory that
; 923  : 		// the grammar name used, which is guaranteed to exist.
; 924  : 		// 64 bytes will do us here for starters. 
; 925  : 		//
; 926  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00034	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0003d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00041	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00044	48 89 4c 24 20	 mov	 QWORD PTR tv170[rsp], rcx
  00049	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR tv170[rsp]
  00056	ff 50 18	 call	 QWORD PTR [rax+24]
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@createNode:

; 927  : 	}
; 928  : 
; 929  : 	// Empty string
; 930  : 	//
; 931  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"createNodeFromTokenElements ");

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5?$AA@
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0007b	ff 50 28	 call	 QWORD PTR [rax+40]

; 932  : 
; 933  : 	// Now we serialize the elements of the node.Note that the debugger only
; 934  : 	// uses 32 bits.
; 935  : 	//
; 936  : 	// Adaptor ID
; 937  : 	//
; 938  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00083	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00087	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00091	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00095	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000a0	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000a4	48 89 4c 24 28	 mov	 QWORD PTR tv167[rsp], rcx
  000a9	8b d0		 mov	 edx, eax
  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000b0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR tv167[rsp]
  000b9	ff 50 78	 call	 QWORD PTR [rax+120]

; 939  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000c1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c5	ba 09 00 00 00	 mov	 edx, 9
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000cf	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000d3	ff 50 70	 call	 QWORD PTR [rax+112]

; 940  : 
; 941  : 	// Type of the current token (which may be imaginary)
; 942  : 	//
; 943  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, t));

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000db	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000df	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000e9	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000ed	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000f8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fc	48 89 4c 24 30	 mov	 QWORD PTR tv164[rsp], rcx
  00101	8b d0		 mov	 edx, eax
  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00108	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0010c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv164[rsp]
  00111	ff 50 78	 call	 QWORD PTR [rax+120]

; 944  : 
; 945  : 	// The text that this node represents
; 946  : 	//
; 947  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00119	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0011d	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  00122	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00127	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0012b	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00131	48 8b d0	 mov	 rdx, rax
  00134	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00139	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0013d	e8 00 00 00 00	 call	 serializeText

; 948  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  00142	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00147	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0014b	ba 0a 00 00 00	 mov	 edx, 10
  00150	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00155	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00159	ff 50 70	 call	 QWORD PTR [rax+112]

; 949  : 
; 950  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 951  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 952  : 	// must force encode it. We have a method to do this in the string class, but
; 953  : 	// there is no utf8 string implementation as of yet
; 954  : 	//
; 955  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  0015c	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00161	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00165	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0016a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0016e	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00174	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00178	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0017d	e8 00 00 00 00	 call	 transmit

; 956  : 
; 957  : }

  00182	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00186	5f		 pop	 rdi
  00187	c3		 ret	 0
createNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT errorNode
_TEXT	SEGMENT
tv163 = 32
tv160 = 40
delboy$ = 64
t$ = 72
errorNode PROC						; COMDAT

; 960  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 961  : 	// Do we already have a serialization buffer?
; 962  : 	//
; 963  : 	if	(delboy->tokenString == NULL)

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00028	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002d	75 33		 jne	 SHORT $LN2@errorNode

; 964  : 	{
; 965  : 		// No, so create one, using the string factory that
; 966  : 		// the grammar name used, which is guaranteed to exist.
; 967  : 		// 64 bytes will do us here for starters. 
; 968  : 		//
; 969  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00034	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0003d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00041	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00044	48 89 4c 24 20	 mov	 QWORD PTR tv163[rsp], rcx
  00049	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR tv163[rsp]
  00056	ff 50 18	 call	 QWORD PTR [rax+24]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@errorNode:

; 970  : 	}
; 971  : 
; 972  : 	// Empty string
; 973  : 	//
; 974  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"errorNode\t");

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OOIEOANM@errorNode?7?$AA@
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0007b	ff 50 28	 call	 QWORD PTR [rax+40]

; 975  : 
; 976  : 	// Now we serialize the elements of the node.Note that the debugger only
; 977  : 	// uses 32 bits.
; 978  : 	//
; 979  : 	// Adaptor ID
; 980  : 	//
; 981  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00083	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00087	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00091	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00095	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000a0	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000a4	48 89 4c 24 28	 mov	 QWORD PTR tv160[rsp], rcx
  000a9	8b d0		 mov	 edx, eax
  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000b0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR tv160[rsp]
  000b9	ff 50 78	 call	 QWORD PTR [rax+120]

; 982  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000c1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c5	ba 09 00 00 00	 mov	 edx, 9
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000cf	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000d3	ff 50 70	 call	 QWORD PTR [rax+112]

; 983  : 
; 984  : 	// Type of the current token (which is an error)
; 985  : 	//
; 986  : 	delboy->tokenString->addi(delboy->tokenString, ANTLR3_TOKEN_INVALID);

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000db	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000df	33 d2		 xor	 edx, edx
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000e6	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ea	ff 50 78	 call	 QWORD PTR [rax+120]

; 987  : 
; 988  : 	// The text that this node represents
; 989  : 	//
; 990  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000f2	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000f6	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00100	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00104	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00112	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00116	e8 00 00 00 00	 call	 serializeText

; 991  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00120	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00124	ba 0a 00 00 00	 mov	 edx, 10
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0012e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00132	ff 50 70	 call	 QWORD PTR [rax+112]

; 992  : 
; 993  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 994  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 995  : 	// must force encode it. We have a method to do this in the string class, but
; 996  : 	// there is no utf8 string implementation as of yet
; 997  : 	//
; 998  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00135	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  0013a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00143	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00147	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0014d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00151	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00156	e8 00 00 00 00	 call	 transmit

; 999  : 
; 1000 : }

  0015b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015f	5f		 pop	 rdi
  00160	c3		 ret	 0
errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT nilNode
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
t$ = 232
nilNode	PROC						; COMDAT

; 909  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 910  : 	char	buffer[128];
; 911  : 	sprintf(buffer, "nilNode\t%d\n", delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0003b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00043	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00047	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0004f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00057	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0005b	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00061	44 8b c0	 mov	 r8d, eax
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6?$AA@
  0006b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00070	e8 00 00 00 00	 call	 sprintf

; 912  : 	transmit(delboy, buffer);

  00075	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0007a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00082	e8 00 00 00 00	 call	 transmit

; 913  : }

  00087	48 8b cc	 mov	 rcx, rsp
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:nilNode$rtcFrameData
  00091	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00096	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009e	48 33 cc	 xor	 rcx, rsp
  000a1	e8 00 00 00 00	 call	 __security_check_cookie
  000a6	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
nilNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT LTT
_TEXT	SEGMENT
buffer$ = 32
delboy$ = 64
i$ = 72
t$ = 80
LTT	PROC						; COMDAT

; 890  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 891  : 	pANTLR3_STRING	buffer;
; 892  : 
; 893  : 	buffer = serializeNode	(delboy, t);

  00027	48 8b 54 24 50	 mov	 rdx, QWORD PTR t$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00031	e8 00 00 00 00	 call	 serializeNode
  00036	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 894  : 
; 895  : 	// Now prepend the command
; 896  : 	//
; 897  : 	buffer->insert8	(buffer, 0, "\t");

  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01GPOEFGEJ@?7?$AA@
  00042	33 d2		 xor	 edx, edx
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0004e	ff 50 48	 call	 QWORD PTR [rax+72]

; 898  : 	buffer->inserti	(buffer, 0, i);

  00051	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$[rsp]
  00056	33 d2		 xor	 edx, edx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00062	ff 50 68	 call	 QWORD PTR [rax+104]

; 899  : 	buffer->insert8	(buffer, 0, "LN\t");

  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03KELPNMOF@LN?7?$AA@
  0006c	33 d2		 xor	 edx, edx
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00078	ff 50 48	 call	 QWORD PTR [rax+72]

; 900  : 	buffer->addc	(buffer, '\n');

  0007b	ba 0a 00 00 00	 mov	 edx, 10
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0008a	ff 50 70	 call	 QWORD PTR [rax+112]

; 901  : 
; 902  : 	// Send to the debugger and wait for the ack
; 903  : 	//
; 904  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00092	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00096	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0009b	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0009f	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  000a5	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ae	e8 00 00 00 00	 call	 transmit

; 905  : }

  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
LTT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeNode
_TEXT	SEGMENT
buffer$ = 32
delboy$ = 64
t$ = 72
consumeNode PROC					; COMDAT

; 873  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 874  : 	pANTLR3_STRING	buffer;
; 875  : 
; 876  : 	buffer = serializeNode	(delboy, t);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002d	e8 00 00 00 00	 call	 serializeNode
  00032	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 877  : 
; 878  : 	// Now prepend the command
; 879  : 	//
; 880  : 	buffer->insert8	(buffer, 0, "consumeNode\t");

  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CLFGHGNF@consumeNode?7?$AA@
  0003e	33 d2		 xor	 edx, edx
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0004a	ff 50 48	 call	 QWORD PTR [rax+72]

; 881  : 	buffer->addc	(buffer, '\n');

  0004d	ba 0a 00 00 00	 mov	 edx, 10
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0005c	ff 50 70	 call	 QWORD PTR [rax+112]

; 882  : 
; 883  : 	// Send to the debugger and wait for the ack
; 884  : 	//
; 885  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00064	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00071	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00077	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00080	e8 00 00 00 00	 call	 transmit

; 886  : }

  00085	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
consumeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT terminate
_TEXT	SEGMENT
delboy$ = 48
terminate PROC						; COMDAT

; 862  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 863  : 	// Terminate sequence
; 864  : 	//
; 865  : 	sockSend(delboy->socket, "terminate\n", 10);		// Send out the command

  0001e	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KANKBBAE@terminate?6?$AA@
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR delboy$[rsp]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	e8 00 00 00 00	 call	 sockSend

; 866  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
terminate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT commence
_TEXT	SEGMENT
delboy$ = 16
commence PROC						; COMDAT

; 851  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 852  : 	// Nothing to see here
; 853  : 	//
; 854  : }

  00006	5f		 pop	 rdi
  00007	c3		 ret	 0
commence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT semanticPredicate
_TEXT	SEGMENT
buffer$ = 32
out$ = 40
tv78 = 48
tv87 = 56
delboy$ = 80
result$ = 88
predicate$ = 96
semanticPredicate PROC					; COMDAT

; 788  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 789  : 	unsigned char * buffer;
; 790  : 	unsigned char * out;
; 791  : 
; 792  : 	if	(predicate != NULL)

  00027	48 83 7c 24 60
	00		 cmp	 QWORD PTR predicate$[rsp], 0
  0002d	0f 84 dc 01 00
	00		 je	 $LN6@semanticPr

; 793  : 	{
; 794  : 		buffer	= (unsigned char *)ANTLR3_MALLOC(64 + 2*strlen(predicate));

  00033	48 8b 4c 24 60	 mov	 rcx, QWORD PTR predicate$[rsp]
  00038	e8 00 00 00 00	 call	 strlen
  0003d	48 8d 44 00 40	 lea	 rax, QWORD PTR [rax+rax+64]
  00042	48 8b c8	 mov	 rcx, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004b	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 795  : 
; 796  : 		if	(buffer != NULL)

  00050	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00056	0f 84 a4 01 00
	00		 je	 $LN7@semanticPr

; 797  : 		{
; 798  : 			out = buffer + sprintf((char *)buffer, "semanticPredicate\t%s\t", result == ANTLR3_TRUE ? "true" : "false");

  0005c	0f b6 44 24 58	 movzx	 eax, BYTE PTR result$[rsp]
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 0e		 jne	 SHORT $LN13@semanticPr
  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
  0006d	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  00072	eb 0c		 jmp	 SHORT $LN14@semanticPr
$LN13@semanticPr:
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  0007b	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
$LN14@semanticPr:
  00080	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv78[rsp]
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7?$AA@
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00091	e8 00 00 00 00	 call	 sprintf
  00096	48 98		 cdqe
  00098	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0009d	48 03 c8	 add	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN2@semanticPr:

; 799  : 
; 800  : 			while (*predicate != '\0')

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  000ad	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 1e 01 00
	00		 je	 $LN3@semanticPr

; 801  : 			{
; 802  : 				switch(*predicate)

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  000bd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000c0	88 44 24 38	 mov	 BYTE PTR tv87[rsp], al
  000c4	80 7c 24 38 0a	 cmp	 BYTE PTR tv87[rsp], 10
  000c9	74 17		 je	 SHORT $LN8@semanticPr
  000cb	80 7c 24 38 0d	 cmp	 BYTE PTR tv87[rsp], 13
  000d0	74 54		 je	 SHORT $LN9@semanticPr
  000d2	80 7c 24 38 25	 cmp	 BYTE PTR tv87[rsp], 37	; 00000025H
  000d7	0f 84 8a 00 00
	00		 je	 $LN10@semanticPr
  000dd	e9 c6 00 00 00	 jmp	 $LN11@semanticPr
$LN8@semanticPr:

; 803  : 				{
; 804  : 					case	'\n':
; 805  : 						
; 806  : 						*out++	= '%';

  000e2	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000e7	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000ef	48 ff c0	 inc	 rax
  000f2	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 807  : 						*out++	= '0';

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000fc	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00104	48 ff c0	 inc	 rax
  00107	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 808  : 						*out++	= 'A';

  0010c	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00111	c6 00 41	 mov	 BYTE PTR [rax], 65	; 00000041H
  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00119	48 ff c0	 inc	 rax
  0011c	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 809  : 						break;

  00121	e9 9e 00 00 00	 jmp	 $LN4@semanticPr
$LN9@semanticPr:

; 810  : 
; 811  : 					case	'\r':
; 812  : 
; 813  : 						*out++	= '%';

  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0012b	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  0012e	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00133	48 ff c0	 inc	 rax
  00136	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 814  : 						*out++	= '0';

  0013b	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00140	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  00143	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00148	48 ff c0	 inc	 rax
  0014b	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 815  : 						*out++	= 'D';

  00150	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00155	c6 00 44	 mov	 BYTE PTR [rax], 68	; 00000044H
  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0015d	48 ff c0	 inc	 rax
  00160	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 816  : 						break;

  00165	eb 5d		 jmp	 SHORT $LN4@semanticPr
$LN10@semanticPr:

; 817  : 
; 818  : 					case	'%':
; 819  : 
; 820  : 						*out++	= '%';

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0016c	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  0016f	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00174	48 ff c0	 inc	 rax
  00177	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 821  : 						*out++	= '0';

  0017c	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00181	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00189	48 ff c0	 inc	 rax
  0018c	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 822  : 						*out++	= 'D';

  00191	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00196	c6 00 44	 mov	 BYTE PTR [rax], 68	; 00000044H
  00199	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0019e	48 ff c0	 inc	 rax
  001a1	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 823  : 						break;

  001a6	eb 1c		 jmp	 SHORT $LN4@semanticPr
$LN11@semanticPr:

; 824  : 
; 825  : 
; 826  : 					default:
; 827  : 
; 828  : 						*out++	= *predicate;

  001a8	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR predicate$[rsp]
  001b2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001b5	88 08		 mov	 BYTE PTR [rax], cl
  001b7	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001bc	48 ff c0	 inc	 rax
  001bf	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN4@semanticPr:

; 829  : 						break;
; 830  : 				}
; 831  : 
; 832  : 				predicate++;

  001c4	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  001c9	48 ff c0	 inc	 rax
  001cc	48 89 44 24 60	 mov	 QWORD PTR predicate$[rsp], rax

; 833  : 			}

  001d1	e9 d2 fe ff ff	 jmp	 $LN2@semanticPr
$LN3@semanticPr:

; 834  : 			*out++	= '\n';

  001d6	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001db	c6 00 0a	 mov	 BYTE PTR [rax], 10
  001de	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001e3	48 ff c0	 inc	 rax
  001e6	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 835  : 			*out++	= '\0';

  001eb	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001f0	c6 00 00	 mov	 BYTE PTR [rax], 0
  001f3	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001f8	48 ff c0	 inc	 rax
  001fb	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN7@semanticPr:

; 836  : 		}
; 837  : 
; 838  : 		// Send it and wait for the ack
; 839  : 		//
; 840  : 		transmit(delboy, (const char *)buffer);

  00200	48 8b 54 24 20	 mov	 rdx, QWORD PTR buffer$[rsp]
  00205	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0020a	e8 00 00 00 00	 call	 transmit
$LN6@semanticPr:

; 841  : 	}
; 842  : }

  0020f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00213	5f		 pop	 rdi
  00214	c3		 ret	 0
semanticPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT endResync
_TEXT	SEGMENT
delboy$ = 48
endResync PROC						; COMDAT

; 782  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 783  : 	transmit(delboy, (const char *)"endResync\n");

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KHCEOHOJ@endResync?6?$AA@
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002a	e8 00 00 00 00	 call	 transmit

; 784  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT beginResync
_TEXT	SEGMENT
delboy$ = 48
beginResync PROC					; COMDAT

; 776  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 777  : 	transmit(delboy, (const char *)"beginResync\n");

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DCBHEMKM@beginResync?6?$AA@
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002a	e8 00 00 00 00	 call	 transmit

; 778  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT recognitionException
_TEXT	SEGMENT
buffer$ = 64
__$ArrayPad$ = 336
delboy$ = 368
e$ = 376
recognitionException PROC				; COMDAT

; 764  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR [rsp+368]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 765  : 	char	buffer[256];
; 766  : 
; 767  : 	sprintf(buffer, "exception\t%s\t%d\t%d\t%d\n", (char *)(e->name), (ANTLR3_INT32)(e->index), e->line, e->charPositionInLine);

  0003b	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00043	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00046	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00052	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00055	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00059	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00061	44 8b 48 28	 mov	 r9d, DWORD PTR [rax+40]
  00065	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0006d	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6?$AA@
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0007d	e8 00 00 00 00	 call	 sprintf

; 768  : 
; 769  : 	// Transmit the message and wait for ack
; 770  : 	//
; 771  : 	transmit(delboy, buffer);

  00082	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00087	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0008f	e8 00 00 00 00	 call	 transmit

; 772  : }

  00094	48 8b cc	 mov	 rcx, rsp
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:recognitionException$rtcFrameData
  0009e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ab	48 33 cc	 xor	 rcx, rsp
  000ae	e8 00 00 00 00	 call	 __security_check_cookie
  000b3	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
recognitionException ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT location
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
line$ = 232
pos$ = 240
location PROC						; COMDAT

; 752  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 753  : 	char buffer[128];
; 754  : 
; 755  : 	sprintf(buffer, "location\t%d\t%d\n", line, pos);

  0003f	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR pos$[rsp]
  00047	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR line$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6?$AA@
  00056	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 sprintf

; 756  : 
; 757  : 	// Transmit the message and wait for ack
; 758  : 	//
; 759  : 	transmit(delboy, buffer);

  00060	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00065	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006d	e8 00 00 00 00	 call	 transmit

; 760  : }

  00072	48 8b cc	 mov	 rcx, rsp
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:location$rtcFrameData
  0007c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00081	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00089	48 33 cc	 xor	 rcx, rsp
  0008c	e8 00 00 00 00	 call	 __security_check_cookie
  00091	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
location ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT endBacktrack
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
level$ = 232
successful$ = 240
endBacktrack PROC					; COMDAT

; 740  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 741  : 	char buffer[128];
; 742  : 
; 743  : 	sprintf(buffer, "endBacktrack\t%d\t%d\n", level, successful);

  0003f	0f b6 84 24 f0
	00 00 00	 movzx	 eax, BYTE PTR successful$[rsp]
  00047	44 8b c8	 mov	 r9d, eax
  0004a	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR level$[rsp]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6?$AA@
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005e	e8 00 00 00 00	 call	 sprintf

; 744  : 
; 745  : 	// Transmit the message and wait for ack
; 746  : 	//
; 747  : 	transmit(delboy, buffer);

  00063	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00068	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00070	e8 00 00 00 00	 call	 transmit

; 748  : }

  00075	48 8b cc	 mov	 rcx, rsp
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:endBacktrack$rtcFrameData
  0007f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00084	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT beginBacktrack
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
level$ = 232
beginBacktrack PROC					; COMDAT

; 728  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 729  : 	char buffer[128];
; 730  : 
; 731  : 	sprintf(buffer, "beginBacktrack\t%d\n", (ANTLR3_UINT32)(level & 0xFFFFFFFF));

  0003a	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR level$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 732  : 
; 733  : 	// Transmit the message and wait for ack
; 734  : 	//
; 735  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 736  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:beginBacktrack$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT rewindLast
_TEXT	SEGMENT
delboy$ = 48
rewindLast PROC						; COMDAT

; 722  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 723  : 	transmit(delboy, (const char *)"rewind\n");

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBOLPGDK@rewind?6?$AA@
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002a	e8 00 00 00 00	 call	 transmit

; 724  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT rewindMark
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
marker$ = 232
rewindMark PROC						; COMDAT

; 709  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 710  : 	char buffer[128];
; 711  : 
; 712  : 	sprintf(buffer, "rewind\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR marker$[rsp]
  00048	48 23 c8	 and	 rcx, rax
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	44 8b c0	 mov	 r8d, eax
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DJLPLDGG@rewind?7?$CFd?6?$AA@
  00058	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005d	e8 00 00 00 00	 call	 sprintf

; 713  : 
; 714  : 	// Transmit the message and wait for ack
; 715  : 	//
; 716  : 	transmit(delboy, buffer);

  00062	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00067	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006f	e8 00 00 00 00	 call	 transmit

; 717  : 
; 718  : }

  00074	48 8b cc	 mov	 rcx, rsp
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rewindMark$rtcFrameData
  0007e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00083	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
rewindMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT mark
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
marker$ = 232
mark	PROC						; COMDAT

; 697  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 698  : 	char buffer[128];
; 699  : 
; 700  : 	sprintf(buffer, "mark\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR marker$[rsp]
  00048	48 23 c8	 and	 rcx, rax
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	44 8b c0	 mov	 r8d, eax
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JOJCKFBH@mark?7?$CFd?6?$AA@
  00058	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005d	e8 00 00 00 00	 call	 sprintf

; 701  : 
; 702  : 	// Transmit the message and wait for ack
; 703  : 	//
; 704  : 	transmit(delboy, buffer);

  00062	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00067	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006f	e8 00 00 00 00	 call	 transmit

; 705  : }

  00074	48 8b cc	 mov	 rcx, rsp
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:mark$rtcFrameData
  0007e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00083	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT LT
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
i$ = 72
t$ = 80
LT	PROC						; COMDAT

; 669  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 670  : 	pANTLR3_STRING msg;
; 671  : 
; 672  : 	if	(t != NULL)

  00027	48 83 7c 24 50
	00		 cmp	 QWORD PTR t$[rsp], 0
  0002d	74 79		 je	 SHORT $LN2@LT

; 673  : 	{
; 674  : 		// Create the serialized token
; 675  : 		//
; 676  : 		msg = serializeToken(delboy, t);

  0002f	48 8b 54 24 50	 mov	 rdx, QWORD PTR t$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00039	e8 00 00 00 00	 call	 serializeToken
  0003e	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 677  : 
; 678  : 		// Insert the index parameter
; 679  : 		//
; 680  : 		msg->insert8(msg, 0, "\t");

  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01GPOEFGEJ@?7?$AA@
  0004a	33 d2		 xor	 edx, edx
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00056	ff 50 48	 call	 QWORD PTR [rax+72]

; 681  : 		msg->inserti(msg, 0, i);

  00059	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$[rsp]
  0005e	33 d2		 xor	 edx, edx
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0006a	ff 50 68	 call	 QWORD PTR [rax+104]

; 682  : 
; 683  : 		// Insert the debug event indicator
; 684  : 		//
; 685  : 		msg->insert8(msg, 0, "LT\t");

  0006d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03LFAOPKED@LT?7?$AA@
  00074	33 d2		 xor	 edx, edx
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00080	ff 50 48	 call	 QWORD PTR [rax+72]

; 686  : 
; 687  : 		msg->addc(msg, '\n');

  00083	ba 0a 00 00 00	 mov	 edx, 10
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00092	ff 50 70	 call	 QWORD PTR [rax+112]

; 688  : 
; 689  : 		// Transmit the message and wait for ack
; 690  : 		//
; 691  : 		transmit(delboy, (const char *)(msg->chars));

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0009a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000a3	e8 00 00 00 00	 call	 transmit
$LN2@LT:

; 692  : 	}
; 693  : }

  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
LT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeHiddenToken
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
t$ = 72
consumeHiddenToken PROC					; COMDAT

; 647  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 648  : 	pANTLR3_STRING msg;
; 649  : 
; 650  : 	// Create the serialized token
; 651  : 	//
; 652  : 	msg = serializeToken(delboy, t);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002d	e8 00 00 00 00	 call	 serializeToken
  00032	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 653  : 
; 654  : 	// Insert the debug event indicator
; 655  : 	//
; 656  : 	msg->insert8(msg, 0, "consumeHiddenToken\t");

  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BE@GEGFGNHF@consumeHiddenToken?7?$AA@
  0003e	33 d2		 xor	 edx, edx
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0004a	ff 50 48	 call	 QWORD PTR [rax+72]

; 657  : 
; 658  : 	msg->addc(msg, '\n');

  0004d	ba 0a 00 00 00	 mov	 edx, 10
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0005c	ff 50 70	 call	 QWORD PTR [rax+112]

; 659  : 
; 660  : 	// Transmit the message and wait for ack
; 661  : 	//
; 662  : 	transmit(delboy, (const char *)(msg->chars));

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00064	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006d	e8 00 00 00 00	 call	 transmit

; 663  : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
consumeHiddenToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeToken
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
t$ = 72
consumeToken PROC					; COMDAT

; 627  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 628  : 	pANTLR3_STRING msg;
; 629  : 
; 630  : 	// Create the serialized token
; 631  : 	//
; 632  : 	msg = serializeToken(delboy, t);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0002d	e8 00 00 00 00	 call	 serializeToken
  00032	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 633  : 
; 634  : 	// Insert the debug event indicator
; 635  : 	//
; 636  : 	msg->insert8(msg, 0, "consumeToken\t");

  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@CLDGECJA@consumeToken?7?$AA@
  0003e	33 d2		 xor	 edx, edx
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0004a	ff 50 48	 call	 QWORD PTR [rax+72]

; 637  : 
; 638  : 	msg->addc(msg, '\n');

  0004d	ba 0a 00 00 00	 mov	 edx, 10
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0005c	ff 50 70	 call	 QWORD PTR [rax+112]

; 639  : 
; 640  : 	// Transmit the message and wait for ack
; 641  : 	//
; 642  : 	transmit(delboy, (const char *)(msg->chars));

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00064	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006d	e8 00 00 00 00	 call	 transmit

; 643  : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
consumeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitDecision
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
exitDecision PROC					; COMDAT

; 616  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 617  : 	char	buffer[512];
; 618  : 
; 619  : 	// Create the message (speed is not of the essence)
; 620  : 	//
; 621  : 	sprintf(buffer, "exitDecision\t%d\n", decisionNumber);

  0003a	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 622  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 623  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitDecision$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
exitDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterDecision
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
enterDecision PROC					; COMDAT

; 604  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 605  : 	char	buffer[512];
; 606  : 
; 607  : 	// Create the message (speed is not of the essence)
; 608  : 	//
; 609  : 	sprintf(buffer, "enterDecision\t%d\n", decisionNumber);

  0003a	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 610  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 611  : 
; 612  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterDecision$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
enterDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitSubRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
exitSubRule PROC					; COMDAT

; 593  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 594  : 	char	buffer[512];
; 595  : 
; 596  : 	// Create the message (speed is not of the essence)
; 597  : 	//
; 598  : 	sprintf(buffer, "exitSubRule\t%d\n", decisionNumber);

  0003a	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 599  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 600  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitSubRule$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
exitSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterSubRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
enterSubRule PROC					; COMDAT

; 582  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 583  : 	char	buffer[512];
; 584  : 
; 585  : 	// Create the message (speed is not of the essence)
; 586  : 	//
; 587  : 	sprintf(buffer, "enterSubRule\t%d\n", decisionNumber);

  0003a	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 588  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 589  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterSubRule$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
enterSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
grammarFileName$ = 616
ruleName$ = 624
exitRule PROC						; COMDAT

; 571  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 572  : 	char	buffer[512];
; 573  : 
; 574  : 	// Create the message (speed is not of the essence)
; 575  : 	//
; 576  : 	sprintf(buffer, "exitRule\t%s\t%s\n", grammarFileName, ruleName);

  00040	4c 8b 8c 24 70
	02 00 00	 mov	 r9, QWORD PTR ruleName$[rsp]
  00048	4c 8b 84 24 68
	02 00 00	 mov	 r8, QWORD PTR grammarFileName$[rsp]
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6?$AA@
  00057	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005c	e8 00 00 00 00	 call	 sprintf

; 577  : 	transmit(delboy, buffer);

  00061	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00066	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006e	e8 00 00 00 00	 call	 transmit

; 578  : }

  00073	48 8b cc	 mov	 rcx, rsp
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitRule$rtcFrameData
  0007d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00082	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008a	48 33 cc	 xor	 rcx, rsp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
exitRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterAlt
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
alt$ = 616
enterAlt PROC						; COMDAT

; 560  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 561  : 	char	buffer[512];
; 562  : 
; 563  : 	// Create the message (speed is not of the essence)
; 564  : 	//
; 565  : 	sprintf(buffer, "enterAlt\t%d\n", alt);

  0003a	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR alt$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6?$AA@
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0004e	e8 00 00 00 00	 call	 sprintf

; 566  : 	transmit(delboy, buffer);

  00053	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00060	e8 00 00 00 00	 call	 transmit

; 567  : }

  00065	48 8b cc	 mov	 rcx, rsp
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterAlt$rtcFrameData
  0006f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00074	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
enterAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
grammarFileName$ = 616
ruleName$ = 624
enterRule PROC						; COMDAT

; 549  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 550  : 	char	buffer[512];
; 551  : 
; 552  : 	// Create the message (speed is not of the essence)
; 553  : 	//
; 554  : 	sprintf(buffer, "enterRule\t%s\t%s\n", grammarFileName, ruleName);

  00040	4c 8b 8c 24 70
	02 00 00	 mov	 r9, QWORD PTR ruleName$[rsp]
  00048	4c 8b 84 24 68
	02 00 00	 mov	 r8, QWORD PTR grammarFileName$[rsp]
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6?$AA@
  00057	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005c	e8 00 00 00 00	 call	 sprintf

; 555  : 	transmit(delboy, buffer);

  00061	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00066	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006e	e8 00 00 00 00	 call	 transmit

; 556  : }

  00073	48 8b cc	 mov	 rcx, rsp
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterRule$rtcFrameData
  0007d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00082	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008a	48 33 cc	 xor	 rcx, rsp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
enterRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT handshake
_TEXT	SEGMENT
serverSocket$ = 48
client$ = 72
server$ = 120
message$ = 176
sockaddr_len$ = 452
optVal$ = 484
wVersionRequested$9 = 500
wsaData$10 = 528
err$11 = 948
__$ArrayPad$ = 960
delboy$ = 992
handshake PROC						; COMDAT

; 195  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 03
	00 00		 sub	 rsp, 976		; 000003d0H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 f4 00 00 00	 mov	 ecx, 244		; 000000f4H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR [rsp+992]
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 196  : 	/// Connection structure with which to wait and accept a connection from
; 197  : 	/// a debugger.
; 198  : 	///
; 199  : 	SOCKET				serverSocket;
; 200  : 
; 201  : 	// Connection structures to deal with the client after we accept the connection
; 202  : 	// and the server while we accept a connection.
; 203  : 	//
; 204  : 	ANTLR3_SOCKADDRT	client;
; 205  : 	ANTLR3_SOCKADDRT	server;
; 206  : 
; 207  : 	// Buffer to construct our message in
; 208  : 	//
; 209  : 	char	message[256];
; 210  : 
; 211  : 	// Specifies the length of the connection structure to accept()
; 212  : 	// Windows use int, everyone else uses size_t
; 213  : 	//
; 214  : 	ANTLR3_SALENT				sockaddr_len;
; 215  : 
; 216  : 	// Option holder for setsockopt()
; 217  : 	//
; 218  : 	int		optVal;
; 219  : 
; 220  : 	if	(delboy->initialized == ANTLR3_FALSE)

  00036	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0003e	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00042	85 c0		 test	 eax, eax
  00044	0f 85 5a 01 00
	00		 jne	 $LN2@handshake

; 221  : 	{
; 222  : 		// Windows requires us to initialize WinSock.
; 223  : 		//
; 224  : #ifdef ANTLR3_WINDOWS
; 225  : 		{
; 226  : 			WORD		wVersionRequested;
; 227  : 			WSADATA		wsaData;
; 228  : 			int			err;			// Return code from WSAStartup
; 229  : 
; 230  : 			// We must initialise the Windows socket system when the DLL is loaded.
; 231  : 			// We are asking for Winsock 1.1 or better as we don't need anything
; 232  : 			// too complicated for this.
; 233  : 			//
; 234  : 			wVersionRequested = MAKEWORD( 1, 1);

  0004a	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  0004f	66 89 84 24 f4
	01 00 00	 mov	 WORD PTR wVersionRequested$9[rsp], ax

; 235  : 
; 236  : 			err = WSAStartup( wVersionRequested, &wsaData );

  00057	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR wsaData$10[rsp]
  0005f	0f b7 8c 24 f4
	01 00 00	 movzx	 ecx, WORD PTR wVersionRequested$9[rsp]
  00067	e8 00 00 00 00	 call	 WSAStartup
  0006c	89 84 24 b4 03
	00 00		 mov	 DWORD PTR err$11[rsp], eax

; 237  : 
; 238  : 			if ( err != 0 ) 

  00073	83 bc 24 b4 03
	00 00 00	 cmp	 DWORD PTR err$11[rsp], 0
  0007b	74 07		 je	 SHORT $LN3@handshake

; 239  : 			{
; 240  : 				// Tell the user that we could not find a usable
; 241  : 				// WinSock DLL
; 242  : 				//
; 243  : 				return FALSE;

  0007d	32 c0		 xor	 al, al
  0007f	e9 d1 01 00 00	 jmp	 $LN1@handshake
$LN3@handshake:

; 244  : 			}
; 245  : 		}
; 246  : #endif
; 247  : 
; 248  : 		// Create the server socket, we are the server because we just wait until
; 249  : 		// a debugger connects to the port we are listening on.
; 250  : 		//
; 251  : 		serverSocket	= socket(AF_INET, SOCK_STREAM, 0);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	ba 01 00 00 00	 mov	 edx, 1
  0008c	b9 02 00 00 00	 mov	 ecx, 2
  00091	e8 00 00 00 00	 call	 socket
  00096	48 89 44 24 30	 mov	 QWORD PTR serverSocket$[rsp], rax

; 252  : 
; 253  : 		if	(serverSocket == INVALID_SOCKET)

  0009b	48 83 7c 24 30
	ff		 cmp	 QWORD PTR serverSocket$[rsp], -1
  000a1	75 07		 jne	 SHORT $LN4@handshake

; 254  : 		{
; 255  : 			return ANTLR3_FALSE;

  000a3	32 c0		 xor	 al, al
  000a5	e9 ab 01 00 00	 jmp	 $LN1@handshake
$LN4@handshake:

; 256  : 		}
; 257  : 
; 258  : 		// Set the listening port
; 259  : 		//
; 260  : 		server.sin_port			= htons((unsigned short)delboy->port);

  000aa	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  000b2	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000b5	e8 00 00 00 00	 call	 htons
  000ba	66 89 44 24 7a	 mov	 WORD PTR server$[rsp+2], ax

; 261  : 		server.sin_family		= AF_INET;

  000bf	b8 02 00 00 00	 mov	 eax, 2
  000c4	66 89 44 24 78	 mov	 WORD PTR server$[rsp], ax

; 262  : 		server.sin_addr.s_addr	= htonl (INADDR_ANY);

  000c9	33 c9		 xor	 ecx, ecx
  000cb	e8 00 00 00 00	 call	 htonl
  000d0	89 44 24 7c	 mov	 DWORD PTR server$[rsp+4], eax

; 263  : 
; 264  : 		// We could allow a rebind on the same addr/port pair I suppose, but
; 265  : 		// I imagine that most people will just want to start debugging one parser at once.
; 266  : 		// Maybe change this at some point, but rejecting the bind at this point will ensure
; 267  : 		// that people realize they have left something running in the background.
; 268  : 		//
; 269  : 		if	(bind(serverSocket, (pANTLR3_SOCKADDRC)&server, sizeof(server)) == -1)

  000d4	41 b8 10 00 00
	00		 mov	 r8d, 16
  000da	48 8d 54 24 78	 lea	 rdx, QWORD PTR server$[rsp]
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  000e4	e8 00 00 00 00	 call	 bind
  000e9	83 f8 ff	 cmp	 eax, -1
  000ec	75 07		 jne	 SHORT $LN5@handshake

; 270  : 		{
; 271  : 			return ANTLR3_FALSE;

  000ee	32 c0		 xor	 al, al
  000f0	e9 60 01 00 00	 jmp	 $LN1@handshake
$LN5@handshake:

; 272  : 		}
; 273  : 
; 274  : 		// We have bound the socket to the port and address so we now ask the TCP subsystem
; 275  : 		// to start listening on that address/port
; 276  : 		//
; 277  : 		if	(listen(serverSocket, 1) == -1)

  000f5	ba 01 00 00 00	 mov	 edx, 1
  000fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  000ff	e8 00 00 00 00	 call	 listen
  00104	83 f8 ff	 cmp	 eax, -1
  00107	75 07		 jne	 SHORT $LN6@handshake

; 278  : 		{
; 279  : 			// Some error, just fail
; 280  : 			//
; 281  : 			return	ANTLR3_FALSE;

  00109	32 c0		 xor	 al, al
  0010b	e9 45 01 00 00	 jmp	 $LN1@handshake
$LN6@handshake:

; 282  : 		}
; 283  : 
; 284  : 		// Now we can try to accept a connection on the port
; 285  : 		//
; 286  : 		sockaddr_len	= sizeof(client);

  00110	c7 84 24 c4 01
	00 00 10 00 00
	00		 mov	 DWORD PTR sockaddr_len$[rsp], 16

; 287  : 		delboy->socket	= accept(serverSocket, (pANTLR3_SOCKADDRC)&client, &sockaddr_len);

  0011b	4c 8d 84 24 c4
	01 00 00	 lea	 r8, QWORD PTR sockaddr_len$[rsp]
  00123	48 8d 54 24 48	 lea	 rdx, QWORD PTR client$[rsp]
  00128	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  0012d	e8 00 00 00 00	 call	 accept
  00132	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0013a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 288  : 
; 289  : 		// Having accepted a connection, we can stop listening and close down the socket
; 290  : 		//
; 291  : 		shutdown		(serverSocket, 0x02);

  0013e	ba 02 00 00 00	 mov	 edx, 2
  00143	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  00148	e8 00 00 00 00	 call	 shutdown

; 292  : 		ANTLR3_CLOSESOCKET		(serverSocket);

  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  00152	e8 00 00 00 00	 call	 closesocket

; 293  : 
; 294  : 		if	(delboy->socket == -1)

  00157	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0015f	48 83 78 08 ff	 cmp	 QWORD PTR [rax+8], -1
  00164	75 07		 jne	 SHORT $LN7@handshake

; 295  : 		{
; 296  : 			return ANTLR3_FALSE;

  00166	32 c0		 xor	 al, al
  00168	e9 e8 00 00 00	 jmp	 $LN1@handshake
$LN7@handshake:

; 297  : 		}
; 298  : 
; 299  : 		// Disable Nagle as this is essentially a chat exchange
; 300  : 		//
; 301  : 		optVal	= 1;

  0016d	c7 84 24 e4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR optVal$[rsp], 1

; 302  : 		setsockopt(delboy->socket, SOL_SOCKET, TCP_NODELAY, (const void *)&optVal, sizeof(optVal));

  00178	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00180	4c 8d 8c 24 e4
	01 00 00	 lea	 r9, QWORD PTR optVal$[rsp]
  00188	41 b8 01 00 00
	00		 mov	 r8d, 1
  0018e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00193	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0019b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0019f	e8 00 00 00 00	 call	 setsockopt
$LN2@handshake:

; 303  : 		
; 304  : 	}
; 305  : 
; 306  : 	// We now have a good socket connection with the debugging client, so we
; 307  : 	// send it the protocol version we are using and what the name of the grammar
; 308  : 	// is that we represent.
; 309  : 	//
; 310  : 	sprintf		(message, "ANTLR %d\n", delboy->PROTOCOL_VERSION);

  001a4	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001ac	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ILMAJDDB@ANTLR?5?$CFd?6?$AA@
  001b7	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  001bf	e8 00 00 00 00	 call	 sprintf

; 311  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  001c4	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  001cc	e8 00 00 00 00	 call	 strlen
  001d1	44 8b c0	 mov	 r8d, eax
  001d4	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR message$[rsp]
  001dc	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001e4	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001e8	e8 00 00 00 00	 call	 sockSend

; 312  : 	sprintf		(message, "grammar \"%s\n", delboy->grammarFileName->chars);

  001ed	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001f5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001f9	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6?$AA@
  00204	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  0020c	e8 00 00 00 00	 call	 sprintf

; 313  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  00211	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  00219	e8 00 00 00 00	 call	 strlen
  0021e	44 8b c0	 mov	 r8d, eax
  00221	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR message$[rsp]
  00229	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00231	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00235	e8 00 00 00 00	 call	 sockSend

; 314  : 	ack			(delboy);

  0023a	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00242	e8 00 00 00 00	 call	 ack

; 315  : 
; 316  : 	delboy->initialized = ANTLR3_TRUE;

  00247	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0024f	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1

; 317  : 
; 318  : 	return	ANTLR3_TRUE;

  00253	b0 01		 mov	 al, 1
$LN1@handshake:

; 319  : }

  00255	48 8b f8	 mov	 rdi, rax
  00258	48 8b cc	 mov	 rcx, rsp
  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:handshake$rtcFrameData
  00262	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00267	48 8b c7	 mov	 rax, rdi
  0026a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00272	48 33 cc	 xor	 rcx, rsp
  00275	e8 00 00 00 00	 call	 __security_check_cookie
  0027a	48 81 c4 d0 03
	00 00		 add	 rsp, 976		; 000003d0H
  00281	5f		 pop	 rdi
  00282	c3		 ret	 0
handshake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT antlr3DebugListenerNew
_TEXT	SEGMENT
delboy$ = 32
antlr3DebugListenerNew PROC				; COMDAT

; 94   : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 0c 00 00 00	 mov	 ecx, 12
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd

; 95   : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 96   : 
; 97   : 	delboy = ANTLR3_CALLOC(1, sizeof(ANTLR3_DEBUG_EVENT_LISTENER));

  00015	ba 48 01 00 00	 mov	 edx, 328		; 00000148H
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00025	48 89 44 24 20	 mov	 QWORD PTR delboy$[rsp], rax

; 98   : 
; 99   : 	if	(delboy == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR delboy$[rsp], 0
  00030	75 07		 jne	 SHORT $LN2@antlr3Debu

; 100  : 	{
; 101  : 		return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 61 02 00 00	 jmp	 $LN1@antlr3Debu
$LN2@antlr3Debu:

; 102  : 	}
; 103  : 
; 104  : 	// Initialize the API
; 105  : 	//
; 106  : 	delboy->addChild				= addChild;

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00045	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 107  : 	delboy->becomeRoot				= becomeRoot;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRoot
  00058	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 108  : 	delboy->beginBacktrack			= beginBacktrack;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginBacktrack
  0006b	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 109  : 	delboy->beginResync				= beginResync;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginResync
  0007e	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 110  : 	delboy->commence				= commence;

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:commence
  00091	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 111  : 	delboy->consumeHiddenToken		= consumeHiddenToken;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeHiddenToken
  000a4	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 112  : 	delboy->consumeNode				= consumeNode;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeNode
  000b7	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 113  : 	delboy->consumeToken			= consumeToken;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeToken
  000ca	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 114  : 	delboy->createNode				= createNode;

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createNode
  000da	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 115  : 	delboy->createNodeTok			= createNodeTok;

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createNodeTok
  000ed	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 116  : 	delboy->endBacktrack			= endBacktrack;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endBacktrack
  00100	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 117  : 	delboy->endResync				= endResync;

  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endResync
  00113	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 118  : 	delboy->enterAlt				= enterAlt;

  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterAlt
  00126	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 119  : 	delboy->enterDecision			= enterDecision;

  0012a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterDecision
  00136	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 120  : 	delboy->enterRule				= enterRule;

  0013a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterRule
  00146	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 121  : 	delboy->enterSubRule			= enterSubRule;

  0014a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterSubRule
  00156	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 122  : 	delboy->exitDecision			= exitDecision;

  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitDecision
  00166	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 123  : 	delboy->exitRule				= exitRule;

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitRule
  00176	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 124  : 	delboy->exitSubRule				= exitSubRule;

  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitSubRule
  00186	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 125  : 	delboy->handshake				= handshake;

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:handshake
  00196	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 126  : 	delboy->location				= location;

  0019a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:location
  001a6	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 127  : 	delboy->LT						= LT;

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LT
  001b9	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 128  : 	delboy->LTT						= LTT;

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LTT
  001cc	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 129  : 	delboy->mark					= mark;

  001d3	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mark
  001df	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 130  : 	delboy->nilNode					= nilNode;

  001e6	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nilNode
  001f2	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 131  : 	delboy->recognitionException	= recognitionException;

  001f9	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recognitionException
  00205	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 132  : 	delboy->rewind					= rewindMark;

  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindMark
  00218	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 133  : 	delboy->rewindLast				= rewindLast;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindLast
  0022b	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 134  : 	delboy->semanticPredicate		= semanticPredicate;

  00232	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:semanticPredicate
  0023e	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 135  : 	delboy->setTokenBoundaries		= setTokenBoundaries;

  00245	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenBoundaries
  00251	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 136  : 	delboy->terminate				= terminate;

  00258	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:terminate
  00264	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 137  : 	delboy->errorNode				= errorNode;

  0026b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:errorNode
  00277	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 138  : 
; 139  : 	delboy->PROTOCOL_VERSION		= 2;	// ANTLR 3.1 is at protocol version 2

  0027e	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00283	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [rax+16], 2

; 140  : 
; 141  : 	delboy->port					= DEFAULT_DEBUGGER_PORT;

  0028a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0028f	c7 00 cc bf 00
	00		 mov	 DWORD PTR [rax], 49100	; 0000bfccH

; 142  : 
; 143  : 	return delboy;

  00295	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
$LN1@antlr3Debu:

; 144  : }

  0029a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0029e	5f		 pop	 rdi
  0029f	c3		 ret	 0
antlr3DebugListenerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00049	e8 00 00 00 00	 call	 _vsprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00037	b9 01 00 00 00	 mov	 ecx, 1
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00042	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Format$[rsp]
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 _vfprintf_l
  00057	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

  0005b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

  00064	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 957  : }

  00068	8b f8		 mov	 edi, eax
  0006a	48 8b cc	 mov	 rcx, rsp
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printf$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	8b c7		 mov	 eax, edi
  0007b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
