; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
trailingBytesForUTF8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
PUBLIC	ConvertUTF8toUTF16
PUBLIC	ConvertUTF16toUTF8
PUBLIC	ConvertUTF8toUTF32
PUBLIC	ConvertUTF32toUTF8
PUBLIC	ConvertUTF16toUTF32
PUBLIC	ConvertUTF32toUTF16
PUBLIC	isLegalUTF8Sequence
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF8toUTF16 DD imagerel $LN28
	DD	imagerel $LN28+1016
	DD	imagerel $unwind$ConvertUTF8toUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF16toUTF8 DD imagerel $LN29
	DD	imagerel $LN29+858
	DD	imagerel $unwind$ConvertUTF16toUTF8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF8toUTF32 DD imagerel $LN23
	DD	imagerel $LN23+808
	DD	imagerel $unwind$ConvertUTF8toUTF32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF32toUTF8 DD imagerel $LN22
	DD	imagerel $LN22+680
	DD	imagerel $unwind$ConvertUTF32toUTF8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF16toUTF32 DD imagerel $LN15
	DD	imagerel $LN15+451
	DD	imagerel $unwind$ConvertUTF16toUTF32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF32toUTF16 DD imagerel $LN17
	DD	imagerel $LN17+486
	DD	imagerel $unwind$ConvertUTF32toUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isLegalUTF8Sequence DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$isLegalUTF8Sequence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isLegalUTF8 DD imagerel isLegalUTF8
	DD	imagerel isLegalUTF8+436
	DD	imagerel $unwind$isLegalUTF8
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isLegalUTF8 DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isLegalUTF8Sequence DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF32toUTF16 DD 022d01H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF16toUTF32 DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF32toUTF8 DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF8toUTF32 DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF16toUTF8 DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF8toUTF16 DD 022d01H
	DD	070159219H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT isLegalUTF8
_TEXT	SEGMENT
a$ = 0
srcptr$ = 8
tv66 = 16
tv81 = 20
source$ = 48
length$ = 56
isLegalUTF8 PROC					; COMDAT

; 287  : isLegalUTF8(const UTF8 *source, int length) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 288  :     UTF8 a;
; 289  :     const UTF8 *srcptr = source+length;

  00022	48 63 44 24 38	 movsxd	 rax, DWORD PTR length$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR source$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax

; 290  :     switch (length) {

  00037	8b 44 24 38	 mov	 eax, DWORD PTR length$[rsp]
  0003b	89 44 24 10	 mov	 DWORD PTR tv66[rsp], eax
  0003f	83 7c 24 10 01	 cmp	 DWORD PTR tv66[rsp], 1
  00044	0f 84 2d 01 00
	00		 je	 $LN25@isLegalUTF
  0004a	83 7c 24 10 02	 cmp	 DWORD PTR tv66[rsp], 2
  0004f	74 7f		 je	 SHORT $LN13@isLegalUTF
  00051	83 7c 24 10 03	 cmp	 DWORD PTR tv66[rsp], 3
  00056	74 43		 je	 SHORT $LN10@isLegalUTF
  00058	83 7c 24 10 04	 cmp	 DWORD PTR tv66[rsp], 4
  0005d	74 07		 je	 SHORT $LN7@isLegalUTF

; 291  :     default: return false;

  0005f	32 c0		 xor	 al, al
  00061	e9 48 01 00 00	 jmp	 $LN1@isLegalUTF
$LN7@isLegalUTF:

; 292  : 	/* Everything else falls through when "true"... */
; 293  :     case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  00066	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  0006b	48 ff c8	 dec	 rax
  0006e	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  00073	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  00078	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007b	88 04 24	 mov	 BYTE PTR a$[rsp], al
  0007e	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00082	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00087	7c 0b		 jl	 SHORT $LN9@isLegalUTF
  00089	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  0008d	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  00092	7e 07		 jle	 SHORT $LN8@isLegalUTF
$LN9@isLegalUTF:
  00094	32 c0		 xor	 al, al
  00096	e9 13 01 00 00	 jmp	 $LN1@isLegalUTF
$LN8@isLegalUTF:
$LN10@isLegalUTF:

; 294  :     case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  0009b	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000a0	48 ff c8	 dec	 rax
  000a3	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  000a8	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000ad	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b0	88 04 24	 mov	 BYTE PTR a$[rsp], al
  000b3	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000b7	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000bc	7c 0b		 jl	 SHORT $LN12@isLegalUTF
  000be	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000c2	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000c7	7e 07		 jle	 SHORT $LN11@isLegalUTF
$LN12@isLegalUTF:
  000c9	32 c0		 xor	 al, al
  000cb	e9 de 00 00 00	 jmp	 $LN1@isLegalUTF
$LN11@isLegalUTF:
$LN13@isLegalUTF:

; 295  :     case 2: if ((a = (*--srcptr)) > 0xBF) return false;

  000d0	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000d5	48 ff c8	 dec	 rax
  000d8	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  000dd	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000e2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e5	88 04 24	 mov	 BYTE PTR a$[rsp], al
  000e8	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000ec	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000f1	7e 07		 jle	 SHORT $LN14@isLegalUTF
  000f3	32 c0		 xor	 al, al
  000f5	e9 b4 00 00 00	 jmp	 $LN1@isLegalUTF
$LN14@isLegalUTF:

; 296  : 
; 297  : 	switch (*source) {

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  000ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00102	88 44 24 14	 mov	 BYTE PTR tv81[rsp], al
  00106	80 7c 24 14 e0	 cmp	 BYTE PTR tv81[rsp], 224	; 000000e0H
  0010b	74 17		 je	 SHORT $LN15@isLegalUTF
  0010d	80 7c 24 14 ed	 cmp	 BYTE PTR tv81[rsp], 237	; 000000edH
  00112	74 21		 je	 SHORT $LN17@isLegalUTF
  00114	80 7c 24 14 f0	 cmp	 BYTE PTR tv81[rsp], 240	; 000000f0H
  00119	74 2b		 je	 SHORT $LN19@isLegalUTF
  0011b	80 7c 24 14 f4	 cmp	 BYTE PTR tv81[rsp], 244	; 000000f4H
  00120	74 35		 je	 SHORT $LN21@isLegalUTF
  00122	eb 44		 jmp	 SHORT $LN23@isLegalUTF
$LN15@isLegalUTF:

; 298  : 	    /* no fall-through in this inner switch */
; 299  : 	    case 0xE0: if (a < 0xA0) return false; break;

  00124	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00128	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0012d	7d 04		 jge	 SHORT $LN16@isLegalUTF
  0012f	32 c0		 xor	 al, al
  00131	eb 7b		 jmp	 SHORT $LN1@isLegalUTF
$LN16@isLegalUTF:
  00133	eb 42		 jmp	 SHORT $LN4@isLegalUTF
$LN17@isLegalUTF:

; 300  : 	    case 0xED: if (a > 0x9F) return false; break;

  00135	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00139	3d 9f 00 00 00	 cmp	 eax, 159		; 0000009fH
  0013e	7e 04		 jle	 SHORT $LN18@isLegalUTF
  00140	32 c0		 xor	 al, al
  00142	eb 6a		 jmp	 SHORT $LN1@isLegalUTF
$LN18@isLegalUTF:
  00144	eb 31		 jmp	 SHORT $LN4@isLegalUTF
$LN19@isLegalUTF:

; 301  : 	    case 0xF0: if (a < 0x90) return false; break;

  00146	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  0014a	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  0014f	7d 04		 jge	 SHORT $LN20@isLegalUTF
  00151	32 c0		 xor	 al, al
  00153	eb 59		 jmp	 SHORT $LN1@isLegalUTF
$LN20@isLegalUTF:
  00155	eb 20		 jmp	 SHORT $LN4@isLegalUTF
$LN21@isLegalUTF:

; 302  : 	    case 0xF4: if (a > 0x8F) return false; break;

  00157	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  0015b	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  00160	7e 04		 jle	 SHORT $LN22@isLegalUTF
  00162	32 c0		 xor	 al, al
  00164	eb 48		 jmp	 SHORT $LN1@isLegalUTF
$LN22@isLegalUTF:
  00166	eb 0f		 jmp	 SHORT $LN4@isLegalUTF
$LN23@isLegalUTF:

; 303  : 	    default:   if (a < 0x80) return false;

  00168	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  0016c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00171	7d 04		 jge	 SHORT $LN24@isLegalUTF
  00173	32 c0		 xor	 al, al
  00175	eb 37		 jmp	 SHORT $LN1@isLegalUTF
$LN24@isLegalUTF:
$LN4@isLegalUTF:
$LN25@isLegalUTF:

; 304  : 	}
; 305  : 
; 306  :     case 1: if (*source >= 0x80 && *source < 0xC2) return false;

  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  0017c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00184	7c 13		 jl	 SHORT $LN26@isLegalUTF
  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  0018b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018e	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00193	7d 04		 jge	 SHORT $LN26@isLegalUTF
  00195	32 c0		 xor	 al, al
  00197	eb 15		 jmp	 SHORT $LN1@isLegalUTF
$LN26@isLegalUTF:

; 307  :     }
; 308  :     if (*source > 0xF4) return false;

  00199	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  0019e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a1	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  001a6	7e 04		 jle	 SHORT $LN27@isLegalUTF
  001a8	32 c0		 xor	 al, al
  001aa	eb 02		 jmp	 SHORT $LN1@isLegalUTF
$LN27@isLegalUTF:

; 309  :     return true;

  001ac	b0 01		 mov	 al, 1
$LN1@isLegalUTF:

; 310  : }

  001ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b2	5f		 pop	 rdi
  001b3	c3		 ret	 0
isLegalUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT isLegalUTF8Sequence
_TEXT	SEGMENT
length$ = 32
source$ = 64
sourceEnd$ = 72
isLegalUTF8Sequence PROC				; COMDAT

; 319  : isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 320  :     int length = trailingBytesForUTF8[*source]+1;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR source$[rsp]
  00028	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00032	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00036	ff c0		 inc	 eax
  00038	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 321  :     if (source+length > sourceEnd) {

  0003c	48 63 44 24 20	 movsxd	 rax, DWORD PTR length$[rsp]
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00046	48 03 c8	 add	 rcx, rax
  00049	48 8b c1	 mov	 rax, rcx
  0004c	48 3b 44 24 48	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  00051	76 04		 jbe	 SHORT $LN2@isLegalUTF

; 322  : 	return false;

  00053	32 c0		 xor	 al, al
  00055	eb 0e		 jmp	 SHORT $LN1@isLegalUTF
$LN2@isLegalUTF:

; 323  :     }
; 324  :     return isLegalUTF8(source, length);

  00057	8b 54 24 20	 mov	 edx, DWORD PTR length$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00060	e8 00 00 00 00	 call	 isLegalUTF8
$LN1@isLegalUTF:

; 325  : }

  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
isLegalUTF8Sequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF32toUTF16
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
sourceStart$ = 48
sourceEnd$ = 56
targetStart$ = 64
targetEnd$ = 72
flags$ = 80
ConvertUTF32toUTF16 PROC				; COMDAT

; 54   : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 55   :     ConversionResult result = conversionOK;

  0002d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 56   :     const UTF32* source = *sourceStart;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 57   :     UTF16* target = *targetStart;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR targetStart$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 58   :     while (source < sourceEnd) {

  0004e	48 8b 44 24 38	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00053	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00058	0f 83 65 01 00
	00		 jae	 $LN3@ConvertUTF

; 59   : 	UTF32 ch;
; 60   : 	if (target >= targetEnd) {

  0005e	48 8b 44 24 48	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00063	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  00068	72 0c		 jb	 SHORT $LN4@ConvertUTF

; 61   : 	    result = targetExhausted; break;

  0006a	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  00071	e9 4d 01 00 00	 jmp	 $LN3@ConvertUTF
$LN4@ConvertUTF:

; 62   : 	}
; 63   : 	ch = *source++;

  00076	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0007b	8b 00		 mov	 eax, DWORD PTR [rax]
  0007d	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  00081	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 64   : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  0008f	81 7c 24 18 ff
	ff 00 00	 cmp	 DWORD PTR ch$1[rsp], 65535 ; 0000ffffH
  00097	77 74		 ja	 SHORT $LN5@ConvertUTF

; 65   : 	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
; 66   : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00099	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  000a1	72 4a		 jb	 SHORT $LN7@ConvertUTF
  000a3	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  000ab	77 40		 ja	 SHORT $LN7@ConvertUTF

; 67   : 		if (flags == strictConversion) {

  000ad	83 7c 24 50 00	 cmp	 DWORD PTR flags$[rsp], 0
  000b2	75 1c		 jne	 SHORT $LN9@ConvertUTF

; 68   : 		    --source; /* return to the illegal value itself */

  000b4	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000b9	48 83 e8 04	 sub	 rax, 4
  000bd	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 69   : 		    result = sourceIllegal;

  000c2	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 70   : 		    break;

  000c9	e9 f5 00 00 00	 jmp	 $LN3@ConvertUTF

; 71   : 		} else {

  000ce	eb 1b		 jmp	 SHORT $LN10@ConvertUTF
$LN9@ConvertUTF:

; 72   : 		    *target++ = UNI_REPLACEMENT_CHAR;

  000d0	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  000d5	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  000da	66 89 01	 mov	 WORD PTR [rcx], ax
  000dd	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000e2	48 83 c0 02	 add	 rax, 2
  000e6	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN10@ConvertUTF:

; 73   : 		}
; 74   : 	    } else {

  000eb	eb 1b		 jmp	 SHORT $LN8@ConvertUTF
$LN7@ConvertUTF:

; 75   : 		*target++ = (UTF16)ch; /* normal case */

  000ed	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000f2	0f b7 4c 24 18	 movzx	 ecx, WORD PTR ch$1[rsp]
  000f7	66 89 08	 mov	 WORD PTR [rax], cx
  000fa	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000ff	48 83 c0 02	 add	 rax, 2
  00103	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN8@ConvertUTF:

; 76   : 	    }

  00108	e9 b1 00 00 00	 jmp	 $LN6@ConvertUTF
$LN5@ConvertUTF:

; 77   : 	} else if (ch > UNI_MAX_LEGAL_UTF32) {

  0010d	81 7c 24 18 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  00115	76 2d		 jbe	 SHORT $LN11@ConvertUTF

; 78   : 	    if (flags == strictConversion) {

  00117	83 7c 24 50 00	 cmp	 DWORD PTR flags$[rsp], 0
  0011c	75 09		 jne	 SHORT $LN13@ConvertUTF

; 79   : 		result = sourceIllegal;

  0011e	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 80   : 	    } else {

  00125	eb 1b		 jmp	 SHORT $LN14@ConvertUTF
$LN13@ConvertUTF:

; 81   : 		*target++ = UNI_REPLACEMENT_CHAR;

  00127	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  0012c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00131	66 89 01	 mov	 WORD PTR [rcx], ax
  00134	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00139	48 83 c0 02	 add	 rax, 2
  0013d	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN14@ConvertUTF:

; 82   : 	    }
; 83   : 	} else {

  00142	eb 7a		 jmp	 SHORT $LN12@ConvertUTF
$LN11@ConvertUTF:

; 84   : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 85   : 	    if (target + 1 >= targetEnd) {

  00144	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00149	48 83 c0 02	 add	 rax, 2
  0014d	48 3b 44 24 48	 cmp	 rax, QWORD PTR targetEnd$[rsp]
  00152	72 17		 jb	 SHORT $LN15@ConvertUTF

; 86   : 		--source; /* Back up source pointer! */

  00154	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00159	48 83 e8 04	 sub	 rax, 4
  0015d	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 87   : 		result = targetExhausted; break;

  00162	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  00169	eb 58		 jmp	 SHORT $LN3@ConvertUTF
$LN15@ConvertUTF:

; 88   : 	    }
; 89   : 	    ch -= halfBase;

  0016b	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0016f	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  00174	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax

; 90   : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  00178	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0017c	c1 e8 0a	 shr	 eax, 10
  0017f	05 00 d8 00 00	 add	 eax, 55296		; 0000d800H
  00184	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00189	66 89 01	 mov	 WORD PTR [rcx], ax
  0018c	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00191	48 83 c0 02	 add	 rax, 2
  00195	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 91   : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  0019a	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0019e	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001a3	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  001a8	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001ad	66 89 01	 mov	 WORD PTR [rcx], ax
  001b0	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001b5	48 83 c0 02	 add	 rax, 2
  001b9	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN12@ConvertUTF:
$LN6@ConvertUTF:

; 92   : 	}
; 93   :     }

  001be	e9 8b fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 94   :     *sourceStart = source;

  001c3	48 8b 44 24 30	 mov	 rax, QWORD PTR sourceStart$[rsp]
  001c8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  001cd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 95   :     *targetStart = target;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR targetStart$[rsp]
  001d5	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001da	48 89 08	 mov	 QWORD PTR [rax], rcx

; 96   :     return result;

  001dd	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 97   : }

  001e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e4	5f		 pop	 rdi
  001e5	c3		 ret	 0
ConvertUTF32toUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF16toUTF32
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$ = 24
ch2$ = 28
oldSource$1 = 32
sourceStart$ = 64
sourceEnd$ = 72
targetStart$ = 80
targetEnd$ = 88
flags$ = 96
ConvertUTF16toUTF32 PROC				; COMDAT

; 103  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 104  :     ConversionResult result = conversionOK;

  0002d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 105  :     const UTF16* source = *sourceStart;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 106  :     UTF32* target = *targetStart;

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 107  :     UTF32 ch, ch2;
; 108  :     while (source < sourceEnd) {

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00053	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00058	0f 83 42 01 00
	00		 jae	 $LN3@ConvertUTF

; 109  : 	const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */

  0005e	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00063	48 89 44 24 20	 mov	 QWORD PTR oldSource$1[rsp], rax

; 110  : 	ch = *source++;

  00068	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0006d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00070	89 44 24 18	 mov	 DWORD PTR ch$[rsp], eax
  00074	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00079	48 83 c0 02	 add	 rax, 2
  0007d	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 111  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 112  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00082	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  0008a	0f 82 a1 00 00
	00		 jb	 $LN4@ConvertUTF
  00090	81 7c 24 18 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00098	0f 87 93 00 00
	00		 ja	 $LN4@ConvertUTF

; 113  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 114  : 	    if (source < sourceEnd) {

  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  000a3	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  000a8	73 6e		 jae	 SHORT $LN6@ConvertUTF

; 115  : 		ch2 = *source;

  000aa	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000af	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000b2	89 44 24 1c	 mov	 DWORD PTR ch2$[rsp], eax

; 116  : 		/* If it's a low surrogate, convert to UTF32. */
; 117  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  000b6	81 7c 24 1c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000be	72 35		 jb	 SHORT $LN8@ConvertUTF
  000c0	81 7c 24 1c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000c8	77 2b		 ja	 SHORT $LN8@ConvertUTF

; 118  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  000ca	8b 44 24 18	 mov	 eax, DWORD PTR ch$[rsp]
  000ce	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  000d3	c1 e0 0a	 shl	 eax, 10
  000d6	8b 4c 24 1c	 mov	 ecx, DWORD PTR ch2$[rsp]
  000da	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  000e1	89 44 24 18	 mov	 DWORD PTR ch$[rsp], eax

; 119  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 120  : 		    ++source;

  000e5	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000ea	48 83 c0 02	 add	 rax, 2
  000ee	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax
  000f3	eb 21		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 121  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  000f5	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  000fa	75 1a		 jne	 SHORT $LN10@ConvertUTF

; 122  : 		    --source; /* return to the illegal value itself */

  000fc	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00101	48 83 e8 02	 sub	 rax, 2
  00105	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 123  : 		    result = sourceIllegal;

  0010a	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 124  : 		    break;

  00111	e9 8a 00 00 00	 jmp	 $LN3@ConvertUTF
$LN10@ConvertUTF:
$LN9@ConvertUTF:

; 125  : 		}
; 126  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  00116	eb 17		 jmp	 SHORT $LN7@ConvertUTF
$LN6@ConvertUTF:

; 127  : 		--source; /* return to the high surrogate */

  00118	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0011d	48 83 e8 02	 sub	 rax, 2
  00121	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 128  : 		result = sourceExhausted;

  00126	c7 04 24 01 00
	00 00		 mov	 DWORD PTR result$[rsp], 1

; 129  : 		break;

  0012d	eb 71		 jmp	 SHORT $LN3@ConvertUTF
$LN7@ConvertUTF:

; 130  : 	    }

  0012f	eb 32		 jmp	 SHORT $LN5@ConvertUTF
$LN4@ConvertUTF:

; 131  : 	} else if (flags == strictConversion) {

  00131	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  00136	75 2b		 jne	 SHORT $LN11@ConvertUTF

; 132  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 133  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00138	81 7c 24 18 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  00140	72 21		 jb	 SHORT $LN12@ConvertUTF
  00142	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  0014a	77 17		 ja	 SHORT $LN12@ConvertUTF

; 134  : 		--source; /* return to the illegal value itself */

  0014c	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00151	48 83 e8 02	 sub	 rax, 2
  00155	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 135  : 		result = sourceIllegal;

  0015a	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 136  : 		break;

  00161	eb 3d		 jmp	 SHORT $LN3@ConvertUTF
$LN12@ConvertUTF:
$LN11@ConvertUTF:
$LN5@ConvertUTF:

; 137  : 	    }
; 138  : 	}
; 139  : 	if (target >= targetEnd) {

  00163	48 8b 44 24 58	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00168	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  0016d	72 13		 jb	 SHORT $LN13@ConvertUTF

; 140  : 	    source = oldSource; /* Back up source pointer! */

  0016f	48 8b 44 24 20	 mov	 rax, QWORD PTR oldSource$1[rsp]
  00174	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 141  : 	    result = targetExhausted; break;

  00179	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  00180	eb 1e		 jmp	 SHORT $LN3@ConvertUTF
$LN13@ConvertUTF:

; 142  : 	}
; 143  : 	*target++ = ch;

  00182	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00187	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$[rsp]
  0018b	89 08		 mov	 DWORD PTR [rax], ecx
  0018d	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00192	48 83 c0 04	 add	 rax, 4
  00196	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 144  :     }

  0019b	e9 ae fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 145  :     *sourceStart = source;

  001a0	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  001a5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  001aa	48 89 08	 mov	 QWORD PTR [rax], rcx

; 146  :     *targetStart = target;

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  001b2	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001b7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 147  : #ifdef CVTUTF_DEBUG
; 148  : if (result == sourceIllegal) {
; 149  :     ANTLR3_FPRINTF(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
; 150  :     fflush(stderr);
; 151  : }
; 152  : #endif
; 153  :     return result;

  001ba	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 154  : }

  001bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c1	5f		 pop	 rdi
  001c2	c3		 ret	 0
ConvertUTF16toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF32toUTF8
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
bytesToWrite$2 = 28
byteMask$3 = 32
byteMark$4 = 36
tv81 = 40
sourceStart$ = 64
sourceEnd$ = 72
targetStart$ = 80
targetEnd$ = 88
flags$ = 96
ConvertUTF32toUTF8 PROC					; COMDAT

; 404  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

$LN22:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 405  :     ConversionResult result = conversionOK;

  0002d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 406  :     const UTF32* source = *sourceStart;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 407  :     UTF8* target = *targetStart;

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 408  :     while (source < sourceEnd) {

  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00053	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00058	0f 83 27 02 00
	00		 jae	 $LN3@ConvertUTF

; 409  : 	UTF32 ch;
; 410  : 	unsigned short bytesToWrite = 0;

  0005e	33 c0		 xor	 eax, eax
  00060	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 411  : 	const UTF32 byteMask = 0xBF;

  00065	c7 44 24 20 bf
	00 00 00	 mov	 DWORD PTR byteMask$3[rsp], 191 ; 000000bfH

; 412  : 	const UTF32 byteMark = 0x80; 

  0006d	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR byteMark$4[rsp], 128 ; 00000080H

; 413  : 	ch = *source++;

  00075	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0007a	8b 00		 mov	 eax, DWORD PTR [rax]
  0007c	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  00080	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00085	48 83 c0 04	 add	 rax, 4
  00089	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 414  : 	if (flags == strictConversion ) {

  0008e	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  00093	75 2e		 jne	 SHORT $LN6@ConvertUTF

; 415  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 416  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00095	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  0009d	72 24		 jb	 SHORT $LN7@ConvertUTF
  0009f	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  000a7	77 1a		 ja	 SHORT $LN7@ConvertUTF

; 417  : 		--source; /* return to the illegal value itself */

  000a9	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000ae	48 83 e8 04	 sub	 rax, 4
  000b2	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 418  : 		result = sourceIllegal;

  000b7	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 419  : 		break;

  000be	e9 c2 01 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:
$LN6@ConvertUTF:

; 420  : 	    }
; 421  : 	}
; 422  : 	/*
; 423  : 	 * Figure out how many bytes the result will require. Turn any
; 424  : 	 * illegally large UTF32 things (> Plane 17) into replacement chars.
; 425  : 	 */
; 426  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  000c3	81 7c 24 18 80
	00 00 00	 cmp	 DWORD PTR ch$1[rsp], 128 ; 00000080H
  000cb	73 0c		 jae	 SHORT $LN8@ConvertUTF
  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  000d7	eb 5b		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 427  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  000d9	81 7c 24 18 00
	08 00 00	 cmp	 DWORD PTR ch$1[rsp], 2048 ; 00000800H
  000e1	73 0c		 jae	 SHORT $LN10@ConvertUTF
  000e3	b8 02 00 00 00	 mov	 eax, 2
  000e8	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  000ed	eb 45		 jmp	 SHORT $LN11@ConvertUTF
$LN10@ConvertUTF:

; 428  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  000ef	81 7c 24 18 00
	00 01 00	 cmp	 DWORD PTR ch$1[rsp], 65536 ; 00010000H
  000f7	73 0c		 jae	 SHORT $LN12@ConvertUTF
  000f9	b8 03 00 00 00	 mov	 eax, 3
  000fe	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00103	eb 2f		 jmp	 SHORT $LN13@ConvertUTF
$LN12@ConvertUTF:

; 429  : 	} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;

  00105	81 7c 24 18 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  0010d	77 0c		 ja	 SHORT $LN14@ConvertUTF
  0010f	b8 04 00 00 00	 mov	 eax, 4
  00114	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00119	eb 19		 jmp	 SHORT $LN15@ConvertUTF
$LN14@ConvertUTF:

; 430  : 	} else {			    bytesToWrite = 3;

  0011b	b8 03 00 00 00	 mov	 eax, 3
  00120	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 431  : 					    ch = UNI_REPLACEMENT_CHAR;

  00125	c7 44 24 18 fd
	ff 00 00	 mov	 DWORD PTR ch$1[rsp], 65533 ; 0000fffdH

; 432  : 					    result = sourceIllegal;

  0012d	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3
$LN15@ConvertUTF:
$LN13@ConvertUTF:
$LN11@ConvertUTF:
$LN9@ConvertUTF:

; 433  : 	}
; 434  : 	
; 435  : 	target += bytesToWrite;

  00134	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00139	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0013e	48 03 c8	 add	 rcx, rax
  00141	48 8b c1	 mov	 rax, rcx
  00144	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 436  : 	if (target > targetEnd) {

  00149	48 8b 44 24 58	 mov	 rax, QWORD PTR targetEnd$[rsp]
  0014e	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  00153	76 2f		 jbe	 SHORT $LN16@ConvertUTF

; 437  : 	    --source; /* Back up source pointer! */

  00155	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0015a	48 83 e8 04	 sub	 rax, 4
  0015e	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 438  : 	    target -= bytesToWrite; result = targetExhausted; break;

  00163	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00168	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0016d	48 2b c8	 sub	 rcx, rax
  00170	48 8b c1	 mov	 rax, rcx
  00173	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00178	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  0017f	e9 01 01 00 00	 jmp	 $LN3@ConvertUTF
$LN16@ConvertUTF:

; 439  : 	}
; 440  : 	switch (bytesToWrite) { /* note: everything falls through. */

  00184	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00189	89 44 24 28	 mov	 DWORD PTR tv81[rsp], eax
  0018d	83 7c 24 28 01	 cmp	 DWORD PTR tv81[rsp], 1
  00192	0f 84 a7 00 00
	00		 je	 $LN20@ConvertUTF
  00198	83 7c 24 28 02	 cmp	 DWORD PTR tv81[rsp], 2
  0019d	74 71		 je	 SHORT $LN19@ConvertUTF
  0019f	83 7c 24 28 03	 cmp	 DWORD PTR tv81[rsp], 3
  001a4	74 3b		 je	 SHORT $LN18@ConvertUTF
  001a6	83 7c 24 28 04	 cmp	 DWORD PTR tv81[rsp], 4
  001ab	74 05		 je	 SHORT $LN17@ConvertUTF
  001ad	e9 b9 00 00 00	 jmp	 $LN4@ConvertUTF
$LN17@ConvertUTF:

; 441  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001b2	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001b7	48 ff c8	 dec	 rax
  001ba	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  001bf	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  001c3	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  001c7	0b c8		 or	 ecx, eax
  001c9	8b c1		 mov	 eax, ecx
  001cb	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  001cf	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001d4	88 01		 mov	 BYTE PTR [rcx], al
  001d6	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  001da	c1 e8 06	 shr	 eax, 6
  001dd	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN18@ConvertUTF:

; 442  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001e1	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001e6	48 ff c8	 dec	 rax
  001e9	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  001ee	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  001f2	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  001f6	0b c8		 or	 ecx, eax
  001f8	8b c1		 mov	 eax, ecx
  001fa	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  001fe	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00203	88 01		 mov	 BYTE PTR [rcx], al
  00205	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  00209	c1 e8 06	 shr	 eax, 6
  0020c	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN19@ConvertUTF:

; 443  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00210	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00215	48 ff c8	 dec	 rax
  00218	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  0021d	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  00221	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00225	0b c8		 or	 ecx, eax
  00227	8b c1		 mov	 eax, ecx
  00229	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  0022d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00232	88 01		 mov	 BYTE PTR [rcx], al
  00234	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  00238	c1 e8 06	 shr	 eax, 6
  0023b	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN20@ConvertUTF:

; 444  : 	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);

  0023f	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00244	48 ff c8	 dec	 rax
  00247	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  0024c	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstByteMark
  00258	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025c	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00260	0b c8		 or	 ecx, eax
  00262	8b c1		 mov	 eax, ecx
  00264	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00269	88 01		 mov	 BYTE PTR [rcx], al
$LN4@ConvertUTF:

; 445  : 	}
; 446  : 	target += bytesToWrite;

  0026b	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00270	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00275	48 03 c8	 add	 rcx, rax
  00278	48 8b c1	 mov	 rax, rcx
  0027b	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 447  :     }

  00280	e9 c9 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 448  :     *sourceStart = source;

  00285	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  0028a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  0028f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 449  :     *targetStart = target;

  00292	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00297	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0029c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 450  :     return result;

  0029f	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 451  : }

  002a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002a6	5f		 pop	 rdi
  002a7	c3		 ret	 0
ConvertUTF32toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF8toUTF32
_TEXT	SEGMENT
result$ = 32
source$ = 40
target$ = 48
ch$1 = 56
extraBytesToRead$2 = 60
tv80 = 64
sourceStart$ = 96
sourceEnd$ = 104
targetStart$ = 112
targetEnd$ = 120
flags$ = 128
ConvertUTF8toUTF32 PROC					; COMDAT

; 457  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 458  :     ConversionResult result = conversionOK;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 459  :     const UTF8* source = *sourceStart;

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 460  :     UTF32* target = *targetStart;

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 461  :     while (source < sourceEnd) {

  0004f	48 8b 44 24 68	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00054	48 39 44 24 28	 cmp	 QWORD PTR source$[rsp], rax
  00059	0f 83 8b 02 00
	00		 jae	 $LN3@ConvertUTF

; 462  : 	UTF32 ch = 0;

  0005f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ch$1[rsp], 0

; 463  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0006c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00076	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  0007b	66 89 44 24 3c	 mov	 WORD PTR extraBytesToRead$2[rsp], ax

; 464  : 	if (source + extraBytesToRead >= sourceEnd) {

  00080	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 3b 44 24 68	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  00095	72 0d		 jb	 SHORT $LN6@ConvertUTF

; 465  : 	    result = sourceExhausted; break;

  00097	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
  0009f	e9 46 02 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 466  : 	}
; 467  : 	/* Do this check whether lenient or strict */
; 468  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  000a4	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000a9	ff c0		 inc	 eax
  000ab	8b d0		 mov	 edx, eax
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  000b2	e8 00 00 00 00	 call	 isLegalUTF8
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	85 c0		 test	 eax, eax
  000bc	75 0d		 jne	 SHORT $LN7@ConvertUTF

; 469  : 	    result = sourceIllegal;

  000be	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 470  : 	    break;

  000c6	e9 1f 02 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 471  : 	}
; 472  : 	/*
; 473  : 	 * The cases all fall through. See "Note A" below.
; 474  : 	 */
; 475  : 	switch (extraBytesToRead) {

  000cb	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000d0	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  000d4	83 7c 24 40 05	 cmp	 DWORD PTR tv80[rsp], 5
  000d9	0f 87 15 01 00
	00		 ja	 $LN4@ConvertUTF
  000df	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv80[rsp]
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000eb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN22@ConvertUTF[rcx+rax*4]
  000f2	48 03 c1	 add	 rax, rcx
  000f5	ff e0		 jmp	 rax
$LN8@ConvertUTF:

; 476  : 	    case 5: ch += *source++; ch <<= 6;

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000fc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ff	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00103	03 c8		 add	 ecx, eax
  00105	8b c1		 mov	 eax, ecx
  00107	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00110	48 ff c0	 inc	 rax
  00113	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00118	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  0011c	c1 e0 06	 shl	 eax, 6
  0011f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN9@ConvertUTF:

; 477  : 	    case 4: ch += *source++; ch <<= 6;

  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00128	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012b	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0012f	03 c8		 add	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0013c	48 ff c0	 inc	 rax
  0013f	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00144	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00148	c1 e0 06	 shl	 eax, 6
  0014b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN10@ConvertUTF:

; 478  : 	    case 3: ch += *source++; ch <<= 6;

  0014f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00154	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00157	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0015b	03 c8		 add	 ecx, eax
  0015d	8b c1		 mov	 eax, ecx
  0015f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00168	48 ff c0	 inc	 rax
  0016b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00170	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00174	c1 e0 06	 shl	 eax, 6
  00177	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN11@ConvertUTF:

; 479  : 	    case 2: ch += *source++; ch <<= 6;

  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00180	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00183	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00187	03 c8		 add	 ecx, eax
  00189	8b c1		 mov	 eax, ecx
  0018b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00194	48 ff c0	 inc	 rax
  00197	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  0019c	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001a0	c1 e0 06	 shl	 eax, 6
  001a3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN12@ConvertUTF:

; 480  : 	    case 1: ch += *source++; ch <<= 6;

  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001af	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001bb	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001c0	48 ff c0	 inc	 rax
  001c3	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  001c8	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001cc	c1 e0 06	 shl	 eax, 6
  001cf	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN13@ConvertUTF:

; 481  : 	    case 0: ch += *source++;

  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001db	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001df	03 c8		 add	 ecx, eax
  001e1	8b c1		 mov	 eax, ecx
  001e3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001e7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ec	48 ff c0	 inc	 rax
  001ef	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
$LN4@ConvertUTF:

; 482  : 	}
; 483  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001f4	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  00200	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00207	2b c8		 sub	 ecx, eax
  00209	8b c1		 mov	 eax, ecx
  0020b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 484  : 
; 485  : 	if (target >= targetEnd) {

  0020f	48 8b 44 24 78	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00214	48 39 44 24 30	 cmp	 QWORD PTR target$[rsp], rax
  00219	72 26		 jb	 SHORT $LN14@ConvertUTF

; 486  : 	    source -= (extraBytesToRead+1); /* Back up the source pointer! */

  0021b	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00220	ff c0		 inc	 eax
  00222	48 98		 cdqe
  00224	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00229	48 2b c8	 sub	 rcx, rax
  0022c	48 8b c1	 mov	 rax, rcx
  0022f	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 487  : 	    result = targetExhausted; break;

  00234	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  0023c	e9 a9 00 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 488  : 	}
; 489  : 	if (ch <= UNI_MAX_LEGAL_UTF32) {

  00241	81 7c 24 38 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  00249	77 79		 ja	 SHORT $LN15@ConvertUTF

; 490  : 	    /*
; 491  : 	     * UTF-16 surrogate values are illegal in UTF-32, and anything
; 492  : 	     * over Plane 17 (> 0x10FFFF) is illegal.
; 493  : 	     */
; 494  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0024b	81 7c 24 38 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  00253	72 54		 jb	 SHORT $LN17@ConvertUTF
  00255	81 7c 24 38 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  0025d	77 4a		 ja	 SHORT $LN17@ConvertUTF

; 495  : 		if (flags == strictConversion) {

  0025f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  00267	75 25		 jne	 SHORT $LN19@ConvertUTF

; 496  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  00269	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0026e	ff c0		 inc	 eax
  00270	48 98		 cdqe
  00272	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00277	48 2b c8	 sub	 rcx, rax
  0027a	48 8b c1	 mov	 rax, rcx
  0027d	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 497  : 		    result = sourceIllegal;

  00282	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 498  : 		    break;

  0028a	eb 5e		 jmp	 SHORT $LN3@ConvertUTF

; 499  : 		} else {

  0028c	eb 19		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 500  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  0028e	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00293	c7 00 fd ff 00
	00		 mov	 DWORD PTR [rax], 65533	; 0000fffdH
  00299	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0029e	48 83 c0 04	 add	 rax, 4
  002a2	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN20@ConvertUTF:

; 501  : 		}
; 502  : 	    } else {

  002a7	eb 19		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 503  : 		*target++ = ch;

  002a9	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002ae	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  002b2	89 08		 mov	 DWORD PTR [rax], ecx
  002b4	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002b9	48 83 c0 04	 add	 rax, 4
  002bd	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN18@ConvertUTF:

; 504  : 	    }
; 505  : 	} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */

  002c2	eb 21		 jmp	 SHORT $LN16@ConvertUTF
$LN15@ConvertUTF:

; 506  : 	    result = sourceIllegal;

  002c4	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 507  : 	    *target++ = UNI_REPLACEMENT_CHAR;

  002cc	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002d1	c7 00 fd ff 00
	00		 mov	 DWORD PTR [rax], 65533	; 0000fffdH
  002d7	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002dc	48 83 c0 04	 add	 rax, 4
  002e0	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN16@ConvertUTF:

; 508  : 	}
; 509  :     }

  002e5	e9 65 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 510  :     *sourceStart = source;

  002ea	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  002ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  002f4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 511  :     *targetStart = target;

  002f7	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  002fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  00301	48 89 08	 mov	 QWORD PTR [rax], rcx

; 512  :     return result;

  00304	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 513  : }

  00308	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0030c	5f		 pop	 rdi
  0030d	c3		 ret	 0
  0030e	66 90		 npad	 2
$LN22@ConvertUTF:
  00310	00 00 00 00	 DD	 $LN13@ConvertUTF
  00314	00 00 00 00	 DD	 $LN12@ConvertUTF
  00318	00 00 00 00	 DD	 $LN11@ConvertUTF
  0031c	00 00 00 00	 DD	 $LN10@ConvertUTF
  00320	00 00 00 00	 DD	 $LN9@ConvertUTF
  00324	00 00 00 00	 DD	 $LN8@ConvertUTF
ConvertUTF8toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF16toUTF8
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
bytesToWrite$2 = 28
byteMask$3 = 32
byteMark$4 = 36
oldSource$5 = 40
ch2$6 = 48
tv128 = 52
sourceStart$ = 80
sourceEnd$ = 88
targetStart$ = 96
targetEnd$ = 104
flags$ = 112
ConvertUTF16toUTF8 PROC					; COMDAT

; 207  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

$LN29:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 208  :     ConversionResult result = conversionOK;

  0002d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 209  :     const UTF16* source = *sourceStart;

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 210  :     UTF8* target = *targetStart;

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR targetStart$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 211  :     while (source < sourceEnd) {

  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00053	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00058	0f 83 d9 02 00
	00		 jae	 $LN3@ConvertUTF

; 212  : 	UTF32 ch;
; 213  : 	unsigned short bytesToWrite = 0;

  0005e	33 c0		 xor	 eax, eax
  00060	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 214  : 	const UTF32 byteMask = 0xBF;

  00065	c7 44 24 20 bf
	00 00 00	 mov	 DWORD PTR byteMask$3[rsp], 191 ; 000000bfH

; 215  : 	const UTF32 byteMark = 0x80; 

  0006d	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR byteMark$4[rsp], 128 ; 00000080H

; 216  : 	const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */

  00075	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0007a	48 89 44 24 28	 mov	 QWORD PTR oldSource$5[rsp], rax

; 217  : 	ch = *source++;

  0007f	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00084	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00087	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00090	48 83 c0 02	 add	 rax, 2
  00094	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 218  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 219  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00099	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  000a1	0f 82 a4 00 00
	00		 jb	 $LN6@ConvertUTF
  000a7	81 7c 24 18 ff
	db 00 00	 cmp	 DWORD PTR ch$1[rsp], 56319 ; 0000dbffH
  000af	0f 87 96 00 00
	00		 ja	 $LN6@ConvertUTF

; 220  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 221  : 	    if (source < sourceEnd) {

  000b5	48 8b 44 24 58	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  000ba	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  000bf	73 6e		 jae	 SHORT $LN8@ConvertUTF

; 222  : 		UTF32 ch2 = *source;

  000c1	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000c6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000c9	89 44 24 30	 mov	 DWORD PTR ch2$6[rsp], eax

; 223  : 		/* If it's a low surrogate, convert to UTF32. */
; 224  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  000cd	81 7c 24 30 00
	dc 00 00	 cmp	 DWORD PTR ch2$6[rsp], 56320 ; 0000dc00H
  000d5	72 35		 jb	 SHORT $LN10@ConvertUTF
  000d7	81 7c 24 30 ff
	df 00 00	 cmp	 DWORD PTR ch2$6[rsp], 57343 ; 0000dfffH
  000df	77 2b		 ja	 SHORT $LN10@ConvertUTF

; 225  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  000e1	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  000e5	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  000ea	c1 e0 0a	 shl	 eax, 10
  000ed	8b 4c 24 30	 mov	 ecx, DWORD PTR ch2$6[rsp]
  000f1	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  000f8	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax

; 226  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 227  : 		    ++source;

  000fc	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00101	48 83 c0 02	 add	 rax, 2
  00105	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax
  0010a	eb 21		 jmp	 SHORT $LN11@ConvertUTF
$LN10@ConvertUTF:

; 228  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  0010c	83 7c 24 70 00	 cmp	 DWORD PTR flags$[rsp], 0
  00111	75 1a		 jne	 SHORT $LN12@ConvertUTF

; 229  : 		    --source; /* return to the illegal value itself */

  00113	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00118	48 83 e8 02	 sub	 rax, 2
  0011c	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 230  : 		    result = sourceIllegal;

  00121	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 231  : 		    break;

  00128	e9 0a 02 00 00	 jmp	 $LN3@ConvertUTF
$LN12@ConvertUTF:
$LN11@ConvertUTF:

; 232  : 		}
; 233  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  0012d	eb 1a		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 234  : 		--source; /* return to the high surrogate */

  0012f	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00134	48 83 e8 02	 sub	 rax, 2
  00138	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 235  : 		result = sourceExhausted;

  0013d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR result$[rsp], 1

; 236  : 		break;

  00144	e9 ee 01 00 00	 jmp	 $LN3@ConvertUTF
$LN9@ConvertUTF:

; 237  : 	    }

  00149	eb 35		 jmp	 SHORT $LN7@ConvertUTF
$LN6@ConvertUTF:

; 238  :         } else if (flags == strictConversion) {

  0014b	83 7c 24 70 00	 cmp	 DWORD PTR flags$[rsp], 0
  00150	75 2e		 jne	 SHORT $LN13@ConvertUTF

; 239  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 240  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00152	81 7c 24 18 00
	dc 00 00	 cmp	 DWORD PTR ch$1[rsp], 56320 ; 0000dc00H
  0015a	72 24		 jb	 SHORT $LN14@ConvertUTF
  0015c	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00164	77 1a		 ja	 SHORT $LN14@ConvertUTF

; 241  : 		--source; /* return to the illegal value itself */

  00166	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0016b	48 83 e8 02	 sub	 rax, 2
  0016f	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 242  : 		result = sourceIllegal;

  00174	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 243  : 		break;

  0017b	e9 b7 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:
$LN13@ConvertUTF:
$LN7@ConvertUTF:

; 244  : 	    }
; 245  : 	}
; 246  : 	/* Figure out how many bytes the result will require */
; 247  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  00180	81 7c 24 18 80
	00 00 00	 cmp	 DWORD PTR ch$1[rsp], 128 ; 00000080H
  00188	73 0c		 jae	 SHORT $LN15@ConvertUTF
  0018a	b8 01 00 00 00	 mov	 eax, 1
  0018f	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00194	eb 54		 jmp	 SHORT $LN16@ConvertUTF
$LN15@ConvertUTF:

; 248  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  00196	81 7c 24 18 00
	08 00 00	 cmp	 DWORD PTR ch$1[rsp], 2048 ; 00000800H
  0019e	73 0c		 jae	 SHORT $LN17@ConvertUTF
  001a0	b8 02 00 00 00	 mov	 eax, 2
  001a5	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  001aa	eb 3e		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 249  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  001ac	81 7c 24 18 00
	00 01 00	 cmp	 DWORD PTR ch$1[rsp], 65536 ; 00010000H
  001b4	73 0c		 jae	 SHORT $LN19@ConvertUTF
  001b6	b8 03 00 00 00	 mov	 eax, 3
  001bb	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  001c0	eb 28		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 250  : 	} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

  001c2	81 7c 24 18 00
	00 11 00	 cmp	 DWORD PTR ch$1[rsp], 1114112 ; 00110000H
  001ca	73 0c		 jae	 SHORT $LN21@ConvertUTF
  001cc	b8 04 00 00 00	 mov	 eax, 4
  001d1	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  001d6	eb 12		 jmp	 SHORT $LN22@ConvertUTF
$LN21@ConvertUTF:

; 251  : 	} else {			    bytesToWrite = 3;

  001d8	b8 03 00 00 00	 mov	 eax, 3
  001dd	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 252  : 					    ch = UNI_REPLACEMENT_CHAR;

  001e2	c7 44 24 18 fd
	ff 00 00	 mov	 DWORD PTR ch$1[rsp], 65533 ; 0000fffdH
$LN22@ConvertUTF:
$LN20@ConvertUTF:
$LN18@ConvertUTF:
$LN16@ConvertUTF:

; 253  : 	}
; 254  : 
; 255  : 	target += bytesToWrite;

  001ea	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  001ef	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001f4	48 03 c8	 add	 rcx, rax
  001f7	48 8b c1	 mov	 rax, rcx
  001fa	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 256  : 	if (target > targetEnd) {

  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00204	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  00209	76 2b		 jbe	 SHORT $LN23@ConvertUTF

; 257  : 	    source = oldSource; /* Back up source pointer! */

  0020b	48 8b 44 24 28	 mov	 rax, QWORD PTR oldSource$5[rsp]
  00210	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 258  : 	    target -= bytesToWrite; result = targetExhausted; break;

  00215	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  0021a	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0021f	48 2b c8	 sub	 rcx, rax
  00222	48 8b c1	 mov	 rax, rcx
  00225	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  0022a	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  00231	e9 01 01 00 00	 jmp	 $LN3@ConvertUTF
$LN23@ConvertUTF:

; 259  : 	}
; 260  : 	switch (bytesToWrite) { /* note: everything falls through. */

  00236	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  0023b	89 44 24 34	 mov	 DWORD PTR tv128[rsp], eax
  0023f	83 7c 24 34 01	 cmp	 DWORD PTR tv128[rsp], 1
  00244	0f 84 a7 00 00
	00		 je	 $LN27@ConvertUTF
  0024a	83 7c 24 34 02	 cmp	 DWORD PTR tv128[rsp], 2
  0024f	74 71		 je	 SHORT $LN26@ConvertUTF
  00251	83 7c 24 34 03	 cmp	 DWORD PTR tv128[rsp], 3
  00256	74 3b		 je	 SHORT $LN25@ConvertUTF
  00258	83 7c 24 34 04	 cmp	 DWORD PTR tv128[rsp], 4
  0025d	74 05		 je	 SHORT $LN24@ConvertUTF
  0025f	e9 b9 00 00 00	 jmp	 $LN4@ConvertUTF
$LN24@ConvertUTF:

; 261  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00264	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00269	48 ff c8	 dec	 rax
  0026c	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00271	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  00275	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00279	0b c8		 or	 ecx, eax
  0027b	8b c1		 mov	 eax, ecx
  0027d	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  00281	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00286	88 01		 mov	 BYTE PTR [rcx], al
  00288	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0028c	c1 e8 06	 shr	 eax, 6
  0028f	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN25@ConvertUTF:

; 262  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00293	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00298	48 ff c8	 dec	 rax
  0029b	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  002a0	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  002a4	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  002a8	0b c8		 or	 ecx, eax
  002aa	8b c1		 mov	 eax, ecx
  002ac	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  002b0	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  002b5	88 01		 mov	 BYTE PTR [rcx], al
  002b7	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  002bb	c1 e8 06	 shr	 eax, 6
  002be	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN26@ConvertUTF:

; 263  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  002c2	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  002c7	48 ff c8	 dec	 rax
  002ca	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  002cf	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  002d3	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  002d7	0b c8		 or	 ecx, eax
  002d9	8b c1		 mov	 eax, ecx
  002db	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  002df	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  002e4	88 01		 mov	 BYTE PTR [rcx], al
  002e6	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  002ea	c1 e8 06	 shr	 eax, 6
  002ed	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN27@ConvertUTF:

; 264  : 	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

  002f1	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  002f6	48 ff c8	 dec	 rax
  002f9	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  002fe	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstByteMark
  0030a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030e	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00312	0b c8		 or	 ecx, eax
  00314	8b c1		 mov	 eax, ecx
  00316	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0031b	88 01		 mov	 BYTE PTR [rcx], al
$LN4@ConvertUTF:

; 265  : 	}
; 266  : 	target += bytesToWrite;

  0031d	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00322	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00327	48 03 c8	 add	 rcx, rax
  0032a	48 8b c1	 mov	 rax, rcx
  0032d	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 267  :     }

  00332	e9 17 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 268  :     *sourceStart = source;

  00337	48 8b 44 24 50	 mov	 rax, QWORD PTR sourceStart$[rsp]
  0033c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  00341	48 89 08	 mov	 QWORD PTR [rax], rcx

; 269  :     *targetStart = target;

  00344	48 8b 44 24 60	 mov	 rax, QWORD PTR targetStart$[rsp]
  00349	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0034e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 270  :     return result;

  00351	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 271  : }

  00354	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00358	5f		 pop	 rdi
  00359	c3		 ret	 0
ConvertUTF16toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF8toUTF16
_TEXT	SEGMENT
result$ = 32
source$ = 40
target$ = 48
ch$1 = 56
extraBytesToRead$2 = 60
tv80 = 64
sourceStart$ = 96
sourceEnd$ = 104
targetStart$ = 112
targetEnd$ = 120
flags$ = 128
ConvertUTF8toUTF16 PROC					; COMDAT

; 331  : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

$LN28:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 332  :     ConversionResult result = conversionOK;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 333  :     const UTF8* source = *sourceStart;

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 334  :     UTF16* target = *targetStart;

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 335  :     while (source < sourceEnd) {

  0004f	48 8b 44 24 68	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00054	48 39 44 24 28	 cmp	 QWORD PTR source$[rsp], rax
  00059	0f 83 5a 03 00
	00		 jae	 $LN3@ConvertUTF

; 336  : 	UTF32 ch = 0;

  0005f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ch$1[rsp], 0

; 337  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0006c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00076	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  0007b	66 89 44 24 3c	 mov	 WORD PTR extraBytesToRead$2[rsp], ax

; 338  : 	if (source + extraBytesToRead >= sourceEnd) {

  00080	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 3b 44 24 68	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  00095	72 0d		 jb	 SHORT $LN6@ConvertUTF

; 339  : 	    result = sourceExhausted; break;

  00097	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
  0009f	e9 15 03 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 340  : 	}
; 341  : 	/* Do this check whether lenient or strict */
; 342  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  000a4	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000a9	ff c0		 inc	 eax
  000ab	8b d0		 mov	 edx, eax
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  000b2	e8 00 00 00 00	 call	 isLegalUTF8
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	85 c0		 test	 eax, eax
  000bc	75 0d		 jne	 SHORT $LN7@ConvertUTF

; 343  : 	    result = sourceIllegal;

  000be	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 344  : 	    break;

  000c6	e9 ee 02 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 345  : 	}
; 346  : 	/*
; 347  : 	 * The cases all fall through. See "Note A" below.
; 348  : 	 */
; 349  : 	switch (extraBytesToRead) {

  000cb	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000d0	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  000d4	83 7c 24 40 05	 cmp	 DWORD PTR tv80[rsp], 5
  000d9	0f 87 15 01 00
	00		 ja	 $LN4@ConvertUTF
  000df	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv80[rsp]
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000eb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@ConvertUTF[rcx+rax*4]
  000f2	48 03 c1	 add	 rax, rcx
  000f5	ff e0		 jmp	 rax
$LN8@ConvertUTF:

; 350  : 	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000fc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ff	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00103	03 c8		 add	 ecx, eax
  00105	8b c1		 mov	 eax, ecx
  00107	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00110	48 ff c0	 inc	 rax
  00113	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00118	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  0011c	c1 e0 06	 shl	 eax, 6
  0011f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN9@ConvertUTF:

; 351  : 	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00128	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012b	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0012f	03 c8		 add	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0013c	48 ff c0	 inc	 rax
  0013f	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00144	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00148	c1 e0 06	 shl	 eax, 6
  0014b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN10@ConvertUTF:

; 352  : 	    case 3: ch += *source++; ch <<= 6;

  0014f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00154	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00157	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0015b	03 c8		 add	 ecx, eax
  0015d	8b c1		 mov	 eax, ecx
  0015f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00168	48 ff c0	 inc	 rax
  0016b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00170	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00174	c1 e0 06	 shl	 eax, 6
  00177	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN11@ConvertUTF:

; 353  : 	    case 2: ch += *source++; ch <<= 6;

  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00180	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00183	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00187	03 c8		 add	 ecx, eax
  00189	8b c1		 mov	 eax, ecx
  0018b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00194	48 ff c0	 inc	 rax
  00197	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  0019c	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001a0	c1 e0 06	 shl	 eax, 6
  001a3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN12@ConvertUTF:

; 354  : 	    case 1: ch += *source++; ch <<= 6;

  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001af	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001bb	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001c0	48 ff c0	 inc	 rax
  001c3	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  001c8	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001cc	c1 e0 06	 shl	 eax, 6
  001cf	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN13@ConvertUTF:

; 355  : 	    case 0: ch += *source++;

  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001db	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001df	03 c8		 add	 ecx, eax
  001e1	8b c1		 mov	 eax, ecx
  001e3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001e7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ec	48 ff c0	 inc	 rax
  001ef	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
$LN4@ConvertUTF:

; 356  : 	}
; 357  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001f4	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  00200	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00207	2b c8		 sub	 ecx, eax
  00209	8b c1		 mov	 eax, ecx
  0020b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 358  : 
; 359  : 	if (target >= targetEnd) {

  0020f	48 8b 44 24 78	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00214	48 39 44 24 30	 cmp	 QWORD PTR target$[rsp], rax
  00219	72 26		 jb	 SHORT $LN14@ConvertUTF

; 360  : 	    source -= (extraBytesToRead+1); /* Back up source pointer! */

  0021b	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00220	ff c0		 inc	 eax
  00222	48 98		 cdqe
  00224	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00229	48 2b c8	 sub	 rcx, rax
  0022c	48 8b c1	 mov	 rax, rcx
  0022f	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 361  : 	    result = targetExhausted; break;

  00234	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  0023c	e9 78 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 362  : 	}
; 363  : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  00241	81 7c 24 38 ff
	ff 00 00	 cmp	 DWORD PTR ch$1[rsp], 65535 ; 0000ffffH
  00249	0f 87 83 00 00
	00		 ja	 $LN15@ConvertUTF

; 364  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 365  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0024f	81 7c 24 38 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  00257	72 59		 jb	 SHORT $LN17@ConvertUTF
  00259	81 7c 24 38 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00261	77 4f		 ja	 SHORT $LN17@ConvertUTF

; 366  : 		if (flags == strictConversion) {

  00263	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  0026b	75 28		 jne	 SHORT $LN19@ConvertUTF

; 367  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  0026d	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00272	ff c0		 inc	 eax
  00274	48 98		 cdqe
  00276	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0027b	48 2b c8	 sub	 rcx, rax
  0027e	48 8b c1	 mov	 rax, rcx
  00281	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 368  : 		    result = sourceIllegal;

  00286	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 369  : 		    break;

  0028e	e9 26 01 00 00	 jmp	 $LN3@ConvertUTF

; 370  : 		} else {

  00293	eb 1b		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 371  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  00295	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  0029a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  0029f	66 89 01	 mov	 WORD PTR [rcx], ax
  002a2	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002a7	48 83 c0 02	 add	 rax, 2
  002ab	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN20@ConvertUTF:

; 372  : 		}
; 373  : 	    } else {

  002b0	eb 1b		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 374  : 		*target++ = (UTF16)ch; /* normal case */

  002b2	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002b7	0f b7 4c 24 38	 movzx	 ecx, WORD PTR ch$1[rsp]
  002bc	66 89 08	 mov	 WORD PTR [rax], cx
  002bf	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002c4	48 83 c0 02	 add	 rax, 2
  002c8	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN18@ConvertUTF:

; 375  : 	    }

  002cd	e9 e2 00 00 00	 jmp	 $LN16@ConvertUTF
$LN15@ConvertUTF:

; 376  : 	} else if (ch > UNI_MAX_UTF16) {

  002d2	81 7c 24 38 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  002da	76 52		 jbe	 SHORT $LN21@ConvertUTF

; 377  : 	    if (flags == strictConversion) {

  002dc	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  002e4	75 28		 jne	 SHORT $LN23@ConvertUTF

; 378  : 		result = sourceIllegal;

  002e6	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 379  : 		source -= (extraBytesToRead+1); /* return to the start */

  002ee	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  002f3	ff c0		 inc	 eax
  002f5	48 98		 cdqe
  002f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  002fc	48 2b c8	 sub	 rcx, rax
  002ff	48 8b c1	 mov	 rax, rcx
  00302	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 380  : 		break; /* Bail out; shouldn't continue */

  00307	e9 ad 00 00 00	 jmp	 $LN3@ConvertUTF

; 381  : 	    } else {

  0030c	eb 1b		 jmp	 SHORT $LN24@ConvertUTF
$LN23@ConvertUTF:

; 382  : 		*target++ = UNI_REPLACEMENT_CHAR;

  0030e	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  00313	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  00318	66 89 01	 mov	 WORD PTR [rcx], ax
  0031b	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00320	48 83 c0 02	 add	 rax, 2
  00324	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN24@ConvertUTF:

; 383  : 	    }
; 384  : 	} else {

  00329	e9 86 00 00 00	 jmp	 $LN22@ConvertUTF
$LN21@ConvertUTF:

; 385  : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 386  : 	    if (target + 1 >= targetEnd) {

  0032e	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00333	48 83 c0 02	 add	 rax, 2
  00337	48 3b 44 24 78	 cmp	 rax, QWORD PTR targetEnd$[rsp]
  0033c	72 23		 jb	 SHORT $LN25@ConvertUTF

; 387  : 		source -= (extraBytesToRead+1); /* Back up source pointer! */

  0033e	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00343	ff c0		 inc	 eax
  00345	48 98		 cdqe
  00347	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0034c	48 2b c8	 sub	 rcx, rax
  0034f	48 8b c1	 mov	 rax, rcx
  00352	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 388  : 		result = targetExhausted; break;

  00357	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  0035f	eb 58		 jmp	 SHORT $LN3@ConvertUTF
$LN25@ConvertUTF:

; 389  : 	    }
; 390  : 	    ch -= halfBase;

  00361	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00365	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  0036a	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 391  : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  0036e	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00372	c1 e8 0a	 shr	 eax, 10
  00375	05 00 d8 00 00	 add	 eax, 55296		; 0000d800H
  0037a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  0037f	66 89 01	 mov	 WORD PTR [rcx], ax
  00382	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00387	48 83 c0 02	 add	 rax, 2
  0038b	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax

; 392  : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  00390	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00394	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00399	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  0039e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  003a3	66 89 01	 mov	 WORD PTR [rcx], ax
  003a6	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  003ab	48 83 c0 02	 add	 rax, 2
  003af	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN22@ConvertUTF:
$LN16@ConvertUTF:

; 393  : 	}
; 394  :     }

  003b4	e9 96 fc ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 395  :     *sourceStart = source;

  003b9	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  003be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  003c3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 396  :     *targetStart = target;

  003c6	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  003cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  003d0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 397  :     return result;

  003d3	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 398  : }

  003d7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003db	5f		 pop	 rdi
  003dc	c3		 ret	 0
  003dd	0f 1f 00	 npad	 3
$LN27@ConvertUTF:
  003e0	00 00 00 00	 DD	 $LN13@ConvertUTF
  003e4	00 00 00 00	 DD	 $LN12@ConvertUTF
  003e8	00 00 00 00	 DD	 $LN11@ConvertUTF
  003ec	00 00 00 00	 DD	 $LN10@ConvertUTF
  003f0	00 00 00 00	 DD	 $LN9@ConvertUTF
  003f4	00 00 00 00	 DD	 $LN8@ConvertUTF
ConvertUTF8toUTF16 ENDP
_TEXT	ENDS
END
