; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	e2a
CONST	SEGMENT
trailingBytesForUTF8 DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
	ORG $+8
e2a	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	085H
	DD	09H
	DD	086H
	DD	07fH
	DD	087H
	DD	08dH
	DD	08eH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	08fH
	DD	0aH
	DD	08H
	DD	097H
	DD	018H
	DD	019H
	DD	09cH
	DD	09dH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	080H
	DD	081H
	DD	082H
	DD	083H
	DD	084H
	DD	092H
	DD	017H
	DD	01bH
	DD	088H
	DD	089H
	DD	08aH
	DD	08bH
	DD	08cH
	DD	05H
	DD	06H
	DD	07H
	DD	090H
	DD	091H
	DD	016H
	DD	093H
	DD	094H
	DD	095H
	DD	096H
	DD	04H
	DD	098H
	DD	099H
	DD	09aH
	DD	09bH
	DD	014H
	DD	015H
	DD	09eH
	DD	01aH
	DD	020H
	DD	0a0H
	DD	0e2H
	DD	0e4H
	DD	0e0H
	DD	0e1H
	DD	0e3H
	DD	0e5H
	DD	0e7H
	DD	0f1H
	DD	060H
	DD	02eH
	DD	03cH
	DD	028H
	DD	02bH
	DD	07cH
	DD	026H
	DD	0e9H
	DD	0eaH
	DD	0ebH
	DD	0e8H
	DD	0edH
	DD	0eeH
	DD	0efH
	DD	0ecH
	DD	0dfH
	DD	021H
	DD	024H
	DD	02aH
	DD	029H
	DD	03bH
	DD	09fH
	DD	02dH
	DD	02fH
	DD	0c2H
	DD	0c4H
	DD	0c0H
	DD	0c1H
	DD	0c3H
	DD	0c5H
	DD	0c7H
	DD	0d1H
	DD	05eH
	DD	02cH
	DD	025H
	DD	05fH
	DD	03eH
	DD	03fH
	DD	0f8H
	DD	0c9H
	DD	0caH
	DD	0cbH
	DD	0c8H
	DD	0cdH
	DD	0ceH
	DD	0cfH
	DD	0ccH
	DD	0a8H
	DD	03aH
	DD	023H
	DD	040H
	DD	027H
	DD	03dH
	DD	022H
	DD	0d8H
	DD	061H
	DD	062H
	DD	063H
	DD	064H
	DD	065H
	DD	066H
	DD	067H
	DD	068H
	DD	069H
	DD	0abH
	DD	0bbH
	DD	0f0H
	DD	0fdH
	DD	0feH
	DD	0b1H
	DD	0b0H
	DD	06aH
	DD	06bH
	DD	06cH
	DD	06dH
	DD	06eH
	DD	06fH
	DD	070H
	DD	071H
	DD	072H
	DD	0aaH
	DD	0baH
	DD	0e6H
	DD	0b8H
	DD	0c6H
	DD	0a4H
	DD	0b5H
	DD	0afH
	DD	073H
	DD	074H
	DD	075H
	DD	076H
	DD	077H
	DD	078H
	DD	079H
	DD	07aH
	DD	0a1H
	DD	0bfH
	DD	0d0H
	DD	0ddH
	DD	0deH
	DD	0aeH
	DD	0a2H
	DD	0a3H
	DD	0a5H
	DD	0b7H
	DD	0a9H
	DD	0a7H
	DD	0b6H
	DD	0bcH
	DD	0bdH
	DD	0beH
	DD	0acH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	0b4H
	DD	0d7H
	DD	0f9H
	DD	041H
	DD	042H
	DD	043H
	DD	044H
	DD	045H
	DD	046H
	DD	047H
	DD	048H
	DD	049H
	DD	0adH
	DD	0f4H
	DD	0f6H
	DD	0f2H
	DD	0f3H
	DD	0f5H
	DD	0a6H
	DD	04aH
	DD	04bH
	DD	04cH
	DD	04dH
	DD	04eH
	DD	04fH
	DD	050H
	DD	051H
	DD	052H
	DD	0b9H
	DD	0fbH
	DD	0fcH
	DD	0dbH
	DD	0faH
	DD	0ffH
	DD	0d9H
	DD	0f7H
	DD	053H
	DD	054H
	DD	055H
	DD	056H
	DD	057H
	DD	058H
	DD	059H
	DD	05aH
	DD	0b2H
	DD	0d4H
	DD	0d6H
	DD	0d2H
	DD	0d3H
	DD	0d5H
	DD	030H
	DD	031H
	DD	032H
	DD	033H
	DD	034H
	DD	035H
	DD	036H
	DD	037H
	DD	038H
	DD	039H
	DD	0b3H
	DD	07bH
	DD	0dcH
	DD	07dH
	DD	0daH
	DD	07eH
CONST	ENDS
PUBLIC	antlr38BitSetupStream
PUBLIC	antlr3UTF16SetupStream
PUBLIC	antlr3UTF32SetupStream
PUBLIC	antlr3UTF8SetupStream
PUBLIC	antlr3EBCDICSetupStream
PUBLIC	antlr3GenericSetupStream
PUBLIC	??_C@_08ONBMMFLC@?9memory?9?$AA@		; `string'
EXTRN	__imp_toupper:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	antlr3IntStreamNew:PROC
EXTRN	antlr3StringFactoryNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetupStream DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$antlr38BitSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16SetupStream DD imagerel $LN11
	DD	imagerel $LN11+344
	DD	imagerel $unwind$antlr3UTF16SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32SetupStream DD imagerel $LN11
	DD	imagerel $LN11+284
	DD	imagerel $unwind$antlr3UTF32SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8SetupStream DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$antlr3UTF8SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EBCDICSetupStream DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$antlr3EBCDICSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3GenericSetupStream DD imagerel $LN3
	DD	imagerel $LN3+564
	DD	imagerel $unwind$antlr3GenericSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitConsume DD imagerel antlr38BitConsume
	DD	imagerel antlr38BitConsume+178
	DD	imagerel $unwind$antlr38BitConsume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLA DD imagerel antlr38BitLA
	DD	imagerel antlr38BitLA+118
	DD	imagerel $unwind$antlr38BitLA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLA_ucase DD imagerel antlr38BitLA_ucase
	DD	imagerel antlr38BitLA_ucase+131
	DD	imagerel $unwind$antlr38BitLA_ucase
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitIndex DD imagerel antlr38BitIndex
	DD	imagerel antlr38BitIndex+57
	DD	imagerel $unwind$antlr38BitIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitMark DD imagerel antlr38BitMark
	DD	imagerel antlr38BitMark+287
	DD	imagerel $unwind$antlr38BitMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRewind DD imagerel antlr38BitRewind
	DD	imagerel antlr38BitRewind+213
	DD	imagerel $unwind$antlr38BitRewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRewindLast DD imagerel antlr38BitRewindLast
	DD	imagerel antlr38BitRewindLast+58
	DD	imagerel $unwind$antlr38BitRewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRelease DD imagerel antlr38BitRelease
	DD	imagerel antlr38BitRelease+69
	DD	imagerel $unwind$antlr38BitRelease
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSeek DD imagerel antlr38BitSeek
	DD	imagerel antlr38BitSeek+151
	DD	imagerel $unwind$antlr38BitSeek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetSourceName DD imagerel antlr38BitGetSourceName
	DD	imagerel antlr38BitGetSourceName+17
	DD	imagerel $unwind$antlr38BitGetSourceName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3InputClose DD imagerel antlr3InputClose
	DD	imagerel antlr3InputClose+199
	DD	imagerel $unwind$antlr3InputClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3InputReset DD imagerel antlr3InputReset
	DD	imagerel antlr3InputReset+162
	DD	imagerel $unwind$antlr3InputReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitReuse DD imagerel antlr38BitReuse
	DD	imagerel antlr38BitReuse+284
	DD	imagerel $unwind$antlr38BitReuse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLT DD imagerel antlr38BitLT
	DD	imagerel antlr38BitLT+65
	DD	imagerel $unwind$antlr38BitLT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSize DD imagerel antlr38BitSize
	DD	imagerel antlr38BitSize+16
	DD	imagerel $unwind$antlr38BitSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSubstr DD imagerel antlr38BitSubstr
	DD	imagerel antlr38BitSubstr+104
	DD	imagerel $unwind$antlr38BitSubstr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetLine DD imagerel antlr38BitGetLine
	DD	imagerel antlr38BitGetLine+16
	DD	imagerel $unwind$antlr38BitGetLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetLineBuf DD imagerel antlr38BitGetLineBuf
	DD	imagerel antlr38BitGetLineBuf+17
	DD	imagerel $unwind$antlr38BitGetLineBuf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetCharPosition DD imagerel antlr38BitGetCharPosition
	DD	imagerel antlr38BitGetCharPosition+16
	DD	imagerel $unwind$antlr38BitGetCharPosition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetLine DD imagerel antlr38BitSetLine
	DD	imagerel antlr38BitSetLine+24
	DD	imagerel $unwind$antlr38BitSetLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetCharPosition DD imagerel antlr38BitSetCharPosition
	DD	imagerel antlr38BitSetCharPosition+24
	DD	imagerel $unwind$antlr38BitSetCharPosition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetNewLineChar DD imagerel antlr38BitSetNewLineChar
	DD	imagerel antlr38BitSetNewLineChar+27
	DD	imagerel $unwind$antlr38BitSetNewLineChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetUcaseLA DD imagerel antlr38BitSetUcaseLA
	DD	imagerel antlr38BitSetUcaseLA+61
	DD	imagerel $unwind$antlr38BitSetUcaseLA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Consume DD imagerel antlr3UTF16Consume
	DD	imagerel antlr3UTF16Consume+299
	DD	imagerel $unwind$antlr3UTF16Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LA DD imagerel antlr3UTF16LA
	DD	imagerel antlr3UTF16LA+572
	DD	imagerel $unwind$antlr3UTF16LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16ConsumeLE DD imagerel antlr3UTF16ConsumeLE
	DD	imagerel antlr3UTF16ConsumeLE+333
	DD	imagerel $unwind$antlr3UTF16ConsumeLE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LALE DD imagerel antlr3UTF16LALE
	DD	imagerel antlr3UTF16LALE+652
	DD	imagerel $unwind$antlr3UTF16LALE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16ConsumeBE DD imagerel antlr3UTF16ConsumeBE
	DD	imagerel antlr3UTF16ConsumeBE+333
	DD	imagerel $unwind$antlr3UTF16ConsumeBE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LABE DD imagerel antlr3UTF16LABE
	DD	imagerel antlr3UTF16LABE+658
	DD	imagerel $unwind$antlr3UTF16LABE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Index DD imagerel antlr3UTF16Index
	DD	imagerel antlr3UTF16Index+57
	DD	imagerel $unwind$antlr3UTF16Index
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Seek DD imagerel antlr3UTF16Seek
	DD	imagerel antlr3UTF16Seek+141
	DD	imagerel $unwind$antlr3UTF16Seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Substr DD imagerel antlr3UTF16Substr
	DD	imagerel antlr3UTF16Substr+112
	DD	imagerel $unwind$antlr3UTF16Substr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Consume DD imagerel antlr3UTF32Consume
	DD	imagerel antlr3UTF32Consume+179
	DD	imagerel $unwind$antlr3UTF32Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LA DD imagerel antlr3UTF32LA
	DD	imagerel antlr3UTF32LA+117
	DD	imagerel $unwind$antlr3UTF32LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LALE DD imagerel antlr3UTF32LALE
	DD	imagerel antlr3UTF32LALE+167
	DD	imagerel $unwind$antlr3UTF32LALE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LABE DD imagerel antlr3UTF32LABE
	DD	imagerel antlr3UTF32LABE+167
	DD	imagerel $unwind$antlr3UTF32LABE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Index DD imagerel antlr3UTF32Index
	DD	imagerel antlr3UTF32Index+57
	DD	imagerel $unwind$antlr3UTF32Index
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Seek DD imagerel antlr3UTF32Seek
	DD	imagerel antlr3UTF32Seek+141
	DD	imagerel $unwind$antlr3UTF32Seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Substr DD imagerel antlr3UTF32Substr
	DD	imagerel antlr3UTF32Substr+112
	DD	imagerel $unwind$antlr3UTF32Substr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8Consume DD imagerel antlr3UTF8Consume
	DD	imagerel antlr3UTF8Consume+612
	DD	imagerel $unwind$antlr3UTF8Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8LA DD imagerel antlr3UTF8LA
	DD	imagerel antlr3UTF8LA+740
	DD	imagerel $unwind$antlr3UTF8LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EBCDICLA DD imagerel antlr3EBCDICLA
	DD	imagerel antlr3EBCDICLA+128
	DD	imagerel $unwind$antlr3EBCDICLA
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_08ONBMMFLC@?9memory?9?$AA@
CONST	SEGMENT
??_C@_08ONBMMFLC@?9memory?9?$AA@ DB '-memory-', 00H	; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EBCDICLA DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8LA DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8Consume DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Substr DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Seek DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Index DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LABE DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LALE DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LA DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Consume DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Substr DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Seek DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Index DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LABE DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16ConsumeBE DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LALE DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16ConsumeLE DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LA DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Consume DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetUcaseLA DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetNewLineChar DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetCharPosition DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetCharPosition DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetLineBuf DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSubstr DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLT DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitReuse DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3InputReset DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3InputClose DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetSourceName DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSeek DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRelease DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRewindLast DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRewind DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitMark DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitIndex DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLA_ucase DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLA DD 022201H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitConsume DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3GenericSetupStream DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EBCDICSetupStream DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8SetupStream DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32SetupStream DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16SetupStream DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetupStream DD 021e01H
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3EBCDICLA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr3EBCDICLA PROC					; COMDAT

; 2035 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 2036 :     pANTLR3_INPUT_STREAM input;
; 2037 : 
; 2038 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 2039 : 
; 2040 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003c	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00045	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00048	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0004c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00050	48 3b c1	 cmp	 rax, rcx
  00053	72 09		 jb	 SHORT $LN2@antlr3EBCD

; 2041 :     {
; 2042 :         return	ANTLR3_CHARSTREAM_EOF;

  00055	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005a	eb 1e		 jmp	 SHORT $LN1@antlr3EBCD

; 2043 :     }

  0005c	eb 1c		 jmp	 SHORT $LN3@antlr3EBCD
$LN2@antlr3EBCD:

; 2044 :     else
; 2045 :     {
; 2046 :         // Translate the required character via the constant conversion table
; 2047 :         //
; 2048 :         return	e2a[(*((pANTLR3_UINT8)input->nextChar + la - 1))];

  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006b	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:e2a
  00077	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
$LN3@antlr3EBCD:
$LN1@antlr3EBCD:

; 2049 :     }
; 2050 : }

  0007a	48 83 c4 10	 add	 rsp, 16
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
antlr3EBCDICLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF8LA
_TEXT	SEGMENT
input$ = 0
extraBytesToRead$ = 8
ch$ = 12
nextChar$ = 16
tv89 = 24
tv90 = 28
tv139 = 32
is$ = 64
la$ = 72
antlr3UTF8LA PROC					; COMDAT

; 1871 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1872 :     pANTLR3_INPUT_STREAM    input;
; 1873 :     ANTLR3_UINT32           extraBytesToRead;
; 1874 :     ANTLR3_UCHAR            ch;
; 1875 :     pANTLR3_UINT8           nextChar;
; 1876 : 
; 1877 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1878 : 
; 1879 :     nextChar = input->nextChar;

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00033	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00037	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1880 : 
; 1881 :     // Do we need to traverse forwards or backwards?
; 1882 :     // - LA(0) is treated as LA(1) and we assume that the nextChar is
; 1883 :     //   already positioned.
; 1884 :     // - LA(n+) ; n>1 means we must traverse forward n-1 characters catering for UTF8 encoding
; 1885 :     // - LA(-n) means we must traverse backwards n chracters
; 1886 :     //
; 1887 :     if (la > 1) {

  0003c	83 7c 24 48 01	 cmp	 DWORD PTR la$[rsp], 1
  00041	7e 7d		 jle	 SHORT $LN10@antlr3UTF8

; 1888 : 
; 1889 :         // Make sure that we have at least one character left before trying to
; 1890 :         // loop through the buffer.
; 1891 :         //
; 1892 :         if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00043	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00047	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0004a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0004e	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00052	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00057	73 5b		 jae	 SHORT $LN12@antlr3UTF8
$LN2@antlr3UTF8:

; 1893 :         {	
; 1894 :             // Now traverse n-1 characters forward
; 1895 :             //
; 1896 :             while (--la > 0)

  00059	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  0005d	ff c8		 dec	 eax
  0005f	89 44 24 48	 mov	 DWORD PTR la$[rsp], eax
  00063	83 7c 24 48 00	 cmp	 DWORD PTR la$[rsp], 0
  00068	7e 48		 jle	 SHORT $LN3@antlr3UTF8

; 1897 :             {
; 1898 :                 // Does the next character require trailing bytes?
; 1899 :                 // If so advance the pointer by that many bytes as well as advancing
; 1900 :                 // one position for what will be at least a single byte character.
; 1901 :                 //
; 1902 :                 nextChar += trailingBytesForUTF8[*nextChar] + 1;

  0006a	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0006f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00079	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0007c	ff c0		 inc	 eax
  0007e	8b c0		 mov	 eax, eax
  00080	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1903 : 
; 1904 :                 // Does that calculation take us past the byte length of the buffer?
; 1905 :                 //
; 1906 :                 if	(nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00090	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00094	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00097	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009b	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0009f	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000a4	72 0a		 jb	 SHORT $LN14@antlr3UTF8

; 1907 :                 {
; 1908 :                     return ANTLR3_CHARSTREAM_EOF;

  000a6	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  000ab	e9 13 02 00 00	 jmp	 $LN1@antlr3UTF8
$LN14@antlr3UTF8:

; 1909 :                 }
; 1910 :             }

  000b0	eb a7		 jmp	 SHORT $LN2@antlr3UTF8
$LN3@antlr3UTF8:

; 1911 :         }

  000b2	eb 0a		 jmp	 SHORT $LN13@antlr3UTF8
$LN12@antlr3UTF8:

; 1912 :         else
; 1913 :         {
; 1914 :             return ANTLR3_CHARSTREAM_EOF;

  000b4	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  000b9	e9 05 02 00 00	 jmp	 $LN1@antlr3UTF8
$LN13@antlr3UTF8:

; 1915 :         }
; 1916 :     }

  000be	eb 73		 jmp	 SHORT $LN11@antlr3UTF8
$LN10@antlr3UTF8:
$LN4@antlr3UTF8:

; 1917 :     else
; 1918 :     {
; 1919 :         // LA is negative so we decrease the pointer by n character positions
; 1920 :         //
; 1921 :         while   (nextChar > (pANTLR3_UINT8)input->data && la++ < 0)

  000c0	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000c4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c8	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000cd	76 64		 jbe	 SHORT $LN5@antlr3UTF8
  000cf	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  000d3	89 44 24 18	 mov	 DWORD PTR tv89[rsp], eax
  000d7	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 44 24 48	 mov	 DWORD PTR la$[rsp], eax
  000e1	83 7c 24 18 00	 cmp	 DWORD PTR tv89[rsp], 0
  000e6	7d 0a		 jge	 SHORT $LN23@antlr3UTF8
  000e8	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000f0	eb 08		 jmp	 SHORT $LN24@antlr3UTF8
$LN23@antlr3UTF8:
  000f2	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN24@antlr3UTF8:
  000fa	83 7c 24 1c 00	 cmp	 DWORD PTR tv90[rsp], 0
  000ff	74 32		 je	 SHORT $LN5@antlr3UTF8

; 1922 :         {
; 1923 :             // Traversing backwards in UTF8 means decermenting by one
; 1924 :             // then continuing to decrement while ever a character pattern
; 1925 :             // is flagged as being a trailing byte of an encoded code point.
; 1926 :             // Trailing UTF8 bytes always start with 10 in binary. We assumne that
; 1927 :             // the UTF8 is well formed and do not check boundary conditions
; 1928 :             //
; 1929 :             nextChar--;

  00101	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00106	48 ff c8	 dec	 rax
  00109	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN6@antlr3UTF8:

; 1930 :             while ((*nextChar & 0xC0) == 0x80)

  0010e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00113	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00116	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0011b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00120	75 0f		 jne	 SHORT $LN7@antlr3UTF8

; 1931 :             {
; 1932 :                 nextChar--;

  00122	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00127	48 ff c8	 dec	 rax
  0012a	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1933 :             }

  0012f	eb dd		 jmp	 SHORT $LN6@antlr3UTF8
$LN7@antlr3UTF8:

; 1934 :         }

  00131	eb 8d		 jmp	 SHORT $LN4@antlr3UTF8
$LN5@antlr3UTF8:
$LN11@antlr3UTF8:

; 1935 :     }
; 1936 : 
; 1937 :     // nextChar is now pointing at the UTF8 encoded character that we need to
; 1938 :     // decode and return.
; 1939 :     //
; 1940 :     // Are there more bytes needed to make up the whole thing?
; 1941 :     //
; 1942 :     extraBytesToRead = trailingBytesForUTF8[*nextChar];

  00133	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00138	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00142	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00145	89 44 24 08	 mov	 DWORD PTR extraBytesToRead$[rsp], eax

; 1943 :     if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00149	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  0014d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00152	48 03 c8	 add	 rcx, rax
  00155	48 8b c1	 mov	 rax, rcx
  00158	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0015c	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  0015f	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00163	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00167	48 3b c1	 cmp	 rax, rcx
  0016a	72 0a		 jb	 SHORT $LN15@antlr3UTF8

; 1944 :     {
; 1945 :         return ANTLR3_CHARSTREAM_EOF;

  0016c	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00171	e9 4d 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN15@antlr3UTF8:

; 1946 :     }
; 1947 : 
; 1948 :     // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1949 :     // 
; 1950 :     ch  = 0;

  00176	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR ch$[rsp], 0

; 1951 :     switch (extraBytesToRead) {

  0017e	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  00182	89 44 24 20	 mov	 DWORD PTR tv139[rsp], eax
  00186	83 7c 24 20 05	 cmp	 DWORD PTR tv139[rsp], 5
  0018b	0f 87 14 01 00
	00		 ja	 $LN8@antlr3UTF8
  00191	8b 44 24 20	 mov	 eax, DWORD PTR tv139[rsp]
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0019c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN25@antlr3UTF8[rcx+rax*4]
  001a3	48 03 c1	 add	 rax, rcx
  001a6	ff e0		 jmp	 rax
$LN16@antlr3UTF8:

; 1952 :             case 5: ch += *nextChar++; ch <<= 6;

  001a8	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ad	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b0	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001b4	03 c8		 add	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001bc	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001c1	48 ff c0	 inc	 rax
  001c4	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001c9	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001cd	c1 e0 06	 shl	 eax, 6
  001d0	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF8:

; 1953 :             case 4: ch += *nextChar++; ch <<= 6;

  001d4	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001d9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001dc	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001e0	03 c8		 add	 ecx, eax
  001e2	8b c1		 mov	 eax, ecx
  001e4	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001e8	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ed	48 ff c0	 inc	 rax
  001f0	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001f5	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001f9	c1 e0 06	 shl	 eax, 6
  001fc	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN18@antlr3UTF8:

; 1954 :             case 3: ch += *nextChar++; ch <<= 6;

  00200	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00205	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00208	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  0020c	03 c8		 add	 ecx, eax
  0020e	8b c1		 mov	 eax, ecx
  00210	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00214	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00219	48 ff c0	 inc	 rax
  0021c	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00221	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00225	c1 e0 06	 shl	 eax, 6
  00228	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN19@antlr3UTF8:

; 1955 :             case 2: ch += *nextChar++; ch <<= 6;

  0022c	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00231	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00234	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00238	03 c8		 add	 ecx, eax
  0023a	8b c1		 mov	 eax, ecx
  0023c	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00240	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00245	48 ff c0	 inc	 rax
  00248	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0024d	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00251	c1 e0 06	 shl	 eax, 6
  00254	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN20@antlr3UTF8:

; 1956 :             case 1: ch += *nextChar++; ch <<= 6;

  00258	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0025d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00260	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00264	03 c8		 add	 ecx, eax
  00266	8b c1		 mov	 eax, ecx
  00268	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  0026c	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00271	48 ff c0	 inc	 rax
  00274	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00279	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  0027d	c1 e0 06	 shl	 eax, 6
  00280	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN21@antlr3UTF8:

; 1957 :             case 0: ch += *nextChar++;

  00284	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00289	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0028c	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00290	03 c8		 add	 ecx, eax
  00292	8b c1		 mov	 eax, ecx
  00294	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00298	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0029d	48 ff c0	 inc	 rax
  002a0	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN8@antlr3UTF8:

; 1958 :     }
; 1959 : 
; 1960 :     // Magically correct the input value
; 1961 :     //
; 1962 :     ch -= offsetsFromUTF8[extraBytesToRead];

  002a5	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  002b0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002b3	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  002b7	2b c8		 sub	 ecx, eax
  002b9	8b c1		 mov	 eax, ecx
  002bb	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax

; 1963 : 
; 1964 :     return ch;

  002bf	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF8:

; 1965 : }

  002c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002c7	5f		 pop	 rdi
  002c8	c3		 ret	 0
  002c9	0f 1f 00	 npad	 3
$LN25@antlr3UTF8:
  002cc	00 00 00 00	 DD	 $LN21@antlr3UTF8
  002d0	00 00 00 00	 DD	 $LN20@antlr3UTF8
  002d4	00 00 00 00	 DD	 $LN19@antlr3UTF8
  002d8	00 00 00 00	 DD	 $LN18@antlr3UTF8
  002dc	00 00 00 00	 DD	 $LN17@antlr3UTF8
  002e0	00 00 00 00	 DD	 $LN16@antlr3UTF8
antlr3UTF8LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF8Consume
_TEXT	SEGMENT
input$ = 0
extraBytesToRead$ = 8
ch$ = 12
nextChar$ = 16
tv90 = 24
is$ = 48
antlr3UTF8Consume PROC					; COMDAT

; 1805 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1806 :     pANTLR3_INPUT_STREAM    input;
; 1807 :     ANTLR3_UINT32           extraBytesToRead;
; 1808 :     ANTLR3_UCHAR            ch;
; 1809 :     pANTLR3_UINT8           nextChar;
; 1810 : 
; 1811 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1812 : 
; 1813 :     nextChar = input->nextChar;

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00033	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1814 : 
; 1815 :     if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00038	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0003c	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0003f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00043	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00047	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0004c	0f 83 f3 01 00
	00		 jae	 $LN4@antlr3UTF8

; 1816 :     {	
; 1817 : 	// Indicate one more character in this line
; 1818 : 	//
; 1819 : 	input->charPositionInLine++;

  00052	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00056	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00059	ff c0		 inc	 eax
  0005b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0005f	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1820 : 	
; 1821 :         // Are there more bytes needed to make up the whole thing?
; 1822 :         //
; 1823 :         extraBytesToRead = trailingBytesForUTF8[*nextChar];

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00067	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00071	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00074	89 44 24 08	 mov	 DWORD PTR extraBytesToRead$[rsp], eax

; 1824 : 
; 1825 :         if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00078	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  0007c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0008b	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  0008e	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00092	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00096	48 3b c1	 cmp	 rax, rcx
  00099	72 1c		 jb	 SHORT $LN5@antlr3UTF8

; 1826 :         {
; 1827 :             input->nextChar = (((pANTLR3_UINT8)input->data) + input->sizeBuf);

  0009b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000a2	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a6	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000aa	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ae	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1828 :             return;

  000b2	e9 8e 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN5@antlr3UTF8:

; 1829 :         }
; 1830 : 
; 1831 :         // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1832 :         // Legal UTF8 is only 4 bytes but 6 bytes could be used in old UTF8 so
; 1833 :         // we allow it.
; 1834 :         //
; 1835 :         ch  = 0;

  000b7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR ch$[rsp], 0

; 1836 :        	switch (extraBytesToRead) {

  000bf	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  000c3	89 44 24 18	 mov	 DWORD PTR tv90[rsp], eax
  000c7	83 7c 24 18 05	 cmp	 DWORD PTR tv90[rsp], 5
  000cc	0f 87 14 01 00
	00		 ja	 $LN2@antlr3UTF8
  000d2	8b 44 24 18	 mov	 eax, DWORD PTR tv90[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000dd	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN14@antlr3UTF8[rcx+rax*4]
  000e4	48 03 c1	 add	 rax, rcx
  000e7	ff e0		 jmp	 rax
$LN6@antlr3UTF8:

; 1837 : 	    case 5: ch += *nextChar++; ch <<= 6;

  000e9	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000ee	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f1	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  000f5	03 c8		 add	 ecx, eax
  000f7	8b c1		 mov	 eax, ecx
  000f9	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  000fd	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00102	48 ff c0	 inc	 rax
  00105	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0010a	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  0010e	c1 e0 06	 shl	 eax, 6
  00111	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN7@antlr3UTF8:

; 1838 : 	    case 4: ch += *nextChar++; ch <<= 6;

  00115	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0011a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0011d	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00121	03 c8		 add	 ecx, eax
  00123	8b c1		 mov	 eax, ecx
  00125	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00129	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0012e	48 ff c0	 inc	 rax
  00131	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00136	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  0013a	c1 e0 06	 shl	 eax, 6
  0013d	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN8@antlr3UTF8:

; 1839 : 	    case 3: ch += *nextChar++; ch <<= 6;

  00141	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00146	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00149	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  0014d	03 c8		 add	 ecx, eax
  0014f	8b c1		 mov	 eax, ecx
  00151	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00155	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00162	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00166	c1 e0 06	 shl	 eax, 6
  00169	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN9@antlr3UTF8:

; 1840 : 	    case 2: ch += *nextChar++; ch <<= 6;

  0016d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00172	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00175	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00179	03 c8		 add	 ecx, eax
  0017b	8b c1		 mov	 eax, ecx
  0017d	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00181	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00186	48 ff c0	 inc	 rax
  00189	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0018e	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00192	c1 e0 06	 shl	 eax, 6
  00195	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN10@antlr3UTF8:

; 1841 : 	    case 1: ch += *nextChar++; ch <<= 6;

  00199	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0019e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a1	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001a5	03 c8		 add	 ecx, eax
  001a7	8b c1		 mov	 eax, ecx
  001a9	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001ad	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001b2	48 ff c0	 inc	 rax
  001b5	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001ba	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001be	c1 e0 06	 shl	 eax, 6
  001c1	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN11@antlr3UTF8:

; 1842 : 	    case 0: ch += *nextChar++;

  001c5	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ca	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001cd	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001d1	03 c8		 add	 ecx, eax
  001d3	8b c1		 mov	 eax, ecx
  001d5	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001d9	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001de	48 ff c0	 inc	 rax
  001e1	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN2@antlr3UTF8:

; 1843 : 	}
; 1844 : 
; 1845 :         // Magically correct the input value
; 1846 :         //
; 1847 : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001e6	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  001f1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001f4	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001f8	2b c8		 sub	 ecx, eax
  001fa	8b c1		 mov	 eax, ecx
  001fc	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax

; 1848 : 	if  (ch == input->newlineChar)

  00200	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00204	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [rax+208]
  0020a	39 44 24 0c	 cmp	 DWORD PTR ch$[rsp], eax
  0020e	75 28		 jne	 SHORT $LN12@antlr3UTF8

; 1849 : 	{
; 1850 : 	    /* Reset for start of a new line of input
; 1851 : 	     */
; 1852 : 	    input->line++;

  00210	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00214	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00217	ff c0		 inc	 eax
  00219	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0021d	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1853 : 	    input->charPositionInLine	= 0;

  00220	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00224	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1854 : 	    input->currentLine		= (void *)nextChar;

  0022b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0022f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00234	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN12@antlr3UTF8:

; 1855 : 	}
; 1856 : 
; 1857 :         // Update input pointer
; 1858 :         //
; 1859 :         input->nextChar = nextChar;

  00238	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0023c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00241	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN4@antlr3UTF8:
$LN1@antlr3UTF8:

; 1860 :     }
; 1861 : }

  00245	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00249	5f		 pop	 rdi
  0024a	c3		 ret	 0
  0024b	90		 npad	 1
$LN14@antlr3UTF8:
  0024c	00 00 00 00	 DD	 $LN11@antlr3UTF8
  00250	00 00 00 00	 DD	 $LN10@antlr3UTF8
  00254	00 00 00 00	 DD	 $LN9@antlr3UTF8
  00258	00 00 00 00	 DD	 $LN8@antlr3UTF8
  0025c	00 00 00 00	 DD	 $LN7@antlr3UTF8
  00260	00 00 00 00	 DD	 $LN6@antlr3UTF8
antlr3UTF8Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Substr
_TEXT	SEGMENT
tv75 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr3UTF32Substr PROC					; COMDAT

; 1621 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1622 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/4) + 1);

  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  00032	48 2b c8	 sub	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	33 d2		 xor	 edx, edx
  0003a	b9 04 00 00 00	 mov	 ecx, 4
  0003f	f7 f1		 div	 ecx
  00041	ff c0		 inc	 eax
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00048	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0004c	48 89 4c 24 20	 mov	 QWORD PTR tv75[rsp], rcx
  00051	44 8b c0	 mov	 r8d, eax
  00054	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0005e	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR tv75[rsp]
  00067	ff 50 20	 call	 QWORD PTR [rax+32]

; 1623 : }

  0006a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
antlr3UTF32Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Seek
_TEXT	SEGMENT
input$ = 32
is$ = 64
seekPoint$ = 72
antlr3UTF32Seek PROC					; COMDAT

; 1634 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1635 : 	pANTLR3_INPUT_STREAM input;
; 1636 : 
; 1637 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1638 : 
; 1639 : 	// If the requested seek point is less than the current
; 1640 : 	// input point, then we assume that we are resetting from a mark
; 1641 : 	// and do not need to scan, but can just set to there as rewind will
; 1642 :         // reset line numbers and so on.
; 1643 : 	//
; 1644 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0003f	7f 10		 jg	 SHORT $LN4@antlr3UTF3

; 1645 : 	{
; 1646 : 		input->nextChar	= (void *)seekPoint;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  0004b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1647 : 	}

  0004f	eb 36		 jmp	 SHORT $LN5@antlr3UTF3
$LN4@antlr3UTF3:
$LN2@antlr3UTF3:

; 1648 : 	else
; 1649 : 	{
; 1650 :             // Call consume until we reach the asked for seek point or EOF
; 1651 :             //
; 1652 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00060	ff 50 30	 call	 QWORD PTR [rax+48]
  00063	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00066	74 1f		 je	 SHORT $LN3@antlr3UTF3
  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0006d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00071	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  00076	7d 0f		 jge	 SHORT $LN3@antlr3UTF3

; 1653 : 	    {
; 1654 : 		is->consume(is);

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00082	ff 50 28	 call	 QWORD PTR [rax+40]

; 1655 : 	    }

  00085	eb ca		 jmp	 SHORT $LN2@antlr3UTF3
$LN3@antlr3UTF3:
$LN5@antlr3UTF3:

; 1656 : 	}
; 1657 : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
antlr3UTF32Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Index
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF32Index PROC					; COMDAT

; 1604 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1605 :     pANTLR3_INPUT_STREAM input;
; 1606 : 
; 1607 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1608 : 
; 1609 :     return  (ANTLR3_MARKER)(input->nextChar);

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 1610 : }

  00033	48 83 c4 10	 add	 rsp, 16
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
antlr3UTF32Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LABE
_TEXT	SEGMENT
input$ = 0
c$1 = 8
is$ = 32
la$ = 40
antlr3UTF32LABE PROC					; COMDAT

; 1723 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1724 :     pANTLR3_INPUT_STREAM input;
; 1725 : 	
; 1726 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1727 : 
; 1728 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003c	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00045	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00048	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0004c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00050	48 3b c1	 cmp	 rax, rcx
  00053	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1729 :     {
; 1730 : 		return	ANTLR3_CHARSTREAM_EOF;

  00055	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005a	eb 45		 jmp	 SHORT $LN1@antlr3UTF3

; 1731 :     }

  0005c	eb 43		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1732 :     else
; 1733 :     {
; 1734 :         ANTLR3_UCHAR   c;
; 1735 : 
; 1736 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006b	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  0006f	89 44 24 08	 mov	 DWORD PTR c$1[rsp], eax

; 1737 : 
; 1738 :         // Swap Endianess to Little Endian
; 1739 :         //
; 1740 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  00073	8b 44 24 08	 mov	 eax, DWORD PTR c$1[rsp]
  00077	c1 e8 18	 shr	 eax, 24
  0007a	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0007e	c1 e1 08	 shl	 ecx, 8
  00081	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00087	0b c1		 or	 eax, ecx
  00089	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0008d	c1 e9 08	 shr	 ecx, 8
  00090	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00096	0b c1		 or	 eax, ecx
  00098	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0009c	c1 e1 18	 shl	 ecx, 24
  0009f	0b c1		 or	 eax, ecx
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1741 :     }
; 1742 : }

  000a1	48 83 c4 10	 add	 rsp, 16
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
antlr3UTF32LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LALE
_TEXT	SEGMENT
input$ = 0
c$1 = 8
is$ = 32
la$ = 40
antlr3UTF32LALE PROC					; COMDAT

; 1692 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1693 :     pANTLR3_INPUT_STREAM input;
; 1694 : 	
; 1695 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1696 : 
; 1697 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003c	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00045	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00048	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0004c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00050	48 3b c1	 cmp	 rax, rcx
  00053	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1698 :     {
; 1699 : 		return	ANTLR3_CHARSTREAM_EOF;

  00055	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005a	eb 45		 jmp	 SHORT $LN1@antlr3UTF3

; 1700 :     }

  0005c	eb 43		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1701 :     else
; 1702 :     {
; 1703 :         ANTLR3_UCHAR   c;
; 1704 : 
; 1705 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006b	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  0006f	89 44 24 08	 mov	 DWORD PTR c$1[rsp], eax

; 1706 : 
; 1707 :         // Swap Endianess to Big Endian
; 1708 :         //
; 1709 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  00073	8b 44 24 08	 mov	 eax, DWORD PTR c$1[rsp]
  00077	c1 e8 18	 shr	 eax, 24
  0007a	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0007e	c1 e1 08	 shl	 ecx, 8
  00081	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00087	0b c1		 or	 eax, ecx
  00089	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0008d	c1 e9 08	 shr	 ecx, 8
  00090	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00096	0b c1		 or	 eax, ecx
  00098	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0009c	c1 e1 18	 shl	 ecx, 24
  0009f	0b c1		 or	 eax, ecx
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1710 :     }
; 1711 : }

  000a1	48 83 c4 10	 add	 rsp, 16
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
antlr3UTF32LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr3UTF32LA PROC					; COMDAT

; 1668 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1669 :     pANTLR3_INPUT_STREAM input;
; 1670 : 	
; 1671 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1672 : 
; 1673 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003c	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00045	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00048	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0004c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00050	48 3b c1	 cmp	 rax, rcx
  00053	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1674 :     {
; 1675 : 		return	ANTLR3_CHARSTREAM_EOF;

  00055	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005a	eb 13		 jmp	 SHORT $LN1@antlr3UTF3

; 1676 :     }

  0005c	eb 11		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1677 :     else
; 1678 :     {
; 1679 : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006b	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1680 :     }
; 1681 : }

  0006f	48 83 c4 10	 add	 rsp, 16
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
antlr3UTF32LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Consume
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF32Consume PROC					; COMDAT

; 1571 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1572 :     pANTLR3_INPUT_STREAM input;
; 1573 : 
; 1574 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1575 : 
; 1576 :     // SizeBuf is always in bytes
; 1577 :     //
; 1578 :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00036	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00042	73 69		 jae	 SHORT $LN2@antlr3UTF3

; 1579 :     {	
; 1580 : 	/* Indicate one more character in this line
; 1581 : 	 */
; 1582 : 	input->charPositionInLine++;

  00044	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00048	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0004b	ff c0		 inc	 eax
  0004d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00051	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1583 : 	
; 1584 : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar)) == input->newlineChar)

  00054	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00058	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005c	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00060	8b 89 d0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+208]
  00066	39 08		 cmp	 DWORD PTR [rax], ecx
  00068	75 2f		 jne	 SHORT $LN3@antlr3UTF3

; 1585 : 	{
; 1586 : 	    /* Reset for start of a new line of input
; 1587 : 	     */
; 1588 : 	    input->line++;

  0006a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006e	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00071	ff c0		 inc	 eax
  00073	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00077	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1589 : 	    input->charPositionInLine	= 0;

  0007a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0007e	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1590 : 	    input->currentLine		= (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00085	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00089	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008d	48 83 c0 04	 add	 rax, 4
  00091	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00095	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF3:

; 1591 : 	}
; 1592 : 
; 1593 : 	/* Increment to next character position
; 1594 : 	 */
; 1595 : 	input->nextChar = (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00099	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a1	48 83 c0 04	 add	 rax, 4
  000a5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a9	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@antlr3UTF3:

; 1596 :     }
; 1597 : }

  000ad	48 83 c4 10	 add	 rsp, 16
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
antlr3UTF32Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Substr
_TEXT	SEGMENT
tv75 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr3UTF16Substr PROC					; COMDAT

; 1047 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1048 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/2) + 1);

  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  00032	48 2b c8	 sub	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	33 d2		 xor	 edx, edx
  0003a	b9 02 00 00 00	 mov	 ecx, 2
  0003f	f7 f1		 div	 ecx
  00041	ff c0		 inc	 eax
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00048	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0004c	48 89 4c 24 20	 mov	 QWORD PTR tv75[rsp], rcx
  00051	44 8b c0	 mov	 r8d, eax
  00054	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0005e	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR tv75[rsp]
  00067	ff 50 20	 call	 QWORD PTR [rax+32]

; 1049 : }

  0006a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
antlr3UTF16Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Seek
_TEXT	SEGMENT
input$ = 32
is$ = 64
seekPoint$ = 72
antlr3UTF16Seek PROC					; COMDAT

; 1014 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1015 : 	pANTLR3_INPUT_STREAM input;
; 1016 : 
; 1017 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1018 : 
; 1019 : 	// If the requested seek point is less than the current
; 1020 : 	// input point, then we assume that we are resetting from a mark
; 1021 : 	// and do not need to scan, but can just set to there as rewind will
; 1022 :         // reset line numbers and so on.
; 1023 : 	//
; 1024 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0003f	7f 10		 jg	 SHORT $LN4@antlr3UTF1

; 1025 : 	{
; 1026 : 		input->nextChar	= (void *)seekPoint;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  0004b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1027 : 	}

  0004f	eb 36		 jmp	 SHORT $LN5@antlr3UTF1
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1028 : 	else
; 1029 : 	{
; 1030 :             // Call consume until we reach the asked for seek point or EOF
; 1031 :             //
; 1032 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00060	ff 50 30	 call	 QWORD PTR [rax+48]
  00063	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00066	74 1f		 je	 SHORT $LN3@antlr3UTF1
  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0006d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00071	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  00076	7d 0f		 jge	 SHORT $LN3@antlr3UTF1

; 1033 : 	    {
; 1034 : 		is->consume(is);

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00082	ff 50 28	 call	 QWORD PTR [rax+40]

; 1035 : 	    }

  00085	eb ca		 jmp	 SHORT $LN2@antlr3UTF1
$LN3@antlr3UTF1:
$LN5@antlr3UTF1:

; 1036 : 	}
; 1037 : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
antlr3UTF16Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Index
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF16Index PROC					; COMDAT

; 997  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 998  :     pANTLR3_INPUT_STREAM input;
; 999  : 
; 1000 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1001 : 
; 1002 :     return  (ANTLR3_MARKER)(input->nextChar);

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 1003 : }

  00033	48 83 c4 10	 add	 rsp, 16
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
antlr3UTF16Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LABE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv93 = 24
tv94 = 28
is$ = 48
la$ = 56
antlr3UTF16LABE PROC					; COMDAT

; 1359 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1360 : 	pANTLR3_INPUT_STREAM input;
; 1361 :         UTF32           ch;
; 1362 :         UTF32           ch2;
; 1363 :         pANTLR3_UCHAR   nextChar;
; 1364 : 
; 1365 :         // Find the input interface and where we are currently pointing to
; 1366 :         // in the input stream
; 1367 :         //
; 1368 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1369 :         nextChar    = input->nextChar;

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00033	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00037	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1370 : 
; 1371 :         // If a positive offset then advance forward, else retreat
; 1372 :         //
; 1373 :         if  (la >= 0)

  0003c	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00041	0f 8c bf 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1374 :         {
; 1375 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00047	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  0004b	ff c8		 dec	 eax
  0004d	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00051	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00056	0f 8e a5 00 00
	00		 jle	 $LN3@antlr3UTF1
  0005c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00060	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0006b	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00070	0f 83 8b 00 00
	00		 jae	 $LN3@antlr3UTF1

; 1376 :             {
; 1377 :                 // Advance our copy of the input pointer
; 1378 :                 //
; 1379 :                 // Next char in Big Endian byte order
; 1380 :                 //
; 1381 :                 ch  = ((*nextChar) << 8) + *(nextChar+1);

  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0007b	8b 00		 mov	 eax, DWORD PTR [rax]
  0007d	c1 e0 08	 shl	 eax, 8
  00080	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00085	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00088	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1382 :                 nextChar += 2;

  0008c	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00091	48 83 c0 08	 add	 rax, 8
  00095	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1383 : 
; 1384 :                 // If we have a surrogate pair then we need to consume
; 1385 :                 // a following valid LO surrogate.
; 1386 :                 //
; 1387 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  0009a	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000a2	72 58		 jb	 SHORT $LN8@antlr3UTF1
  000a4	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000ac	77 4e		 ja	 SHORT $LN8@antlr3UTF1

; 1388 :                 {
; 1389 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1390 :                     //
; 1391 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000ae	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000b2	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000b5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000b9	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000bd	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000c2	73 38		 jae	 SHORT $LN9@antlr3UTF1

; 1392 :                     {
; 1393 :                         // Next character is in big endian byte order
; 1394 :                         //
; 1395 :                         ch2 = ((*nextChar) << 8) + *(nextChar+1);

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	c1 e0 08	 shl	 eax, 8
  000ce	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  000d3	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  000d6	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1396 : 
; 1397 :                         // If it's a valid low surrogate, consume it
; 1398 :                         //
; 1399 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000da	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000e2	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000e4	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000ec	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 1400 :                         {
; 1401 :                             // We consumed one 16 bit character
; 1402 :                             //
; 1403 : 		            nextChar += 2;

  000ee	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000f3	48 83 c0 08	 add	 rax, 8
  000f7	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 1404 :                         }
; 1405 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1406 :                         // it.
; 1407 :                         //
; 1408 :                     } 
; 1409 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1410 :                     // it because the buffer ended
; 1411 :                     //
; 1412 :                 }
; 1413 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1414 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1415 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1416 :                 //
; 1417 :             }

  000fc	e9 46 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1418 :         }

  00101	e9 ca 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 1419 :         else
; 1420 :         {
; 1421 :             // We need to go backwards from our input point
; 1422 :             //
; 1423 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  00106	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  0010a	89 44 24 18	 mov	 DWORD PTR tv93[rsp], eax
  0010e	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  00112	ff c0		 inc	 eax
  00114	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00118	83 7c 24 18 00	 cmp	 DWORD PTR tv93[rsp], 0
  0011d	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  0011f	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00127	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  00129	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN20@antlr3UTF1:
  00131	83 7c 24 1c 00	 cmp	 DWORD PTR tv94[rsp], 0
  00136	0f 84 94 00 00
	00		 je	 $LN5@antlr3UTF1
  0013c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00149	0f 86 81 00 00
	00		 jbe	 $LN5@antlr3UTF1

; 1424 :             {
; 1425 :                 // Get the previous 16 bit character
; 1426 :                 //
; 1427 :                 ch = ((*nextChar - 2) << 8) + (*nextChar -1);

  0014f	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00154	8b 00		 mov	 eax, DWORD PTR [rax]
  00156	83 e8 02	 sub	 eax, 2
  00159	c1 e0 08	 shl	 eax, 8
  0015c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00161	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00163	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00167	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1428 :                 nextChar -= 2;

  0016b	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00170	48 83 e8 08	 sub	 rax, 8
  00174	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1429 : 
; 1430 :                 // If we found a low surrogate then go back one more character if
; 1431 :                 // the hi surrogate is there
; 1432 :                 //
; 1433 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00179	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  00181	72 48		 jb	 SHORT $LN11@antlr3UTF1
  00183	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  0018b	77 3e		 ja	 SHORT $LN11@antlr3UTF1

; 1434 :                 {
; 1435 :                     ch2 = ((*nextChar - 2) << 8) + (*nextChar -1);

  0018d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00192	8b 00		 mov	 eax, DWORD PTR [rax]
  00194	83 e8 02	 sub	 eax, 2
  00197	c1 e0 08	 shl	 eax, 8
  0019a	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0019f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001a1	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  001a5	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1436 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  001a9	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  001b1	72 18		 jb	 SHORT $LN12@antlr3UTF1
  001b3	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  001bb	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 1437 :                     {
; 1438 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1439 :                         //
; 1440 :                         nextChar -=2;

  001bd	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001c2	48 83 e8 08	 sub	 rax, 8
  001c6	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 1441 :                     }
; 1442 :                 }
; 1443 :             }

  001cb	e9 36 ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 1444 :         }
; 1445 : 
; 1446 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1447 :         //
; 1448 :         // Input buffer size is always in bytes
; 1449 :         //
; 1450 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001d0	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001d4	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001d7	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001db	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001df	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001e4	72 0f		 jb	 SHORT $LN13@antlr3UTF1

; 1451 : 	{
; 1452 : 		return	ANTLR3_CHARSTREAM_EOF;

  001e6	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001eb	e9 9c 00 00 00	 jmp	 $LN1@antlr3UTF1

; 1453 : 	}

  001f0	e9 93 00 00 00	 jmp	 $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 1454 : 	else
; 1455 : 	{
; 1456 :             // Pick up the next 16 character (big endian byte order)
; 1457 :             //
; 1458 :             ch = ((*nextChar) << 8) + *(nextChar+1);

  001f5	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001fa	8b 00		 mov	 eax, DWORD PTR [rax]
  001fc	c1 e0 08	 shl	 eax, 8
  001ff	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00204	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00207	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1459 :             nextChar += 2;

  0020b	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00210	48 83 c0 08	 add	 rax, 8
  00214	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1460 : 
; 1461 :             // If we have a surrogate pair then we need to consume
; 1462 :             // a following valid LO surrogate.
; 1463 :             //
; 1464 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00219	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  00221	72 65		 jb	 SHORT $LN15@antlr3UTF1
  00223	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  0022b	77 5b		 ja	 SHORT $LN15@antlr3UTF1

; 1465 :             {
; 1466 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1467 :                 //
; 1468 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0022d	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00231	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00234	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00238	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0023c	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00241	73 45		 jae	 SHORT $LN16@antlr3UTF1

; 1469 :                 {
; 1470 :                     // Next character is in big endian byte order
; 1471 :                     //
; 1472 :                     ch2 = ((*nextChar) << 8) + *(nextChar+1);

  00243	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00248	8b 00		 mov	 eax, DWORD PTR [rax]
  0024a	c1 e0 08	 shl	 eax, 8
  0024d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00252	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00255	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1473 : 
; 1474 :                     // If it's a valid low surrogate, consume it
; 1475 :                     //
; 1476 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00259	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00261	72 25		 jb	 SHORT $LN17@antlr3UTF1
  00263	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  0026b	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 1477 :                     {
; 1478 :                         // Construct the UTF32 code point
; 1479 :                         //
; 1480 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  0026d	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  00271	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  00276	c1 e0 0a	 shl	 eax, 10
  00279	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  0027d	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  00284	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 1481 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1482 :                     }
; 1483 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1484 :                     // it.
; 1485 :                     //
; 1486 :                 } 
; 1487 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1488 :                 // it because the buffer ended
; 1489 :                 //
; 1490 :             }
; 1491 :         }
; 1492 :         return ch;

  00288	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 1493 : }

  0028c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00290	5f		 pop	 rdi
  00291	c3		 ret	 0
antlr3UTF16LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16ConsumeBE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16ConsumeBE PROC				; COMDAT

; 1280 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1281 : 	pANTLR3_INPUT_STREAM input;
; 1282 :         UTF32   ch;
; 1283 :         UTF32   ch2;
; 1284 : 
; 1285 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1286 : 
; 1287 :         // Buffer size is always in bytes
; 1288 :         //
; 1289 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00036	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00042	0f 83 ff 00 00
	00		 jae	 $LN2@antlr3UTF1

; 1290 : 	{	
; 1291 : 		// Indicate one more character in this line
; 1292 : 		//
; 1293 : 		input->charPositionInLine++;

  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0004f	ff c0		 inc	 eax
  00051	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00055	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1294 : 
; 1295 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00058	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00060	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  0006d	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 1296 : 		{
; 1297 : 			// Reset for start of a new line of input
; 1298 : 			//
; 1299 : 			input->line++;

  0006f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00073	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00076	ff c0		 inc	 eax
  00078	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0007c	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1300 : 			input->charPositionInLine	= 0;

  0007f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00083	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1301 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	48 83 c0 02	 add	 rax, 2
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009a	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 1302 : 		}
; 1303 : 
; 1304 : 		// Increment to next character position, accounting for any surrogates
; 1305 : 		//
; 1306 :                 // Next char in big endian form
; 1307 :                 //
; 1308 :                 ch  = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  0009e	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000a2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000aa	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ae	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b5	c1 e1 08	 shl	 ecx, 8
  000b8	03 c1		 add	 eax, ecx
  000ba	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1309 : 
; 1310 :                 // We consumed one 16 bit character
; 1311 :                 //
; 1312 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000be	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000c2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c6	48 83 c0 02	 add	 rax, 2
  000ca	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ce	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1313 : 
; 1314 :                 // If we have a surrogate pair then we need to consume
; 1315 :                 // a following valid LO surrogate.
; 1316 :                 //
; 1317 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000d2	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000da	72 6b		 jb	 SHORT $LN4@antlr3UTF1
  000dc	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000e4	77 61		 ja	 SHORT $LN4@antlr3UTF1

; 1318 : 
; 1319 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1320 :                     //
; 1321 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ea	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000ed	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000f1	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000f5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000f9	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000fd	73 48		 jae	 SHORT $LN5@antlr3UTF1

; 1322 :                     {
; 1323 :                         // Big endian
; 1324 :                         //
; 1325 :                         ch2 = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  000ff	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00103	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00107	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0010b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0010f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00113	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00116	c1 e1 08	 shl	 ecx, 8
  00119	03 c1		 add	 eax, ecx
  0011b	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1326 : 
; 1327 :                         // If it's a valid low surrogate, consume it
; 1328 :                         //
; 1329 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0011f	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00127	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  00129	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00131	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 1330 :                         {
; 1331 :                             // We consumed one 16 bit character
; 1332 :                             //
; 1333 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00133	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00137	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013b	48 83 c0 02	 add	 rax, 2
  0013f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00143	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1334 :                         }
; 1335 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1336 :                         // it.
; 1337 :                         //
; 1338 :                     } 
; 1339 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1340 :                     // it because the buffer ended
; 1341 :                     //
; 1342 :                 } 
; 1343 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1344 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1345 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1346 :                 //
; 1347 : 	}
; 1348 : }

  00147	48 83 c4 10	 add	 rsp, 16
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
antlr3UTF16ConsumeBE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LALE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv93 = 24
tv94 = 28
is$ = 48
la$ = 56
antlr3UTF16LALE PROC					; COMDAT

; 1138 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1139 : 	pANTLR3_INPUT_STREAM input;
; 1140 :         UTF32           ch;
; 1141 :         UTF32           ch2;
; 1142 :         pANTLR3_UCHAR   nextChar;
; 1143 : 
; 1144 :         // Find the input interface and where we are currently pointing to
; 1145 :         // in the input stream
; 1146 :         //
; 1147 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1148 :         nextChar    = input->nextChar;

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00033	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00037	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1149 : 
; 1150 :         // If a positive offset then advance forward, else retreat
; 1151 :         //
; 1152 :         if  (la >= 0)

  0003c	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00041	0f 8c bf 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1153 :         {
; 1154 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00047	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  0004b	ff c8		 dec	 eax
  0004d	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00051	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00056	0f 8e a5 00 00
	00		 jle	 $LN3@antlr3UTF1
  0005c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00060	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0006b	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00070	0f 83 8b 00 00
	00		 jae	 $LN3@antlr3UTF1

; 1155 :             {
; 1156 :                 // Advance our copy of the input pointer
; 1157 :                 //
; 1158 :                 // Next char in Little Endian byte order
; 1159 :                 //
; 1160 :                 ch  = (*nextChar) + (*(nextChar+1) << 8);

  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0007b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007e	c1 e0 08	 shl	 eax, 8
  00081	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00086	03 01		 add	 eax, DWORD PTR [rcx]
  00088	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1161 :                 nextChar += 2;

  0008c	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00091	48 83 c0 08	 add	 rax, 8
  00095	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1162 : 
; 1163 :                 // If we have a surrogate pair then we need to consume
; 1164 :                 // a following valid LO surrogate.
; 1165 :                 //
; 1166 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  0009a	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000a2	72 58		 jb	 SHORT $LN8@antlr3UTF1
  000a4	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000ac	77 4e		 ja	 SHORT $LN8@antlr3UTF1

; 1167 :                 {
; 1168 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1169 :                     //
; 1170 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000ae	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000b2	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000b5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000b9	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000bd	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000c2	73 38		 jae	 SHORT $LN9@antlr3UTF1

; 1171 :                     {
; 1172 :                         // Next character is in little endian byte order
; 1173 :                         //
; 1174 :                         ch2 = (*nextChar) + (*(nextChar+1) << 8);

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000cc	c1 e0 08	 shl	 eax, 8
  000cf	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  000d4	03 01		 add	 eax, DWORD PTR [rcx]
  000d6	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1175 : 
; 1176 :                         // If it's a valid low surrogate, consume it
; 1177 :                         //
; 1178 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000da	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000e2	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000e4	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000ec	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 1179 :                         {
; 1180 :                             // We consumed one 16 bit character
; 1181 :                             //
; 1182 : 		            nextChar += 2;

  000ee	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000f3	48 83 c0 08	 add	 rax, 8
  000f7	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 1183 :                         }
; 1184 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1185 :                         // it.
; 1186 :                         //
; 1187 :                     } 
; 1188 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1189 :                     // it because the buffer ended
; 1190 :                     //
; 1191 :                 }
; 1192 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1193 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1194 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1195 :                 //
; 1196 :             }

  000fc	e9 46 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1197 :         }

  00101	e9 c4 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 1198 :         else
; 1199 :         {
; 1200 :             // We need to go backwards from our input point
; 1201 :             //
; 1202 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  00106	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  0010a	89 44 24 18	 mov	 DWORD PTR tv93[rsp], eax
  0010e	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  00112	ff c0		 inc	 eax
  00114	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00118	83 7c 24 18 00	 cmp	 DWORD PTR tv93[rsp], 0
  0011d	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  0011f	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00127	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  00129	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN20@antlr3UTF1:
  00131	83 7c 24 1c 00	 cmp	 DWORD PTR tv94[rsp], 0
  00136	0f 84 8e 00 00
	00		 je	 $LN5@antlr3UTF1
  0013c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00149	76 7f		 jbe	 SHORT $LN5@antlr3UTF1

; 1203 :             {
; 1204 :                 // Get the previous 16 bit character
; 1205 :                 //
; 1206 :                 ch = (*nextChar - 2) + ((*nextChar -1) << 8);

  0014b	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00150	8b 00		 mov	 eax, DWORD PTR [rax]
  00152	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00157	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00159	ff c9		 dec	 ecx
  0015b	c1 e1 08	 shl	 ecx, 8
  0015e	8d 44 08 fe	 lea	 eax, DWORD PTR [rax+rcx-2]
  00162	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1207 :                 nextChar -= 2;

  00166	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0016b	48 83 e8 08	 sub	 rax, 8
  0016f	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1208 : 
; 1209 :                 // If we found a low surrogate then go back one more character if
; 1210 :                 // the hi surrogate is there
; 1211 :                 //
; 1212 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00174	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  0017c	72 47		 jb	 SHORT $LN11@antlr3UTF1
  0017e	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  00186	77 3d		 ja	 SHORT $LN11@antlr3UTF1

; 1213 :                 {
; 1214 :                     ch2 = (*nextChar - 2) + ((*nextChar -1) << 8);

  00188	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0018d	8b 00		 mov	 eax, DWORD PTR [rax]
  0018f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00194	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00196	ff c9		 dec	 ecx
  00198	c1 e1 08	 shl	 ecx, 8
  0019b	8d 44 08 fe	 lea	 eax, DWORD PTR [rax+rcx-2]
  0019f	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1215 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  001a3	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  001ab	72 18		 jb	 SHORT $LN12@antlr3UTF1
  001ad	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  001b5	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 1216 :                     {
; 1217 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1218 :                         //
; 1219 :                         nextChar -=2;

  001b7	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001bc	48 83 e8 08	 sub	 rax, 8
  001c0	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 1220 :                     }
; 1221 :                 }
; 1222 :             }

  001c5	e9 3c ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 1223 :         }
; 1224 : 
; 1225 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1226 :         //
; 1227 :         // Input buffer size is always in bytes
; 1228 :         //
; 1229 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001ca	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001ce	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001d1	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001d5	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001d9	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001de	72 0f		 jb	 SHORT $LN13@antlr3UTF1

; 1230 : 	{
; 1231 : 		return	ANTLR3_CHARSTREAM_EOF;

  001e0	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001e5	e9 9c 00 00 00	 jmp	 $LN1@antlr3UTF1

; 1232 : 	}

  001ea	e9 93 00 00 00	 jmp	 $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 1233 : 	else
; 1234 : 	{
; 1235 :             // Pick up the next 16 character (little endian byte order)
; 1236 :             //
; 1237 :             ch = (*nextChar) + (*(nextChar+1) << 8);

  001ef	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001f4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001f7	c1 e0 08	 shl	 eax, 8
  001fa	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  001ff	03 01		 add	 eax, DWORD PTR [rcx]
  00201	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1238 :             nextChar += 2;

  00205	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0020a	48 83 c0 08	 add	 rax, 8
  0020e	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1239 : 
; 1240 :             // If we have a surrogate pair then we need to consume
; 1241 :             // a following valid LO surrogate.
; 1242 :             //
; 1243 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00213	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  0021b	72 65		 jb	 SHORT $LN15@antlr3UTF1
  0021d	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00225	77 5b		 ja	 SHORT $LN15@antlr3UTF1

; 1244 :             {
; 1245 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1246 :                 //
; 1247 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00227	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0022b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0022e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00232	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00236	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0023b	73 45		 jae	 SHORT $LN16@antlr3UTF1

; 1248 :                 {
; 1249 :                     // Next character is in little endian byte order
; 1250 :                     //
; 1251 :                     ch2 = (*nextChar) + (*(nextChar+1) << 8);

  0023d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00242	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00245	c1 e0 08	 shl	 eax, 8
  00248	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0024d	03 01		 add	 eax, DWORD PTR [rcx]
  0024f	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1252 : 
; 1253 :                     // If it's a valid low surrogate, consume it
; 1254 :                     //
; 1255 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00253	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  0025b	72 25		 jb	 SHORT $LN17@antlr3UTF1
  0025d	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00265	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 1256 :                     {
; 1257 :                         // Construct the UTF32 code point
; 1258 :                         //
; 1259 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00267	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  0026b	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  00270	c1 e0 0a	 shl	 eax, 10
  00273	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  00277	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  0027e	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 1260 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1261 :                     }
; 1262 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1263 :                     // it.
; 1264 :                     //
; 1265 :                 } 
; 1266 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1267 :                 // it because the buffer ended
; 1268 :                 //
; 1269 :             }
; 1270 :         }
; 1271 :         return ch;

  00282	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 1272 : }

  00286	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028a	5f		 pop	 rdi
  0028b	c3		 ret	 0
antlr3UTF16LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16ConsumeLE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16ConsumeLE PROC				; COMDAT

; 1061 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1062 : 	pANTLR3_INPUT_STREAM input;
; 1063 :         UTF32   ch;
; 1064 :         UTF32   ch2;
; 1065 : 
; 1066 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1067 : 
; 1068 :         // Buffer size is always in bytes
; 1069 :         //
; 1070 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00036	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00042	0f 83 ff 00 00
	00		 jae	 $LN2@antlr3UTF1

; 1071 : 	{	
; 1072 : 		// Indicate one more character in this line
; 1073 : 		//
; 1074 : 		input->charPositionInLine++;

  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0004f	ff c0		 inc	 eax
  00051	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00055	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1075 : 
; 1076 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00058	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00060	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  0006d	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 1077 : 		{
; 1078 : 			// Reset for start of a new line of input
; 1079 : 			//
; 1080 : 			input->line++;

  0006f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00073	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00076	ff c0		 inc	 eax
  00078	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0007c	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1081 : 			input->charPositionInLine	= 0;

  0007f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00083	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1082 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	48 83 c0 02	 add	 rax, 2
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009a	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 1083 : 		}
; 1084 : 
; 1085 : 		// Increment to next character position, accounting for any surrogates
; 1086 : 		//
; 1087 :                 // Next char in litle endian form
; 1088 :                 //
; 1089 :                 ch  = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  0009e	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000a2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a9	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ad	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b1	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000b5	c1 e1 08	 shl	 ecx, 8
  000b8	03 c1		 add	 eax, ecx
  000ba	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1090 : 
; 1091 :                 // We consumed one 16 bit character
; 1092 :                 //
; 1093 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000be	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000c2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c6	48 83 c0 02	 add	 rax, 2
  000ca	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ce	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1094 : 
; 1095 :                 // If we have a surrogate pair then we need to consume
; 1096 :                 // a following valid LO surrogate.
; 1097 :                 //
; 1098 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000d2	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000da	72 6b		 jb	 SHORT $LN4@antlr3UTF1
  000dc	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000e4	77 61		 ja	 SHORT $LN4@antlr3UTF1

; 1099 : 
; 1100 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1101 :                     //
; 1102 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ea	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000ed	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000f1	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000f5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000f9	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000fd	73 48		 jae	 SHORT $LN5@antlr3UTF1

; 1103 :                     {
; 1104 :                         ch2 = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  000ff	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00103	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00107	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0010a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0010e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00112	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00116	c1 e1 08	 shl	 ecx, 8
  00119	03 c1		 add	 eax, ecx
  0011b	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1105 : 
; 1106 :                         // If it's a valid low surrogate, consume it
; 1107 :                         //
; 1108 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0011f	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00127	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  00129	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00131	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 1109 :                         {
; 1110 :                             // We consumed one 16 bit character
; 1111 :                             //
; 1112 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00133	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00137	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013b	48 83 c0 02	 add	 rax, 2
  0013f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00143	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1113 :                         }
; 1114 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1115 :                         // it.
; 1116 :                         //
; 1117 :                     } 
; 1118 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1119 :                     // it because the buffer ended
; 1120 :                     //
; 1121 :                 } 
; 1122 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1123 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1124 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1125 :                 //
; 1126 : 	}
; 1127 : }

  00147	48 83 c4 10	 add	 rsp, 16
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
antlr3UTF16ConsumeLE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LA
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv89 = 24
tv90 = 28
is$ = 48
la$ = 56
antlr3UTF16LA PROC					; COMDAT

; 858  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 859  : 	pANTLR3_INPUT_STREAM input;
; 860  :         UTF32   ch;
; 861  :         UTF32   ch2;
; 862  :         UTF16   * nextChar;
; 863  : 
; 864  :         // Find the input interface and where we are currently pointing to
; 865  :         // in the input stream
; 866  :         //
; 867  : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 868  :         nextChar    = input->nextChar;

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00033	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00037	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 869  : 
; 870  :         // If a positive offset then advance forward, else retreat
; 871  :         //
; 872  :         if  (la >= 0)

  0003c	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00041	0f 8c a7 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 873  :         {
; 874  :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00047	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  0004b	ff c8		 dec	 eax
  0004d	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00051	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00056	0f 8e 8d 00 00
	00		 jle	 $LN3@antlr3UTF1
  0005c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00060	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0006b	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00070	73 77		 jae	 SHORT $LN3@antlr3UTF1

; 875  :             {
; 876  :                 // Advance our copy of the input pointer
; 877  :                 //
; 878  :                 // Next char in natural machine byte order
; 879  :                 //
; 880  :                 ch  = *nextChar++;

  00072	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00077	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0007a	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
  0007e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00083	48 83 c0 02	 add	 rax, 2
  00087	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 881  : 
; 882  :                 // If we have a surrogate pair then we need to consume
; 883  :                 // a following valid LO surrogate.
; 884  :                 //
; 885  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  0008c	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  00094	72 4e		 jb	 SHORT $LN8@antlr3UTF1
  00096	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  0009e	77 44		 ja	 SHORT $LN8@antlr3UTF1

; 886  :                 {
; 887  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 888  :                     //
; 889  :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000a0	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000a4	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000a7	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ab	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000af	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000b4	73 2e		 jae	 SHORT $LN9@antlr3UTF1

; 890  :                     {
; 891  :                         // Next character is in natural machine byte order
; 892  :                         //
; 893  :                         ch2 = *nextChar;

  000b6	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000bb	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000be	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 894  : 
; 895  :                         // If it's a valid low surrogate, consume it
; 896  :                         //
; 897  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000c2	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000ca	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000cc	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000d4	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 898  :                         {
; 899  :                             // We consumed one 16 bit character
; 900  :                             //
; 901  : 		            nextChar++;

  000d6	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000db	48 83 c0 02	 add	 rax, 2
  000df	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 902  :                         }
; 903  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 904  :                         // it.
; 905  :                         //
; 906  :                     } 
; 907  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 908  :                     // it because the buffer ended
; 909  :                     //
; 910  :                 }
; 911  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 912  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 913  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 914  :                 //
; 915  :             }

  000e4	e9 5e ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 916  :         }

  000e9	e9 a3 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 917  :         else
; 918  :         {
; 919  :             // We need to go backwards from our input point
; 920  :             //
; 921  :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000ee	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000f2	89 44 24 18	 mov	 DWORD PTR tv89[rsp], eax
  000f6	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000fa	ff c0		 inc	 eax
  000fc	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00100	83 7c 24 18 00	 cmp	 DWORD PTR tv89[rsp], 0
  00105	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  00107	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  0010f	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  00111	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN20@antlr3UTF1:
  00119	83 7c 24 1c 00	 cmp	 DWORD PTR tv90[rsp], 0
  0011e	74 71		 je	 SHORT $LN5@antlr3UTF1
  00120	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00124	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00128	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0012d	76 62		 jbe	 SHORT $LN5@antlr3UTF1

; 922  :             {
; 923  :                 // Get the previous 16 bit character
; 924  :                 //
; 925  :                 ch = *--nextChar;

  0012f	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00134	48 83 e8 02	 sub	 rax, 2
  00138	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0013d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00142	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00145	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 926  : 
; 927  :                 // If we found a low surrogate then go back one more character if
; 928  :                 // the hi surrogate is there
; 929  :                 //
; 930  :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00149	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  00151	72 39		 jb	 SHORT $LN11@antlr3UTF1
  00153	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  0015b	77 2f		 ja	 SHORT $LN11@antlr3UTF1

; 931  :                 {
; 932  :                     ch2 = *(nextChar-1);

  0015d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00162	0f b7 40 fe	 movzx	 eax, WORD PTR [rax-2]
  00166	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 933  :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  0016a	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  00172	72 18		 jb	 SHORT $LN12@antlr3UTF1
  00174	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  0017c	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 934  :                     {
; 935  :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 936  :                         //
; 937  :                         nextChar--;

  0017e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00183	48 83 e8 02	 sub	 rax, 2
  00187	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 938  :                     }
; 939  :                 }
; 940  :             }

  0018c	e9 5d ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 941  :         }
; 942  : 
; 943  :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 944  :         //
; 945  :         // Input buffer size is always in bytes
; 946  :         //
; 947  : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00191	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00195	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00198	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0019c	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001a0	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001a5	72 0c		 jb	 SHORT $LN13@antlr3UTF1

; 948  : 	{
; 949  : 		return	ANTLR3_CHARSTREAM_EOF;

  001a7	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001ac	e9 85 00 00 00	 jmp	 $LN1@antlr3UTF1

; 950  : 	}

  001b1	eb 7f		 jmp	 SHORT $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 951  : 	else
; 952  : 	{
; 953  :             // Pick up the next 16 character (native machine byte order)
; 954  :             //
; 955  :             ch = *nextChar++;

  001b3	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001b8	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001bb	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
  001bf	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001c4	48 83 c0 02	 add	 rax, 2
  001c8	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 956  : 
; 957  :             // If we have a surrogate pair then we need to consume
; 958  :             // a following valid LO surrogate.
; 959  :             //
; 960  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  001cd	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  001d5	72 5b		 jb	 SHORT $LN15@antlr3UTF1
  001d7	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  001df	77 51		 ja	 SHORT $LN15@antlr3UTF1

; 961  :             {
; 962  :                 // If the 16 bits following the high surrogate are in the source buffer...
; 963  :                 //
; 964  :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001e1	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001e5	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001e8	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001ec	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001f0	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001f5	73 3b		 jae	 SHORT $LN16@antlr3UTF1

; 965  :                 {
; 966  :                     // Next character is in natural machine byte order
; 967  :                     //
; 968  :                     ch2 = *nextChar;

  001f7	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001fc	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001ff	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 969  : 
; 970  :                     // If it's a valid low surrogate, consume it
; 971  :                     //
; 972  :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00203	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  0020b	72 25		 jb	 SHORT $LN17@antlr3UTF1
  0020d	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00215	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 973  :                     {
; 974  :                         // Construct the UTF32 code point
; 975  :                         //
; 976  :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00217	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  0021b	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  00220	c1 e0 0a	 shl	 eax, 10
  00223	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  00227	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  0022e	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 977  : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 978  :                     }
; 979  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 980  :                     // it.
; 981  :                     //
; 982  :                 } 
; 983  :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 984  :                 // it because the buffer ended
; 985  :                 //
; 986  :             }
; 987  :         }
; 988  :         return ch;

  00232	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 989  : }

  00236	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0023a	5f		 pop	 rdi
  0023b	c3		 ret	 0
antlr3UTF16LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Consume
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16Consume PROC					; COMDAT

; 779  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 780  : 	pANTLR3_INPUT_STREAM input;
; 781  :         UTF32   ch;
; 782  :         UTF32   ch2;
; 783  : 
; 784  : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 785  : 
; 786  :         // Buffer size is always in bytes
; 787  :         //
; 788  : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00036	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00042	0f 83 dd 00 00
	00		 jae	 $LN2@antlr3UTF1

; 789  : 	{	
; 790  : 		// Indicate one more character in this line
; 791  : 		//
; 792  : 		input->charPositionInLine++;

  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0004f	ff c0		 inc	 eax
  00051	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00055	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 793  : 
; 794  : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00058	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00060	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  0006d	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 795  : 		{
; 796  : 			// Reset for start of a new line of input
; 797  : 			//
; 798  : 			input->line++;

  0006f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00073	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00076	ff c0		 inc	 eax
  00078	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0007c	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 799  : 			input->charPositionInLine	= 0;

  0007f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00083	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 800  : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	48 83 c0 02	 add	 rax, 2
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009a	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 801  : 		}
; 802  : 
; 803  : 		// Increment to next character position, accounting for any surrogates
; 804  : 		//
; 805  :                 // Next char in natural machine byte order
; 806  :                 //
; 807  :                 ch  = *((UTF16*)input->nextChar);

  0009e	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000a2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a9	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 808  : 
; 809  :                 // We consumed one 16 bit character
; 810  :                 //
; 811  : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000ad	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000b1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b5	48 83 c0 02	 add	 rax, 2
  000b9	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000bd	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 812  : 
; 813  :                 // If we have a surrogate pair then we need to consume
; 814  :                 // a following valid LO surrogate.
; 815  :                 //
; 816  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000c1	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000c9	72 5a		 jb	 SHORT $LN4@antlr3UTF1
  000cb	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000d3	77 50		 ja	 SHORT $LN4@antlr3UTF1

; 817  : 
; 818  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 819  :                     //
; 820  :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000d5	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000d9	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000dc	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000e0	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000e4	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000e8	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000ec	73 37		 jae	 SHORT $LN5@antlr3UTF1

; 821  :                     {
; 822  :                         // Next character is in natural machine byte order
; 823  :                         //
; 824  :                         ch2 = *((UTF16*)input->nextChar);

  000ee	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000f2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000f9	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 825  : 
; 826  :                         // If it's a valid low surrogate, consume it
; 827  :                         //
; 828  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000fd	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00105	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  00107	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  0010f	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 829  :                         {
; 830  :                             // We consumed one 16 bit character
; 831  :                             //
; 832  : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00111	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00115	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00119	48 83 c0 02	 add	 rax, 2
  0011d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00121	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 833  :                         }
; 834  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 835  :                         // it.
; 836  :                         //
; 837  :                     } 
; 838  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 839  :                     // it because the buffer ended
; 840  :                     //
; 841  :                 } 
; 842  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 843  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 844  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 845  :                 //
; 846  : 	}
; 847  : }

  00125	48 83 c4 10	 add	 rsp, 16
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
antlr3UTF16Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSetUcaseLA
_TEXT	SEGMENT
input$ = 16
flag$ = 24
antlr38BitSetUcaseLA PROC				; COMDAT

; 240  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 241  : 	if	(flag)

  0000a	0f b6 44 24 18	 movzx	 eax, BYTE PTR flag$[rsp]
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN2@antlr38Bit

; 242  : 	{
; 243  : 		// Return the upper case version of the characters
; 244  : 		//
; 245  : 		input->istream->_LA		    =  antlr38BitLA_ucase;

  00013	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA_ucase
  00022	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 246  : 	}

  00026	eb 13		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 247  : 	else
; 248  : 	{
; 249  : 		// Return the raw characters as they are in the buffer
; 250  : 		//
; 251  : 		input->istream->_LA		    =  antlr38BitLA;

  00028	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA
  00037	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN3@antlr38Bit:

; 252  : 	}
; 253  : }

  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
antlr38BitSetUcaseLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSetNewLineChar
_TEXT	SEGMENT
input$ = 16
newlineChar$ = 24
antlr38BitSetNewLineChar PROC				; COMDAT

; 686  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 687  :     input->newlineChar	= newlineChar;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR newlineChar$[rsp]
  00013	89 88 d0 00 00
	00		 mov	 DWORD PTR [rax+208], ecx

; 688  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
antlr38BitSetNewLineChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSetCharPosition
_TEXT	SEGMENT
input$ = 16
position$ = 24
antlr38BitSetCharPosition PROC				; COMDAT

; 670  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 671  :     input->charPositionInLine = position;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR position$[rsp]
  00013	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 672  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
antlr38BitSetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSetLine
_TEXT	SEGMENT
input$ = 16
line$ = 24
antlr38BitSetLine PROC					; COMDAT

; 655  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 656  :     input->line	= line;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR line$[rsp]
  00013	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 657  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
antlr38BitSetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitGetCharPosition
_TEXT	SEGMENT
input$ = 16
antlr38BitGetCharPosition PROC				; COMDAT

; 638  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 639  :     return  input->charPositionInLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 40	 mov	 eax, DWORD PTR [rax+64]

; 640  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitGetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitGetLineBuf
_TEXT	SEGMENT
input$ = 16
antlr38BitGetLineBuf PROC				; COMDAT

; 627  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 628  :     return  input->currentLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]

; 629  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr38BitGetLineBuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitGetLine
_TEXT	SEGMENT
input$ = 16
antlr38BitGetLine PROC					; COMDAT

; 615  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 616  :     return  input->line;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]

; 617  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitGetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSubstr
_TEXT	SEGMENT
tv74 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr38BitSubstr PROC					; COMDAT

; 604  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 605  : 	return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, (ANTLR3_UINT32)(stop - start + 1));

  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  00032	48 2b c8	 sub	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 ff c0	 inc	 rax
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00040	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00044	48 89 4c 24 20	 mov	 QWORD PTR tv74[rsp], rcx
  00049	44 8b c0	 mov	 r8d, eax
  0004c	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00056	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR tv74[rsp]
  0005f	ff 50 20	 call	 QWORD PTR [rax+32]

; 606  : }

  00062	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
antlr38BitSubstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSize
_TEXT	SEGMENT
input$ = 16
antlr38BitSize PROC					; COMDAT

; 434  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 435  :     return  input->sizeBuf;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]

; 436  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitLT
_TEXT	SEGMENT
input$ = 48
lt$ = 56
antlr38BitLT PROC					; COMDAT

; 403  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 404  :     /* Casting is horrible but it means no warnings and LT should never be called
; 405  :      * on a character stream anyway I think. If it is then, the void * will need to be 
; 406  :      * cast back in a similar manner. Yuck! But this means that LT for Token streams and
; 407  :      * tree streams is correct.
; 408  :      */
; 409  :     return (ANTLR3_FUNC_PTR(input->istream->_LA(input->istream, lt)));

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	8b 54 24 38	 mov	 edx, DWORD PTR lt$[rsp]
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	ff 50 30	 call	 QWORD PTR [rax+48]
  00039	8b c0		 mov	 eax, eax

; 410  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
antlr38BitLT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitReuse
_TEXT	SEGMENT
tv76 = 32
tv88 = 40
tv94 = 48
input$ = 80
inString$ = 88
size$ = 96
name$ = 104
antlr38BitReuse PROC					; COMDAT

; 289  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 290  :     input->isAllocated	= ANTLR3_FALSE;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00032	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 291  :     input->data		= inString;

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inString$[rsp]
  00043	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 292  :     input->sizeBuf	= size;

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  00050	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 293  :     
; 294  :     // Now we can set up the file name. As we are reusing the stream, there may already
; 295  :     // be a string that we can reuse for holding the filename.
; 296  :     //
; 297  : 	if	(input->istream->streamName == NULL) 

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00060	75 5d		 jne	 SHORT $LN2@antlr38Bit

; 298  : 	{
; 299  : 		input->istream->streamName	= input->strFactory->newStr(input->strFactory, name == NULL ? (pANTLR3_UINT8)"-memory-" : name);

  00062	48 83 7c 24 68
	00		 cmp	 QWORD PTR name$[rsp], 0
  00068	75 0e		 jne	 SHORT $LN5@antlr38Bit
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08ONBMMFLC@?9memory?9?$AA@
  00071	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00076	eb 0a		 jmp	 SHORT $LN6@antlr38Bit
$LN5@antlr38Bit:
  00078	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  0007d	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
$LN6@antlr38Bit:
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00087	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008b	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv76[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  00095	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00099	ff 50 30	 call	 QWORD PTR [rax+48]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000a1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a4	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 300  : 		input->fileName		= input->istream->streamName;

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000b5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b9	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 301  : 	}

  000bd	eb 4a		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 302  : 	else
; 303  : 	{
; 304  : 		input->istream->streamName->set(input->istream->streamName,  (name == NULL ? (const char *)"-memory-" : (const char *)name));

  000bf	48 83 7c 24 68
	00		 cmp	 QWORD PTR name$[rsp], 0
  000c5	75 0e		 jne	 SHORT $LN7@antlr38Bit
  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08ONBMMFLC@?9memory?9?$AA@
  000ce	48 89 44 24 28	 mov	 QWORD PTR tv88[rsp], rax
  000d3	eb 0a		 jmp	 SHORT $LN8@antlr38Bit
$LN7@antlr38Bit:
  000d5	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  000da	48 89 44 24 28	 mov	 QWORD PTR tv88[rsp], rax
$LN8@antlr38Bit:
  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  000e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ef	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f3	48 89 4c 24 30	 mov	 QWORD PTR tv94[rsp], rcx
  000f8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv88[rsp]
  000fd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  00106	ff 50 20	 call	 QWORD PTR [rax+32]
$LN3@antlr38Bit:

; 305  : 	}
; 306  : 
; 307  :     input->reset(input);

  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00113	ff 50 70	 call	 QWORD PTR [rax+112]

; 308  : }

  00116	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
antlr38BitReuse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3InputReset
_TEXT	SEGMENT
input$ = 48
antlr3InputReset PROC					; COMDAT

; 262  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 263  : 
; 264  :     input->nextChar		= input->data;	/* Input at first character */

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00028	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002c	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 265  :     input->line			= 1;		/* starts at line 1	    */

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00035	c7 40 34 01 00
	00 00		 mov	 DWORD PTR [rax+52], 1

; 266  :     input->charPositionInLine	= -1;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00041	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 267  :     input->currentLine		= input->data;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00052	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00056	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 268  :     input->markDepth		= 0;		/* Reset markers	    */

  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0005f	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 269  :     
; 270  :     /* Clear out up the markers table if it is there
; 271  :      */
; 272  :     if	(input->markers != NULL)

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0006b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00070	74 1a		 je	 SHORT $LN2@antlr3Inpu

; 273  :     {
; 274  :         input->markers->clear(input->markers);

  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00077	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00080	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00084	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 275  :     }

  0008a	eb 10		 jmp	 SHORT $LN3@antlr3Inpu
$LN2@antlr3Inpu:

; 276  :     else
; 277  :     {
; 278  :         /* Install a new markers table
; 279  :          */
; 280  :         input->markers  = antlr3VectorNew(0);

  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 antlr3VectorNew
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00098	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN3@antlr3Inpu:

; 281  :     }
; 282  : }

  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
antlr3InputReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3InputClose
_TEXT	SEGMENT
input$ = 48
antlr3InputClose PROC					; COMDAT

; 204  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 205  :     // Close any markers in the input stream
; 206  :     //
; 207  :     if	(input->markers != NULL)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00023	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00028	74 25		 je	 SHORT $LN2@antlr3Inpu

; 208  :     {
; 209  : 		input->markers->free(input->markers);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0003c	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 210  : 		input->markers = NULL;

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00047	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN2@antlr3Inpu:

; 211  :     }
; 212  : 
; 213  :     // Close the string factory
; 214  :     //
; 215  :     if	(input->strFactory != NULL)

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00054	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00059	74 15		 je	 SHORT $LN3@antlr3Inpu

; 216  :     {
; 217  : 		input->strFactory->close(input->strFactory);

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00060	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00069	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006d	ff 50 50	 call	 QWORD PTR [rax+80]
$LN3@antlr3Inpu:

; 218  :     }
; 219  : 
; 220  :     // Free the input stream buffer if we allocated it
; 221  :     //
; 222  :     if	(input->isAllocated && input->data != NULL)

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00075	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00079	74 28		 je	 SHORT $LN4@antlr3Inpu
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00080	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00085	74 1c		 je	 SHORT $LN4@antlr3Inpu

; 223  :     {
; 224  : 		ANTLR3_FREE(input->data);

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0008c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 225  : 		input->data = NULL;

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0009b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN4@antlr3Inpu:

; 226  :     }
; 227  :     
; 228  :     input->istream->free(input->istream);

  000a3	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000b0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b3	ff 50 78	 call	 QWORD PTR [rax+120]

; 229  : 
; 230  :     // Finally, free the space for the structure itself
; 231  :     //
; 232  :     ANTLR3_FREE(input);

  000b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 233  : 
; 234  :     // Done
; 235  :     //
; 236  : }

  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
antlr3InputClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitGetSourceName
_TEXT	SEGMENT
is$ = 16
antlr38BitGetSourceName PROC				; COMDAT

; 194  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 195  : 	return	is->streamName;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR is$[rsp]
  0000b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 196  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr38BitGetSourceName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSeek
_TEXT	SEGMENT
count$ = 32
input$ = 40
tv72 = 48
is$ = 80
seekPoint$ = 88
antlr38BitSeek PROC					; COMDAT

; 571  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 572  : 	ANTLR3_INT32   count;
; 573  : 	pANTLR3_INPUT_STREAM input;
; 574  : 
; 575  : 	input   = ANTLR3_FUNC_PTR(((pANTLR3_INPUT_STREAM) is->super));

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 576  : 
; 577  : 	/* If the requested seek point is less than the current
; 578  : 	* input point, then we assume that we are resetting from a mark
; 579  : 	* and do not need to scan, but can just set to there.
; 580  : 	*/
; 581  : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 39 44 24 58	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0003f	7f 10		 jg	 SHORT $LN4@antlr38Bit

; 582  : 	{
; 583  : 		input->nextChar	= ((pANTLR3_UINT8) seekPoint);

  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00046	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  0004b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 584  : 	}

  0004f	eb 40		 jmp	 SHORT $LN5@antlr38Bit
$LN4@antlr38Bit:

; 585  : 	else
; 586  : 	{
; 587  : 		count	= (ANTLR3_UINT32)(seekPoint - (ANTLR3_MARKER)(input->nextChar));

  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00056	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  0005f	48 2b c8	 sub	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
$LN2@antlr38Bit:

; 588  : 
; 589  : 		while (count--)

  00069	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  0006d	89 44 24 30	 mov	 DWORD PTR tv72[rsp], eax
  00071	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  00075	ff c8		 dec	 eax
  00077	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
  0007b	83 7c 24 30 00	 cmp	 DWORD PTR tv72[rsp], 0
  00080	74 0f		 je	 SHORT $LN3@antlr38Bit

; 590  : 		{
; 591  : 			is->consume(is);

  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  0008c	ff 50 28	 call	 QWORD PTR [rax+40]

; 592  : 		}

  0008f	eb d8		 jmp	 SHORT $LN2@antlr38Bit
$LN3@antlr38Bit:
$LN5@antlr38Bit:

; 593  : 	}
; 594  : }

  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
antlr38BitSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitRelease
_TEXT	SEGMENT
input$ = 0
is$ = 32
mark$ = 40
antlr38BitRelease PROC					; COMDAT

; 551  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 552  :     pANTLR3_INPUT_STREAM input;
; 553  : 
; 554  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 555  : 
; 556  :     /* We don't do much here in fact as we never free any higher marks in
; 557  :      * the hashtable as we just resuse any memory allocated for them.
; 558  :      */
; 559  :     input->markDepth	= (ANTLR3_UINT32)(mark - 1);

  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR mark$[rsp]
  00035	48 ff c8	 dec	 rax
  00038	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003c	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 560  : }

  0003f	48 83 c4 10	 add	 rsp, 16
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
antlr38BitRelease ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitRewindLast
_TEXT	SEGMENT
is$ = 48
antlr38BitRewindLast PROC				; COMDAT

; 499  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 500  :     is->rewind(is, is->lastMarker);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00031	ff 50 48	 call	 QWORD PTR [rax+72]

; 501  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
antlr38BitRewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitRewind
_TEXT	SEGMENT
state$ = 32
input$ = 40
tv89 = 48
is$ = 80
mark$ = 88
antlr38BitRewind PROC					; COMDAT

; 512  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 513  :     pANTLR3_LEX_STATE	state;
; 514  :     pANTLR3_INPUT_STREAM input;
; 515  : 
; 516  :     input   = ((pANTLR3_INPUT_STREAM) is->super);

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 517  : 
; 518  :     /* Perform any clean up of the marks
; 519  :      */
; 520  :     input->istream->release(input->istream, mark);

  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 54 24 58	 mov	 rdx, QWORD PTR mark$[rsp]
  0003e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00043	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00046	ff 50 58	 call	 QWORD PTR [rax+88]

; 521  : 
; 522  :     /* Find the supplied mark state 
; 523  :      */
; 524  :     state   = (pANTLR3_LEX_STATE)input->markers->get(input->markers, (ANTLR3_UINT32)(mark - 1));

  00049	48 8b 44 24 58	 mov	 rax, QWORD PTR mark$[rsp]
  0004e	48 ff c8	 dec	 rax
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00056	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0005a	48 89 4c 24 30	 mov	 QWORD PTR tv89[rsp], rcx
  0005f	8b d0		 mov	 edx, eax
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00066	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv89[rsp]
  0006f	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00075	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 525  : 
; 526  :     /* Seek input pointer to the requested point (note we supply the void *pointer
; 527  :      * to whatever is implementing the int stream to seek).
; 528  :      */
; 529  :     antlr38BitSeek(is, (ANTLR3_MARKER)(state->nextChar));

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  00087	e8 00 00 00 00	 call	 antlr38BitSeek

; 530  : 
; 531  :     /* Reset to the reset of the information in the mark
; 532  :      */
; 533  :     input->charPositionInLine	= state->charPositionInLine;

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00096	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00099	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 534  :     input->currentLine		= state->currentLine;

  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000a6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000aa	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 535  :     input->line			= state->line;

  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000b8	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000bb	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 536  :     input->nextChar		= state->nextChar;

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000c8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cb	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 537  : 
; 538  :     /* And we are done
; 539  :      */
; 540  : }

  000cf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
antlr38BitRewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitMark
_TEXT	SEGMENT
state$ = 32
input$ = 40
tv137 = 48
is$ = 80
antlr38BitMark PROC					; COMDAT

; 446  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 447  :     pANTLR3_LEX_STATE	    state;
; 448  :     pANTLR3_INPUT_STREAM    input;
; 449  : 
; 450  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 451  : 
; 452  :     /* New mark point 
; 453  :      */
; 454  :     input->markDepth++;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00031	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00034	ff c0		 inc	 eax
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0003b	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 455  : 
; 456  :     /* See if we are revisiting a mark as we can just reuse the vector
; 457  :      * entry if we are, otherwise, we need a new one
; 458  :      */
; 459  :     if	(input->markDepth > input->markers->count)

  0003e	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00043	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0004c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004f	39 41 44	 cmp	 DWORD PTR [rcx+68], eax
  00052	76 36		 jbe	 SHORT $LN2@antlr38Bit

; 460  :     {	
; 461  : 	state	= ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));

  00054	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005f	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 462  : 
; 463  : 	/* Add it to the table
; 464  : 	 */
; 465  : 	input->markers->add(input->markers, state, ANTLR3_FREE_FUNC);	/* No special structure, just free() on delete */

  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00069	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0006d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_free
  00074	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0007e	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00082	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 466  :     }

  00088	eb 33		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 467  :     else
; 468  :     {
; 469  : 	state	= (pANTLR3_LEX_STATE)input->markers->get(input->markers, input->markDepth - 1);

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  0008f	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00092	ff c8		 dec	 eax
  00094	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00099	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0009d	48 89 4c 24 30	 mov	 QWORD PTR tv137[rsp], rcx
  000a2	8b d0		 mov	 edx, eax
  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000a9	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR tv137[rsp]
  000b2	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  000b8	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax
$LN3@antlr38Bit:

; 470  : 
; 471  : 	/* Assume no errors for speed, it will just blow up if the table failed
; 472  : 	 * for some reasons, hence lots of unit tests on the tables ;-)
; 473  : 	 */
; 474  :     }
; 475  : 
; 476  :     /* We have created or retrieved the state, so update it with the current
; 477  :      * elements of the lexer state.
; 478  :      */
; 479  :     state->charPositionInLine	= input->charPositionInLine;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000c7	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  000ca	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 480  :     state->currentLine		= input->currentLine;

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000d7	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000db	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 481  :     state->line			= input->line;

  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000e9	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  000ec	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 482  :     state->nextChar		= input->nextChar;

  000ef	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000f9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 483  : 
; 484  :     is->lastMarker  = input->markDepth;

  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00105	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00108	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  0010d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 485  : 
; 486  :     /* And that's it
; 487  :      */
; 488  :     return  input->markDepth;

  00111	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00116	8b 40 44	 mov	 eax, DWORD PTR [rax+68]

; 489  : }

  00119	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011d	5f		 pop	 rdi
  0011e	c3		 ret	 0
antlr38BitMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitIndex
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr38BitIndex PROC					; COMDAT

; 417  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 418  :     pANTLR3_INPUT_STREAM input;
; 419  : 
; 420  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 421  : 
; 422  :     return  (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 423  : }

  00033	48 83 c4 10	 add	 rsp, 16
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
antlr38BitIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitLA_ucase
_TEXT	SEGMENT
input$ = 32
is$ = 64
la$ = 72
antlr38BitLA_ucase PROC					; COMDAT

; 378  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 379  :     pANTLR3_INPUT_STREAM input;
; 380  : 	
; 381  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 382  : 
; 383  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00030	48 63 44 24 48	 movsxd	 rax, DWORD PTR la$[rsp]
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0003a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003e	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00048	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  0004b	48 8b 54 24 20	 mov	 rdx, QWORD PTR input$[rsp]
  00050	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00054	48 3b c1	 cmp	 rax, rcx
  00057	72 09		 jb	 SHORT $LN2@antlr38Bit

; 384  :     {
; 385  : 		return	ANTLR3_CHARSTREAM_EOF;

  00059	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005e	eb 1d		 jmp	 SHORT $LN1@antlr38Bit

; 386  :     }

  00060	eb 1b		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 387  :     else
; 388  :     {
; 389  : 		return	(ANTLR3_UCHAR)toupper((*((pANTLR3_UINT8)input->nextChar + la - 1)));

  00062	48 63 44 24 48	 movsxd	 rax, DWORD PTR la$[rsp]
  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0006c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00070	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
  00075	8b c8		 mov	 ecx, eax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
$LN3@antlr38Bit:
$LN1@antlr38Bit:

; 390  :     }
; 391  : }

  0007d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
antlr38BitLA_ucase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitLA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr38BitLA PROC					; COMDAT

; 351  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 352  :     pANTLR3_INPUT_STREAM input;
; 353  : 	
; 354  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 355  : 
; 356  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00038	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003c	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00045	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00048	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0004c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00050	48 3b c1	 cmp	 rax, rcx
  00053	72 09		 jb	 SHORT $LN2@antlr38Bit

; 357  :     {
; 358  : 		return	ANTLR3_CHARSTREAM_EOF;

  00055	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005a	eb 14		 jmp	 SHORT $LN1@antlr38Bit

; 359  :     }

  0005c	eb 12		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 360  :     else
; 361  :     {
; 362  : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar + la - 1));

  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00067	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006b	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
$LN3@antlr38Bit:
$LN1@antlr38Bit:

; 363  :     }
; 364  : }

  00070	48 83 c4 10	 add	 rsp, 16
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
antlr38BitLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitConsume
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr38BitConsume PROC					; COMDAT

; 316  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 317  :     pANTLR3_INPUT_STREAM input;
; 318  : 
; 319  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 320  : 
; 321  :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0002f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00032	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00036	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00042	73 68		 jae	 SHORT $LN2@antlr38Bit

; 322  :     {	
; 323  : 	/* Indicate one more character in this line
; 324  : 	 */
; 325  : 	input->charPositionInLine++;

  00044	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00048	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0004b	ff c0		 inc	 eax
  0004d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00051	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 326  : 	
; 327  : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar)) == input->newlineChar)

  00054	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00058	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00063	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  00069	75 2e		 jne	 SHORT $LN3@antlr38Bit

; 328  : 	{
; 329  : 	    /* Reset for start of a new line of input
; 330  : 	     */
; 331  : 	    input->line++;

  0006b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00072	ff c0		 inc	 eax
  00074	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00078	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 332  : 	    input->charPositionInLine	= 0;

  0007b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0007f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 333  : 	    input->currentLine		= (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  00086	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008e	48 ff c0	 inc	 rax
  00091	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00095	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr38Bit:

; 334  : 	}
; 335  : 
; 336  : 	/* Increment to next character position
; 337  : 	 */
; 338  : 	input->nextChar = (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  00099	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a1	48 ff c0	 inc	 rax
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a8	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@antlr38Bit:

; 339  :     }
; 340  : }

  000ac	48 83 c4 10	 add	 rsp, 16
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
antlr38BitConsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3GenericSetupStream
_TEXT	SEGMENT
input$ = 48
antlr3GenericSetupStream PROC				; COMDAT

; 137  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 138  :     /* Install function pointers for an 8 bit input
; 139  :      */
; 140  : 
; 141  :     /* Allocate stream interface
; 142  :      */
; 143  :     input->istream		= antlr3IntStreamNew();

  0001e	e8 00 00 00 00	 call	 antlr3IntStreamNew
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 144  :     input->istream->type        = ANTLR3_CHARSTREAM;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 145  :     input->istream->super       = input;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00046	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 146  : 
; 147  :     /* Intstream API
; 148  :      */
; 149  :     input->istream->consume	    = antlr38BitConsume;	    // Consume the next 8 bit character in the buffer			

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitConsume
  00059	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 150  :     input->istream->_LA		    = antlr38BitLA;	            // Return the UTF32 character at offset n (1 based)			

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA
  0006c	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 151  :     input->istream->index	    = antlr38BitIndex;	            // Current index (offset from first character			    

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitIndex
  0007f	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 152  :     input->istream->mark	    = antlr38BitMark;		    // Record the current lex state for later restore			

  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitMark
  00092	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 153  :     input->istream->rewind	    = antlr38BitRewind;	            // How to rewind the input									

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0009b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRewind
  000a5	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 154  :     input->istream->rewindLast	    = antlr38BitRewindLast;	    // How to rewind the input									

  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000ae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRewindLast
  000b8	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 155  :     input->istream->seek	    = antlr38BitSeek;		    // How to seek to a specific point in the stream		    

  000bc	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSeek
  000cb	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 156  :     input->istream->release	    = antlr38BitRelease;	    // Reset marks after mark n									

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRelease
  000de	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 157  :     input->istream->getSourceName   = antlr38BitGetSourceName;      // Return a string that names the input source

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetSourceName
  000f1	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 158  : 
; 159  :     /* Charstream API
; 160  :      */
; 161  :     input->close		    =  antlr3InputClose;	    // Close down the stream completely										

  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputClose
  00101	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 162  :     input->free			    =  antlr3InputClose;	    // Synonym for free														

  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputClose
  00111	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 163  :     input->reset		    =  antlr3InputReset;	    // Reset input to start	

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputReset
  00121	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 164  :     input->reuse                    =  antlr38BitReuse;             // Install a new input string and reset

  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitReuse
  00131	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 165  :     input->_LT			    =  antlr38BitLT;		    // Same as _LA for 8 bit file										

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLT
  00141	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 166  :     input->size			    =  antlr38BitSize;		    // Return the size of the input buffer									

  00148	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSize
  00154	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 167  :     input->substr		    =  antlr38BitSubstr;	    // Return a string from the input stream								

  0015b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSubstr
  00167	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 168  :     input->getLine		    =  antlr38BitGetLine;	    // Return the current line number in the input stream					

  0016e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetLine
  0017a	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 169  :     input->getLineBuf		    =  antlr38BitGetLineBuf;	    // Return a pointer to the start of the current line being consumed	    

  00181	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetLineBuf
  0018d	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 170  :     input->getCharPositionInLine    =  antlr38BitGetCharPosition;   // Return the offset into the current line of input						

  00194	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetCharPosition
  001a0	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 171  :     input->setLine		    =  antlr38BitSetLine;	    // Set the input stream line number (does not set buffer pointers)	    

  001a7	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetLine
  001b3	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 172  :     input->setCharPositionInLine    =  antlr38BitSetCharPosition;   // Set the offset in to the current line (does not set any pointers)   

  001ba	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetCharPosition
  001c6	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 173  :     input->SetNewLineChar	    =  antlr38BitSetNewLineChar;    // Set the value of the newline trigger character						

  001cd	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetNewLineChar
  001d9	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 174  :     input->setUcaseLA		    =  antlr38BitSetUcaseLA;        // Changes the LA function to return upper case always

  001e0	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetUcaseLA
  001ec	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 175  : 
; 176  :     input->charByteSize		    = 1;		// Size in bytes of characters in this stream.

  001f3	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001f8	c6 80 d4 00 00
	00 01		 mov	 BYTE PTR [rax+212], 1

; 177  : 
; 178  :     /* Initialize entries for tables etc
; 179  :      */
; 180  :     input->markers  = NULL;

  001ff	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00204	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 181  : 
; 182  :     /* Set up the input stream brand new
; 183  :      */
; 184  :     input->reset(input);

  0020c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00211	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00216	ff 50 70	 call	 QWORD PTR [rax+112]

; 185  :     
; 186  :     /* Install default line separator character (it can be replaced
; 187  :      * by the grammar programmer later)
; 188  :      */
; 189  :     input->SetNewLineChar(input, (ANTLR3_UCHAR)'\n');

  00219	ba 0a 00 00 00	 mov	 edx, 10
  0021e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00223	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00228	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 190  : }

  0022e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00232	5f		 pop	 rdi
  00233	c3		 ret	 0
antlr3GenericSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3EBCDICSetupStream
_TEXT	SEGMENT
input$ = 48
antlr3EBCDICSetupStream PROC				; COMDAT

; 2014 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 2015 :     // EBCDIC streams can use the standard 8 bit string factory
; 2016 :     //
; 2017 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00023	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00029	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00033	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 2018 : 
; 2019 :     // Generic API that does not care about endianess.
; 2020 :     //
; 2021 :     input->istream->_LA         = antlr3EBCDICLA;       // Return the UTF32 character at offset n (1 based)    

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EBCDICLA
  00046	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 2022 :     input->charByteSize		= 1;	                // Size in bytes of characters in this stream.

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004f	c6 80 d4 00 00
	00 01		 mov	 BYTE PTR [rax+212], 1

; 2023 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
antlr3EBCDICSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF8SetupStream
_TEXT	SEGMENT
input$ = 48
antlr3UTF8SetupStream PROC				; COMDAT

; 1751 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1752 :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 1753 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1754 :     // and so on.
; 1755 :     //
; 1756 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00023	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00029	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00033	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1757 : 
; 1758 :     // Generic API that does not care about endianess.
; 1759 :     //
; 1760 :     input->istream->consume	= antlr3UTF8Consume;	// Consume the next UTF32 character in the buffer

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF8Consume
  00046	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1761 :     input->istream->_LA         = antlr3UTF8LA;         // Return the UTF32 character at offset n (1 based)    

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF8LA
  00059	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1762 :     input->charByteSize		= 0;	                // Size in bytes of characters in this stream.

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00062	c6 80 d4 00 00
	00 00		 mov	 BYTE PTR [rax+212], 0

; 1763 : }

  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
antlr3UTF8SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF32SetupStream
_TEXT	SEGMENT
tv76 = 32
input$ = 64
machineBigEndian$ = 72
inputBigEndian$ = 80
antlr3UTF32SetupStream PROC				; COMDAT

; 1501 : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1502 :     // Build a string factory for this stream. This is a UTF32 string factory which is a standard
; 1503 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1504 :     // and so on.
; 1505 :     //
; 1506 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0002c	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00032	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0003c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1507 : 
; 1508 :     // Generic API that does not care about endianess.
; 1509 :     //
; 1510 :     input->istream->index	    =  antlr3UTF32Index;            // Calculate current index in input stream, UTF16 based

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Index
  0004f	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1511 :     input->substr		    =  antlr3UTF32Substr;	    // Return a string from the input stream

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Substr
  0005f	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 1512 :     input->istream->seek	    =  antlr3UTF32Seek;		    // How to seek to a specific point in the stream

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Seek
  00075	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1513 :     input->istream->consume	    =  antlr3UTF32Consume;	    // Consume the next UTF32 character in the buffer

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0007e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Consume
  00088	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1514 : 
; 1515 :     // We must install different UTF32 LA routines according to whether the input
; 1516 :     // is the same endianess as the machine we are executing upon or not. If it is not
; 1517 :     // then we must install methods that can convert the endianess on the fly as they go
; 1518 :     //
; 1519 :     switch (machineBigEndian)

  0008c	0f b6 44 24 48	 movzx	 eax, BYTE PTR machineBigEndian$[rsp]
  00091	88 44 24 20	 mov	 BYTE PTR tv76[rsp], al
  00095	80 7c 24 20 00	 cmp	 BYTE PTR tv76[rsp], 0
  0009a	74 3d		 je	 SHORT $LN7@antlr3UTF3
  0009c	80 7c 24 20 01	 cmp	 BYTE PTR tv76[rsp], 1
  000a1	74 02		 je	 SHORT $LN4@antlr3UTF3
  000a3	eb 65		 jmp	 SHORT $LN2@antlr3UTF3
$LN4@antlr3UTF3:

; 1520 :     {
; 1521 :         case    ANTLR3_TRUE:
; 1522 : 
; 1523 :             // Machine is Big Endian, if the input is also then install the 
; 1524 :             // methods that do not access input by bytes and reverse them.
; 1525 :             // Otherwise install endian aware methods.
; 1526 :             //
; 1527 :             if  (inputBigEndian == ANTLR3_TRUE) 

  000a5	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	75 15		 jne	 SHORT $LN5@antlr3UTF3

; 1528 :             {
; 1529 :                 // Input is machine compatible
; 1530 :                 //
; 1531 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LA
  000be	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1532 :             }

  000c2	eb 13		 jmp	 SHORT $LN6@antlr3UTF3
$LN5@antlr3UTF3:

; 1533 :             else
; 1534 :             {
; 1535 :                 // Need to use methods that know that the input is little endian
; 1536 :                 //
; 1537 :                 input->istream->_LA         =  antlr3UTF32LALE;		    // Return the UTF32 character at offset n (1 based) 

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LALE
  000d3	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN6@antlr3UTF3:

; 1538 :             }
; 1539 :             break;

  000d7	eb 31		 jmp	 SHORT $LN2@antlr3UTF3
$LN7@antlr3UTF3:

; 1540 : 
; 1541 :         case    ANTLR3_FALSE:
; 1542 : 
; 1543 :             // Machine is Little Endian, if the input is also then install the 
; 1544 :             // methods that do not access input by bytes and reverse them.
; 1545 :             // Otherwise install endian aware methods.
; 1546 :             //
; 1547 :             if  (inputBigEndian == ANTLR3_FALSE) 

  000d9	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  000de	85 c0		 test	 eax, eax
  000e0	75 15		 jne	 SHORT $LN8@antlr3UTF3

; 1548 :             {
; 1549 :                 // Input is machine compatible
; 1550 :                 //
; 1551 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LA
  000f1	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1552 :             }

  000f5	eb 13		 jmp	 SHORT $LN9@antlr3UTF3
$LN8@antlr3UTF3:

; 1553 :             else
; 1554 :             {
; 1555 :                 // Need to use methods that know that the input is Big Endian
; 1556 :                 //
; 1557 :                 input->istream->_LA         =  antlr3UTF32LABE;		    // Return the UTF32 character at offset n (1 based) 

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LABE
  00106	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN9@antlr3UTF3:
$LN2@antlr3UTF3:

; 1558 :             }
; 1559 :             break;
; 1560 :     }
; 1561 : 
; 1562 :     input->charByteSize		    = 4;			    // Size in bytes of characters in this stream.

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0010f	c6 80 d4 00 00
	00 04		 mov	 BYTE PTR [rax+212], 4

; 1563 : }

  00116	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
antlr3UTF32SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr3UTF16SetupStream
_TEXT	SEGMENT
tv74 = 32
input$ = 64
machineBigEndian$ = 72
inputBigEndian$ = 80
antlr3UTF16SetupStream PROC				; COMDAT

; 703  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 704  :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 705  :     // part of the ANTLR3 string. The string factory is then passed through the whole chain 
; 706  :     // of lexer->parser->tree->treeparser and so on.
; 707  :     //
; 708  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0002c	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00032	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0003c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 709  : 
; 710  :     // Generic API that does not care about endianess.
; 711  :     //
; 712  :     input->istream->index	    =  antlr3UTF16Index;            // Calculate current index in input stream, UTF16 based

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Index
  0004f	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 713  :     input->substr		    =  antlr3UTF16Substr;	    // Return a string from the input stream

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Substr
  0005f	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 714  :     input->istream->seek	    =  antlr3UTF16Seek;		    // How to seek to a specific point in the stream

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Seek
  00075	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 715  : 
; 716  :     // We must install different UTF16 routines according to whether the input
; 717  :     // is the same endianess as the machine we are executing upon or not. If it is not
; 718  :     // then we must install methods that can convert the endianess on the fly as they go
; 719  :     //
; 720  : 
; 721  :     switch (machineBigEndian)

  00079	0f b6 44 24 48	 movzx	 eax, BYTE PTR machineBigEndian$[rsp]
  0007e	88 44 24 20	 mov	 BYTE PTR tv74[rsp], al
  00082	80 7c 24 20 00	 cmp	 BYTE PTR tv74[rsp], 0
  00087	74 66		 je	 SHORT $LN7@antlr3UTF1
  00089	80 7c 24 20 01	 cmp	 BYTE PTR tv74[rsp], 1
  0008e	74 05		 je	 SHORT $LN4@antlr3UTF1
  00090	e9 b1 00 00 00	 jmp	 $LN2@antlr3UTF1
$LN4@antlr3UTF1:

; 722  :     {
; 723  :         case    ANTLR3_TRUE:
; 724  : 
; 725  :             // Machine is Big Endian, if the input is also then install the 
; 726  :             // methods that do not access input by bytes and reverse them.
; 727  :             // Otherwise install endian aware methods.
; 728  :             //
; 729  :             if  (inputBigEndian == ANTLR3_TRUE) 

  00095	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  0009a	83 f8 01	 cmp	 eax, 1
  0009d	75 28		 jne	 SHORT $LN5@antlr3UTF1

; 730  :             {
; 731  :                 // Input is machine compatible
; 732  :                 //
; 733  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Consume
  000ae	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 734  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LA
  000c1	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 735  :             }

  000c5	eb 26		 jmp	 SHORT $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 736  :             else
; 737  :             {
; 738  :                 // Need to use methods that know that the input is little endian
; 739  :                 //
; 740  :                 input->istream->consume	    =  antlr3UTF16ConsumeLE;	    // Consume the next UTF16 character in the buffer

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16ConsumeLE
  000d6	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 741  :                 input->istream->_LA         =  antlr3UTF16LALE;		    // Return the UTF32 character at offset n (1 based) 

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000df	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LALE
  000e9	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN6@antlr3UTF1:

; 742  :             }
; 743  :             break;

  000ed	eb 57		 jmp	 SHORT $LN2@antlr3UTF1
$LN7@antlr3UTF1:

; 744  : 
; 745  :         case    ANTLR3_FALSE:
; 746  : 
; 747  :             // Machine is Little Endian, if the input is also then install the 
; 748  :             // methods that do not access input by bytes and reverse them.
; 749  :             // Otherwise install endian aware methods.
; 750  :             //
; 751  :             if  (inputBigEndian == ANTLR3_FALSE) 

  000ef	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  000f4	85 c0		 test	 eax, eax
  000f6	75 28		 jne	 SHORT $LN8@antlr3UTF1

; 752  :             {
; 753  :                 // Input is machine compatible
; 754  :                 //
; 755  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Consume
  00107	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 756  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00110	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LA
  0011a	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 757  :             }

  0011e	eb 26		 jmp	 SHORT $LN9@antlr3UTF1
$LN8@antlr3UTF1:

; 758  :             else
; 759  :             {
; 760  :                 // Need to use methods that know that the input is Big Endian
; 761  :                 //
; 762  :                 input->istream->consume	    =  antlr3UTF16ConsumeBE;	    // Consume the next UTF16 character in the buffer

  00120	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00125	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16ConsumeBE
  0012f	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 763  :                 input->istream->_LA         =  antlr3UTF16LABE;		    // Return the UTF32 character at offset n (1 based) 

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00138	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LABE
  00142	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN9@antlr3UTF1:
$LN2@antlr3UTF1:

; 764  :             }
; 765  :             break;
; 766  :     }
; 767  : 
; 768  :         
; 769  :     input->charByteSize		    = 2;			    // Size in bytes of characters in this stream.

  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0014b	c6 80 d4 00 00
	00 02		 mov	 BYTE PTR [rax+212], 2

; 770  : 
; 771  : }

  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	5f		 pop	 rdi
  00157	c3		 ret	 0
antlr3UTF16SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3inputstream.c
;	COMDAT antlr38BitSetupStream
_TEXT	SEGMENT
input$ = 48
antlr38BitSetupStream PROC				; COMDAT

; 126  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 127  :     // Build a string factory for this stream
; 128  :     //
; 129  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00023	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00029	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00033	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 130  : 
; 131  :     // Default stream API set up is for 8Bit, so we are done
; 132  :     //
; 133  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
antlr38BitSetupStream ENDP
_TEXT	ENDS
END
