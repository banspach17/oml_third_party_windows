; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3StringFactoryNew
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp_memmove:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	ConvertUTF16toUTF8:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StringFactoryNew DD imagerel $LN12
	DD	imagerel $LN12+491
	DD	imagerel $unwind$antlr3StringFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newRaw8 DD imagerel newRaw8
	DD	imagerel newRaw8+173
	DD	imagerel $unwind$newRaw8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newRawUTF16 DD imagerel newRawUTF16
	DD	imagerel newRawUTF16+173
	DD	imagerel $unwind$newRawUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSize8 DD imagerel newSize8
	DD	imagerel newSize8+129
	DD	imagerel $unwind$newSize8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSizeUTF16 DD imagerel newSizeUTF16
	DD	imagerel newSizeUTF16+133
	DD	imagerel $unwind$newSizeUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtr8 DD imagerel newPtr8
	DD	imagerel newPtr8+163
	DD	imagerel $unwind$newPtr8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtrUTF16_8 DD imagerel newPtrUTF16_8
	DD	imagerel newPtrUTF16_8+265
	DD	imagerel $unwind$newPtrUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtrUTF16_UTF16 DD imagerel newPtrUTF16_UTF16
	DD	imagerel newPtrUTF16_UTF16+168
	DD	imagerel $unwind$newPtrUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStr8 DD imagerel newStr8
	DD	imagerel newStr8+72
	DD	imagerel $unwind$newStr8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStrUTF16_8 DD imagerel newStrUTF16_8
	DD	imagerel newStrUTF16_8+72
	DD	imagerel $unwind$newStrUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStrUTF16_UTF16 DD imagerel newStrUTF16_UTF16
	DD	imagerel newStrUTF16_UTF16+152
	DD	imagerel $unwind$newStrUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$destroy DD imagerel destroy
	DD	imagerel destroy+177
	DD	imagerel $unwind$destroy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printable8 DD imagerel printable8
	DD	imagerel printable8+395
	DD	imagerel $unwind$printable8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printableUTF16 DD imagerel printableUTF16
	DD	imagerel printableUTF16+461
	DD	imagerel $unwind$printableUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeFactory DD imagerel closeFactory
	DD	imagerel closeFactory+69
	DD	imagerel $unwind$closeFactory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set8 DD	imagerel set8
	DD	imagerel set8+171
	DD	imagerel $unwind$set8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setUTF16_8 DD imagerel setUTF16_8
	DD	imagerel setUTF16_8+241
	DD	imagerel $unwind$setUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setUTF16_UTF16 DD imagerel setUTF16_UTF16
	DD	imagerel setUTF16_UTF16+255
	DD	imagerel $unwind$setUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$append8 DD imagerel append8
	DD	imagerel append8+217
	DD	imagerel $unwind$append8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendUTF16_8 DD imagerel appendUTF16_8
	DD	imagerel appendUTF16_8+287
	DD	imagerel $unwind$appendUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendUTF16_UTF16 DD imagerel appendUTF16_UTF16
	DD	imagerel appendUTF16_UTF16+305
	DD	imagerel $unwind$appendUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insert8 DD imagerel insert8
	DD	imagerel insert8+354
	DD	imagerel $unwind$insert8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertUTF16_8 DD imagerel insertUTF16_8
	DD	imagerel insertUTF16_8+417
	DD	imagerel $unwind$insertUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertUTF16_UTF16 DD imagerel insertUTF16_UTF16
	DD	imagerel insertUTF16_UTF16+450
	DD	imagerel $unwind$insertUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setS DD	imagerel setS
	DD	imagerel setS+63
	DD	imagerel $unwind$setS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendS DD imagerel appendS
	DD	imagerel appendS+118
	DD	imagerel $unwind$appendS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertS DD imagerel insertS
	DD	imagerel insertS+71
	DD	imagerel $unwind$insertS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addc8 DD	imagerel addc8
	DD	imagerel addc8+193
	DD	imagerel $unwind$addc8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addcUTF16 DD imagerel addcUTF16
	DD	imagerel addcUTF16+207
	DD	imagerel $unwind$addcUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addi8 DD	imagerel addi8
	DD	imagerel addi8+141
	DD	imagerel $unwind$addi8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addiUTF16 DD imagerel addiUTF16
	DD	imagerel addiUTF16+141
	DD	imagerel $unwind$addiUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inserti8 DD imagerel inserti8
	DD	imagerel inserti8+153
	DD	imagerel $unwind$inserti8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertiUTF16 DD imagerel insertiUTF16
	DD	imagerel insertiUTF16+153
	DD	imagerel $unwind$insertiUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compare8 DD imagerel compare8
	DD	imagerel compare8+60
	DD	imagerel $unwind$compare8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareUTF16_8 DD imagerel compareUTF16_8
	DD	imagerel compareUTF16_8+155
	DD	imagerel $unwind$compareUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareUTF16_UTF16 DD imagerel compareUTF16_UTF16
	DD	imagerel compareUTF16_UTF16+166
	DD	imagerel $unwind$compareUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareS DD imagerel compareS
	DD	imagerel compareS+66
	DD	imagerel $unwind$compareS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charAt8 DD imagerel charAt8
	DD	imagerel charAt8+49
	DD	imagerel $unwind$charAt8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charAtUTF16 DD imagerel charAtUTF16
	DD	imagerel charAtUTF16+49
	DD	imagerel $unwind$charAtUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$subString8 DD imagerel subString8
	DD	imagerel subString8+143
	DD	imagerel $unwind$subString8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$subStringUTF16 DD imagerel subStringUTF16
	DD	imagerel subStringUTF16+147
	DD	imagerel $unwind$subStringUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toInt32_8 DD imagerel toInt32_8
	DD	imagerel toInt32_8+51
	DD	imagerel $unwind$toInt32_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toInt32_UTF16 DD imagerel toInt32_UTF16
	DD	imagerel toInt32_UTF16+234
	DD	imagerel $unwind$toInt32_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$to8_8 DD	imagerel to8_8
	DD	imagerel to8_8+13
	DD	imagerel $unwind$to8_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$to8_UTF16 DD imagerel to8_UTF16
	DD	imagerel to8_UTF16+264
	DD	imagerel $unwind$to8_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toUTF8_8 DD imagerel toUTF8_8
	DD	imagerel toUTF8_8+73
	DD	imagerel $unwind$toUTF8_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toUTF8_UTF16 DD imagerel toUTF8_UTF16
	DD	imagerel toUTF8_UTF16+346
	DD	imagerel $unwind$toUTF8_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringInit8 DD imagerel stringInit8
	DD	imagerel stringInit8+398
	DD	imagerel $unwind$stringInit8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringInitUTF16 DD imagerel stringInitUTF16
	DD	imagerel stringInitUTF16+398
	DD	imagerel $unwind$stringInitUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringFree DD imagerel stringFree
	DD	imagerel stringFree+74
	DD	imagerel $unwind$stringFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringFree DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringInitUTF16 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringInit8 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toUTF8_UTF16 DD 022401H
	DD	07006f20dH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
toUTF8_UTF16$rtcName$0 DB 06fH
	DB	075H
	DB	074H
	DB	070H
	DB	075H
	DB	074H
	DB	045H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+6
toUTF8_UTF16$rtcName$1 DB 069H
	DB	06eH
	DB	070H
	DB	075H
	DB	074H
	DB	045H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+7
toUTF8_UTF16$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:toUTF8_UTF16$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:toUTF8_UTF16$rtcName$0
	ORG $+96
toUTF8_UTF16$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:toUTF8_UTF16$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toUTF8_8 DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to8_UTF16 DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to8_8 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toInt32_UTF16 DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toInt32_8 DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subStringUTF16 DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subString8 DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charAtUTF16 DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charAt8 DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareS DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareUTF16_UTF16 DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareUTF16_8 DD 022301H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compare8 DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertiUTF16 DD 023919H
	DD	0700fd213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
insertiUTF16$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
insertiUTF16$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:insertiUTF16$rtcName$0
	ORG $+48
insertiUTF16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:insertiUTF16$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inserti8 DD 023919H
	DD	0700fd213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inserti8$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
inserti8$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:inserti8$rtcName$0
	ORG $+48
inserti8$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:inserti8$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addiUTF16 DD 023419H
	DD	0700ad20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addiUTF16$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
addiUTF16$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:addiUTF16$rtcName$0
	ORG $+48
addiUTF16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addiUTF16$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addi8 DD 023419H
	DD	0700ad20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addi8$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
addi8$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:addi8$rtcName$0
	ORG $+48
addi8$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addi8$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addcUTF16 DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addc8 DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertS DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendS DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setS DD	022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertUTF16_UTF16 DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertUTF16_8 DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insert8 DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendUTF16_UTF16 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendUTF16_8 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$append8 DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setUTF16_UTF16 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setUTF16_8 DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set8 DD	022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeFactory DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printableUTF16 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printable8 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$destroy DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStrUTF16_UTF16 DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStrUTF16_8 DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStr8 DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtrUTF16_UTF16 DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtrUTF16_8 DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtr8 DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSizeUTF16 DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSize8 DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newRawUTF16 DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newRaw8 DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StringFactoryNew DD 021c01H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT stringFree
_TEXT	SEGMENT
string$ = 48
stringFree PROC						; COMDAT

; 240  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 241  :     /* First free the string itself if there was anything in it
; 242  :      */
; 243  :     if	(string->chars)

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	74 0f		 je	 SHORT $LN2@stringFree

; 244  :     {
; 245  : 	ANTLR3_FREE(string->chars);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0002f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@stringFree:

; 246  :     }
; 247  : 
; 248  :     /* Now free the space for this string
; 249  :      */
; 250  :     ANTLR3_FREE(string);

  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 251  : 
; 252  :     return;
; 253  : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
stringFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT stringInitUTF16
_TEXT	SEGMENT
string$ = 16
stringInitUTF16 PROC					; COMDAT

; 298  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 299  :     string->len		= 0;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 300  :     string->size	= 0;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00017	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 301  :     string->chars	= NULL;

  0001e	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 302  :     string->encoding	= ANTLR3_ENC_8BIT;

  0002b	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00030	c6 40 1c 04	 mov	 BYTE PTR [rax+28], 4

; 303  : 
; 304  :     /* API for UTF16 strings */
; 305  : 
; 306  :     string->set		= setUTF16_UTF16;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setUTF16_UTF16
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 307  :     string->set8	= setUTF16_8;

  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setUTF16_8
  00050	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 308  :     string->append	= appendUTF16_UTF16;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendUTF16_UTF16
  00060	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 309  :     string->append8	= appendUTF16_8;

  00064	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendUTF16_8
  00070	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 310  :     string->insert	= insertUTF16_UTF16;

  00074	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertUTF16_UTF16
  00080	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 311  :     string->insert8	= insertUTF16_8;

  00084	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertUTF16_8
  00090	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 312  :     string->addi	= addiUTF16;

  00094	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addiUTF16
  000a0	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 313  :     string->inserti	= insertiUTF16;

  000a4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertiUTF16
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 314  :     string->addc	= addcUTF16;

  000b4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addcUTF16
  000c0	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 315  :     string->charAt	= charAtUTF16;

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:charAtUTF16
  000d0	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 316  :     string->compare	= compareUTF16_UTF16;

  000d7	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareUTF16_UTF16
  000e3	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 317  :     string->compare8	= compareUTF16_8;

  000ea	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareUTF16_8
  000f6	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 318  :     string->subString	= subStringUTF16;

  000fd	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:subStringUTF16
  00109	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 319  :     string->toInt32	= toInt32_UTF16;

  00110	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toInt32_UTF16
  0011c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 320  :     string->to8		= to8_UTF16;

  00123	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:to8_UTF16
  0012f	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 321  :     string->toUTF8	= toUTF8_UTF16;

  00136	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toUTF8_UTF16
  00142	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 322  : 
; 323  :     string->compareS	= compareS;

  00149	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareS
  00155	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 324  :     string->setS	= setS;

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setS
  00168	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 325  :     string->appendS	= appendS;

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendS
  00178	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 326  :     string->insertS	= insertS;

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertS
  00188	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 327  : }

  0018c	5f		 pop	 rdi
  0018d	c3		 ret	 0
stringInitUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT stringInit8
_TEXT	SEGMENT
string$ = 16
stringInit8 PROC					; COMDAT

; 261  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 262  :     string->len			= 0;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 263  :     string->size		= 0;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00017	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 264  :     string->chars		= NULL;

  0001e	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 265  :     string->encoding	= ANTLR3_ENC_8BIT ;

  0002b	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00030	c6 40 1c 04	 mov	 BYTE PTR [rax+28], 4

; 266  : 
; 267  :     /* API for 8 bit strings*/
; 268  : 
; 269  :     string->set		= set8;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set8
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 270  :     string->set8	= set8;

  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set8
  00050	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 271  :     string->append	= append8;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:append8
  00060	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 272  :     string->append8	= append8;

  00064	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:append8
  00070	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 273  :     string->insert	= insert8;

  00074	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insert8
  00080	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 274  :     string->insert8	= insert8;

  00084	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insert8
  00090	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 275  :     string->addi	= addi8;

  00094	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addi8
  000a0	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 276  :     string->inserti	= inserti8;

  000a4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inserti8
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 277  :     string->addc	= addc8;

  000b4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addc8
  000c0	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 278  :     string->charAt	= charAt8;

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:charAt8
  000d0	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 279  :     string->compare	= compare8;

  000d7	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compare8
  000e3	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 280  :     string->compare8	= compare8;

  000ea	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compare8
  000f6	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 281  :     string->subString	= subString8;

  000fd	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:subString8
  00109	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 282  :     string->toInt32	= toInt32_8;

  00110	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toInt32_8
  0011c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 283  :     string->to8		= to8_8;

  00123	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:to8_8
  0012f	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 284  :     string->toUTF8	= toUTF8_8;

  00136	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toUTF8_8
  00142	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 285  :     string->compareS	= compareS;

  00149	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareS
  00155	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 286  :     string->setS	= setS;

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setS
  00168	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 287  :     string->appendS	= appendS;

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendS
  00178	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 288  :     string->insertS	= insertS;

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertS
  00188	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 289  : 
; 290  : }

  0018c	5f		 pop	 rdi
  0018d	c3		 ret	 0
stringInit8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT toUTF8_UTF16
_TEXT	SEGMENT
outputEnd$ = 56
inputEnd$ = 88
utf8String$ = 104
cResult$ = 112
string$ = 144
toUTF8_UTF16 PROC					; COMDAT

; 361  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]

; 362  : 
; 363  :     UTF8	      * outputEnd;	
; 364  :     UTF16	      * inputEnd;
; 365  :     pANTLR3_STRING	utf8String;
; 366  : 
; 367  :     ConversionResult	cResult;
; 368  : 
; 369  :     // Allocate the output buffer, which needs to accommodate potentially
; 370  :     // 3X (in bytes) the input size (in chars).
; 371  :     //
; 372  :     utf8String	= string->factory->newStr8(string->factory, (pANTLR3_UINT8)"");

  00024	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00036	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  0003e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00041	ff 50 38	 call	 QWORD PTR [rax+56]
  00044	48 89 44 24 68	 mov	 QWORD PTR utf8String$[rsp], rax

; 373  : 
; 374  :     if	(utf8String != NULL)

  00049	48 83 7c 24 68
	00		 cmp	 QWORD PTR utf8String$[rsp], 0
  0004f	0f 84 e2 00 00
	00		 je	 $LN2@toUTF8_UTF

; 375  :     {
; 376  :         // Free existing allocation
; 377  :         //
; 378  :         ANTLR3_FREE(utf8String->chars);

  00055	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0005a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 379  : 
; 380  :         // Reallocate according to maximum expected size
; 381  :         //
; 382  :         utf8String->size	= string->len *3;

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0006c	6b 40 10 03	 imul	 eax, DWORD PTR [rax+16], 3
  00070	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  00075	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 383  :         utf8String->chars	= (pANTLR3_UINT8)ANTLR3_MALLOC(utf8String->size +1);

  00078	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0007d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00080	ff c0		 inc	 eax
  00082	8b c0		 mov	 eax, eax
  00084	8b c8		 mov	 ecx, eax
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0008c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  00091	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 384  : 
; 385  :         if	(utf8String->chars != NULL)

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0009a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0009f	0f 84 92 00 00
	00		 je	 $LN3@toUTF8_UTF

; 386  :         {
; 387  :             inputEnd  = (UTF16 *)	(string->chars);

  000a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  000ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b1	48 89 44 24 58	 mov	 QWORD PTR inputEnd$[rsp], rax

; 388  :             outputEnd = (UTF8 *)	(utf8String->chars);

  000b6	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  000bb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000bf	48 89 44 24 38	 mov	 QWORD PTR outputEnd$[rsp], rax

; 389  : 
; 390  :             // Call the Unicode converter
; 391  :             //
; 392  :             cResult =  ConvertUTF16toUTF8

  000c4	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  000c9	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000cc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR outputEnd$[rsp]
  000d1	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  000d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  000de	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000e1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR string$[rsp]
  000e9	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000ed	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  000f1	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f9	4c 8b c8	 mov	 r9, rax
  000fc	4c 8d 44 24 38	 lea	 r8, QWORD PTR outputEnd$[rsp]
  00101	48 8b d1	 mov	 rdx, rcx
  00104	48 8d 4c 24 58	 lea	 rcx, QWORD PTR inputEnd$[rsp]
  00109	e8 00 00 00 00	 call	 ConvertUTF16toUTF8
  0010e	89 44 24 70	 mov	 DWORD PTR cResult$[rsp], eax

; 393  :                 (
; 394  :                 (const UTF16**)&inputEnd, 
; 395  :                 ((const UTF16 *)(string->chars)) + string->len, 
; 396  :                 &outputEnd, 
; 397  :                 outputEnd + utf8String->size - 1,
; 398  :                 lenientConversion
; 399  :                 );
; 400  : 
; 401  :             // We don't really care if things failed or not here, we just converted
; 402  :             // everything that was vaguely possible and stopped when it wasn't. It is
; 403  :             // up to the grammar programmer to verify that the input is sensible.
; 404  :             //
; 405  :             utf8String->len = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)outputEnd) - utf8String->chars);

  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  00117	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR outputEnd$[rsp]
  00120	48 2b c8	 sub	 rcx, rax
  00123	48 8b c1	 mov	 rax, rcx
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  0012b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 406  : 
; 407  :             *(outputEnd+1) = '\0';		// Always null terminate

  0012e	48 8b 44 24 38	 mov	 rax, QWORD PTR outputEnd$[rsp]
  00133	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
$LN3@toUTF8_UTF:
$LN2@toUTF8_UTF:

; 408  :         }
; 409  :     }
; 410  :     return utf8String;

  00137	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]

; 411  : }

  0013c	48 8b f8	 mov	 rdi, rax
  0013f	48 8b cc	 mov	 rcx, rsp
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:toUTF8_UTF16$rtcFrameData
  00149	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0014e	48 8b c7	 mov	 rax, rdi
  00151	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
toUTF8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT toUTF8_8
_TEXT	SEGMENT
string$ = 48
toUTF8_8 PROC						; COMDAT

; 350  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 351  : 	return string->factory->newPtr(string->factory, (pANTLR3_UINT8)(string->chars), string->len);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00034	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0003d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00040	ff 50 20	 call	 QWORD PTR [rax+32]

; 352  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
toUTF8_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT to8_UTF16
_TEXT	SEGMENT
newStr$ = 32
i$ = 40
c$1 = 44
tv94 = 48
string$ = 80
to8_UTF16 PROC						; COMDAT

; 1366 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1367 : 	pANTLR3_STRING  newStr;
; 1368 : 	ANTLR3_UINT32   i;
; 1369 : 
; 1370 : 	/* Create a new 8 bit string
; 1371 : 	*/
; 1372 : 	newStr  = newRaw8(string->factory);

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00026	e8 00 00 00 00	 call	 newRaw8
  0002b	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1373 : 
; 1374 : 	if	(newStr == NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR newStr$[rsp], 0
  00036	75 07		 jne	 SHORT $LN5@to8_UTF16

; 1375 : 	{
; 1376 : 		return	NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 c3 00 00 00	 jmp	 $LN1@to8_UTF16
$LN5@to8_UTF16:

; 1377 : 	}
; 1378 : 
; 1379 : 	/* Always add one more byte for a terminator
; 1380 : 	*/
; 1381 : 	newStr->chars   = (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(string->len + 1));

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00044	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00047	ff c0		 inc	 eax
  00049	8b c0		 mov	 eax, eax
  0004b	8b c8		 mov	 ecx, eax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  00058	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1382 : 	newStr->size    = string->len + 1;

  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00061	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00064	ff c0		 inc	 eax
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  0006b	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1383 : 	newStr->len	    = string->len;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00078	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0007b	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1384 : 
; 1385 : 	/* Now copy each UTF16 charActer , making it an 8 bit character of 
; 1386 : 	* some sort.
; 1387 : 	*/
; 1388 : 	for	(i=0; i<string->len; i++)

  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00086	eb 0a		 jmp	 SHORT $LN4@to8_UTF16
$LN2@to8_UTF16:
  00088	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@to8_UTF16:
  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00097	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0009a	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0009e	73 48		 jae	 SHORT $LN3@to8_UTF16

; 1389 : 	{
; 1390 : 		ANTLR3_UCHAR	c;
; 1391 : 
; 1392 : 		c = *(((pANTLR3_UINT16)(string->chars)) + i);

  000a0	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000a9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ad	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000b1	89 44 24 2c	 mov	 DWORD PTR c$1[rsp], eax

; 1393 : 
; 1394 : 		*(newStr->chars + i) = (ANTLR3_UINT8)(c > 255 ? '_' : c);

  000b5	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR c$1[rsp], 255	; 000000ffH
  000bd	76 0a		 jbe	 SHORT $LN7@to8_UTF16
  000bf	c7 44 24 30 5f
	00 00 00	 mov	 DWORD PTR tv94[rsp], 95	; 0000005fH
  000c7	eb 08		 jmp	 SHORT $LN8@to8_UTF16
$LN7@to8_UTF16:
  000c9	8b 44 24 2c	 mov	 eax, DWORD PTR c$1[rsp]
  000cd	89 44 24 30	 mov	 DWORD PTR tv94[rsp], eax
$LN8@to8_UTF16:
  000d1	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  000da	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000de	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv94[rsp]
  000e3	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1395 : 	}

  000e6	eb a0		 jmp	 SHORT $LN2@to8_UTF16
$LN3@to8_UTF16:

; 1396 : 
; 1397 : 	/* Terminate
; 1398 : 	*/
; 1399 : 	*(newStr->chars + newStr->len) = '\0';

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
  000ed	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  000f5	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1400 : 
; 1401 : 	return newStr;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
$LN1@to8_UTF16:

; 1402 : }

  00102	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
to8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT to8_8
_TEXT	SEGMENT
string$ = 16
to8_8	PROC						; COMDAT

; 1356 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1357 :     return  string;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]

; 1358 : }

  0000b	5f		 pop	 rdi
  0000c	c3		 ret	 0
to8_8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT toInt32_UTF16
_TEXT	SEGMENT
input$ = 32
value$ = 40
negate$ = 44
tv85 = 48
string$ = 80
toInt32_UTF16 PROC					; COMDAT

; 1322 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1323 :     pANTLR3_UINT16  input;
; 1324 :     ANTLR3_INT32   value;
; 1325 :     ANTLR3_BOOLEAN  negate;
; 1326 : 
; 1327 :     value   = 0;

  0001e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR value$[rsp], 0

; 1328 :     input   = (pANTLR3_UINT16)(string->chars);

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0002b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002f	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1329 :     negate  = ANTLR3_FALSE;

  00034	c6 44 24 2c 00	 mov	 BYTE PTR negate$[rsp], 0

; 1330 : 
; 1331 :     if	(*input == (ANTLR3_UCHAR)'-')

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0003e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00041	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00044	75 15		 jne	 SHORT $LN4@toInt32_UT

; 1332 :     {
; 1333 : 		negate = ANTLR3_TRUE;

  00046	c6 44 24 2c 01	 mov	 BYTE PTR negate$[rsp], 1

; 1334 : 		input++;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00050	48 83 c0 02	 add	 rax, 2
  00054	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1335 :     }

  00059	eb 1b		 jmp	 SHORT $LN5@toInt32_UT
$LN4@toInt32_UT:

; 1336 :     else if (*input == (ANTLR3_UCHAR)'+')

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00060	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00063	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00066	75 0e		 jne	 SHORT $LN6@toInt32_UT

; 1337 :     {
; 1338 : 		input++;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0006d	48 83 c0 02	 add	 rax, 2
  00071	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax
$LN6@toInt32_UT:
$LN5@toInt32_UT:
$LN2@toInt32_UT:

; 1339 :     }
; 1340 : 
; 1341 :     while   (*input != '\0' && isdigit(*input))

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0007b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0007e	85 c0		 test	 eax, eax
  00080	74 41		 je	 SHORT $LN3@toInt32_UT
  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00087	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0008a	8b c8		 mov	 ecx, eax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00092	85 c0		 test	 eax, eax
  00094	74 2d		 je	 SHORT $LN3@toInt32_UT

; 1342 :     {
; 1343 : 		value	 = value * 10;

  00096	6b 44 24 28 0a	 imul	 eax, DWORD PTR value$[rsp], 10
  0009b	89 44 24 28	 mov	 DWORD PTR value$[rsp], eax

; 1344 : 		value	+= ((ANTLR3_UINT32)(*input) - (ANTLR3_UINT32)'0');

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  000a4	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a7	8b 4c 24 28	 mov	 ecx, DWORD PTR value$[rsp]
  000ab	8d 44 01 d0	 lea	 eax, DWORD PTR [rcx+rax-48]
  000af	89 44 24 28	 mov	 DWORD PTR value$[rsp], eax

; 1345 : 		input++;

  000b3	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  000b8	48 83 c0 02	 add	 rax, 2
  000bc	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1346 :     }

  000c1	eb b3		 jmp	 SHORT $LN2@toInt32_UT
$LN3@toInt32_UT:

; 1347 : 
; 1348 :     return negate ? -value : value;

  000c3	0f b6 44 24 2c	 movzx	 eax, BYTE PTR negate$[rsp]
  000c8	85 c0		 test	 eax, eax
  000ca	74 0c		 je	 SHORT $LN8@toInt32_UT
  000cc	8b 44 24 28	 mov	 eax, DWORD PTR value$[rsp]
  000d0	f7 d8		 neg	 eax
  000d2	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
  000d6	eb 08		 jmp	 SHORT $LN9@toInt32_UT
$LN8@toInt32_UT:
  000d8	8b 44 24 28	 mov	 eax, DWORD PTR value$[rsp]
  000dc	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
$LN9@toInt32_UT:
  000e0	8b 44 24 30	 mov	 eax, DWORD PTR tv85[rsp]

; 1349 : }

  000e4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
toInt32_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT toInt32_8
_TEXT	SEGMENT
string$ = 48
toInt32_8 PROC						; COMDAT

; 1314 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1315 :     return  atoi((const char *)(string->chars));

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi

; 1316 : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
toInt32_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT subStringUTF16
_TEXT	SEGMENT
newStr$ = 32
tv80 = 40
string$ = 64
startIndex$ = 72
endIndex$ = 80
subStringUTF16 PROC					; COMDAT

; 1298 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1299 :     pANTLR3_STRING newStr;
; 1300 : 
; 1301 :     if	(endIndex > string->len)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0002c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002f	39 44 24 50	 cmp	 DWORD PTR endIndex$[rsp], eax
  00033	76 0e		 jbe	 SHORT $LN2@subStringU

; 1302 :     {
; 1303 : 		endIndex = string->len + 1;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 50	 mov	 DWORD PTR endIndex$[rsp], eax
$LN2@subStringU:

; 1304 :     }
; 1305 :     newStr  = string->factory->newPtr(string->factory, (pANTLR3_UINT8)((pANTLR3_UINT16)(string->chars) + startIndex), endIndex - startIndex);

  00043	8b 44 24 48	 mov	 eax, DWORD PTR startIndex$[rsp]
  00047	8b 4c 24 50	 mov	 ecx, DWORD PTR endIndex$[rsp]
  0004b	2b c8		 sub	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	8b 4c 24 48	 mov	 ecx, DWORD PTR startIndex$[rsp]
  00053	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00058	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0005c	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00060	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00065	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00068	48 89 54 24 28	 mov	 QWORD PTR tv80[rsp], rdx
  0006d	44 8b c0	 mov	 r8d, eax
  00070	48 8b d1	 mov	 rdx, rcx
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00078	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv80[rsp]
  00080	ff 50 20	 call	 QWORD PTR [rax+32]
  00083	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1306 : 
; 1307 :     return newStr;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]

; 1308 : }

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
subStringUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT subString8
_TEXT	SEGMENT
newStr$ = 32
tv79 = 40
string$ = 64
startIndex$ = 72
endIndex$ = 80
subString8 PROC						; COMDAT

; 1281 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1282 :     pANTLR3_STRING newStr;
; 1283 : 
; 1284 :     if	(endIndex > string->len)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0002c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002f	39 44 24 50	 cmp	 DWORD PTR endIndex$[rsp], eax
  00033	76 0e		 jbe	 SHORT $LN2@subString8

; 1285 :     {
; 1286 : 		endIndex = string->len + 1;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 50	 mov	 DWORD PTR endIndex$[rsp], eax
$LN2@subString8:

; 1287 :     }
; 1288 :     newStr  = string->factory->newPtr(string->factory, string->chars + startIndex, endIndex - startIndex);

  00043	8b 44 24 48	 mov	 eax, DWORD PTR startIndex$[rsp]
  00047	8b 4c 24 50	 mov	 ecx, DWORD PTR endIndex$[rsp]
  0004b	2b c8		 sub	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	8b 4c 24 48	 mov	 ecx, DWORD PTR startIndex$[rsp]
  00053	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00058	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  0005c	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00061	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00064	48 89 54 24 28	 mov	 QWORD PTR tv79[rsp], rdx
  00069	44 8b c0	 mov	 r8d, eax
  0006c	48 8b d1	 mov	 rdx, rcx
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00074	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR tv79[rsp]
  0007c	ff 50 20	 call	 QWORD PTR [rax+32]
  0007f	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1289 : 
; 1290 :     return newStr;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]

; 1291 : }

  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
subString8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT charAtUTF16
_TEXT	SEGMENT
string$ = 16
offset$ = 24
charAtUTF16 PROC					; COMDAT

; 1265 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1266 :     if	(offset > string->len)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00012	39 44 24 18	 cmp	 DWORD PTR offset$[rsp], eax
  00016	76 06		 jbe	 SHORT $LN2@charAtUTF1

; 1267 :     {
; 1268 : 		return (ANTLR3_UCHAR)'\0';

  00018	33 c0		 xor	 eax, eax
  0001a	eb 13		 jmp	 SHORT $LN1@charAtUTF1

; 1269 :     }

  0001c	eb 11		 jmp	 SHORT $LN3@charAtUTF1
$LN2@charAtUTF1:

; 1270 :     else
; 1271 :     {
; 1272 : 		return  (ANTLR3_UCHAR)(*((pANTLR3_UINT16)(string->chars) + offset));

  0001e	8b 44 24 18	 mov	 eax, DWORD PTR offset$[rsp]
  00022	48 8b 4c 24 10	 mov	 rcx, QWORD PTR string$[rsp]
  00027	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002b	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
$LN3@charAtUTF1:
$LN1@charAtUTF1:

; 1273 :     }
; 1274 : }

  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
charAtUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT charAt8
_TEXT	SEGMENT
string$ = 16
offset$ = 24
charAt8	PROC						; COMDAT

; 1249 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1250 :     if	(offset > string->len)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00012	39 44 24 18	 cmp	 DWORD PTR offset$[rsp], eax
  00016	76 06		 jbe	 SHORT $LN2@charAt8

; 1251 :     {
; 1252 : 		return (ANTLR3_UCHAR)'\0';

  00018	33 c0		 xor	 eax, eax
  0001a	eb 13		 jmp	 SHORT $LN1@charAt8

; 1253 :     }

  0001c	eb 11		 jmp	 SHORT $LN3@charAt8
$LN2@charAt8:

; 1254 :     else
; 1255 :     {
; 1256 : 		return  (ANTLR3_UCHAR)(*(string->chars + offset));

  0001e	8b 44 24 18	 mov	 eax, DWORD PTR offset$[rsp]
  00022	48 8b 4c 24 10	 mov	 rcx, QWORD PTR string$[rsp]
  00027	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
$LN3@charAt8:
$LN1@charAt8:

; 1257 :     }
; 1258 : }

  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
charAt8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT compareS
_TEXT	SEGMENT
string$ = 48
compStr$ = 56
compareS PROC						; COMDAT

; 1239 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1240 :     return  string->compare(string, (const char *)compStr->chars);

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR compStr$[rsp]
  00028	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00036	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1241 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
compareS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT compareUTF16_UTF16
_TEXT	SEGMENT
ourString$ = 0
compStr$ = 8
charDiff$ = 16
string$ = 48
compStr8$ = 56
compareUTF16_UTF16 PROC					; COMDAT

; 1209 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1210 :     pANTLR3_UINT16  ourString;
; 1211 :     pANTLR3_UINT16  compStr;
; 1212 :     ANTLR3_UINT32   charDiff;
; 1213 : 
; 1214 :     ourString	= (pANTLR3_UINT16)(string->chars);

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00028	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002c	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1215 :     compStr	= (pANTLR3_UINT16)(compStr8);

  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR compStr8$[rsp]
  00035	48 89 44 24 08	 mov	 QWORD PTR compStr$[rsp], rax
$LN2@compareUTF:

; 1216 : 
; 1217 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)compStr)) != '\0'))

  0003a	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  0003e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00041	85 c0		 test	 eax, eax
  00043	74 4a		 je	 SHORT $LN3@compareUTF
  00045	48 8b 44 24 08	 mov	 rax, QWORD PTR compStr$[rsp]
  0004a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004d	85 c0		 test	 eax, eax
  0004f	74 3e		 je	 SHORT $LN3@compareUTF

; 1218 :     {
; 1219 : 		charDiff = *ourString - *compStr;

  00051	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00055	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00058	48 8b 4c 24 08	 mov	 rcx, QWORD PTR compStr$[rsp]
  0005d	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00060	2b c1		 sub	 eax, ecx
  00062	89 44 24 10	 mov	 DWORD PTR charDiff$[rsp], eax

; 1220 : 		if  (charDiff != 0)

  00066	83 7c 24 10 00	 cmp	 DWORD PTR charDiff$[rsp], 0
  0006b	74 06		 je	 SHORT $LN4@compareUTF

; 1221 : 		{
; 1222 : 			return charDiff;

  0006d	8b 44 24 10	 mov	 eax, DWORD PTR charDiff$[rsp]
  00071	eb 2d		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1223 : 		}
; 1224 : 		ourString++;

  00073	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00077	48 83 c0 02	 add	 rax, 2
  0007b	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1225 : 		compStr++;

  0007f	48 8b 44 24 08	 mov	 rax, QWORD PTR compStr$[rsp]
  00084	48 83 c0 02	 add	 rax, 2
  00088	48 89 44 24 08	 mov	 QWORD PTR compStr$[rsp], rax

; 1226 :     }

  0008d	eb ab		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1227 : 
; 1228 :     /* At this point, one of the strings was terminated
; 1229 :      */
; 1230 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  0008f	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00093	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00096	48 8b 4c 24 08	 mov	 rcx, QWORD PTR compStr$[rsp]
  0009b	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0009e	2b c1		 sub	 eax, ecx
$LN1@compareUTF:

; 1231 : }

  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
compareUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT compareUTF16_8
_TEXT	SEGMENT
ourString$ = 0
charDiff$ = 8
string$ = 32
compStr$ = 40
compareUTF16_8 PROC					; COMDAT

; 1180 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 1181 :     pANTLR3_UINT16  ourString;
; 1182 :     ANTLR3_UINT32   charDiff;
; 1183 : 
; 1184 :     ourString	= (pANTLR3_UINT16)(string->chars);

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00028	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002c	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax
$LN2@compareUTF:

; 1185 : 
; 1186 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*compStr) != '\0'))

  00030	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00034	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00037	85 c0		 test	 eax, eax
  00039	74 49		 je	 SHORT $LN3@compareUTF
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR compStr$[rsp]
  00040	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00043	85 c0		 test	 eax, eax
  00045	74 3d		 je	 SHORT $LN3@compareUTF

; 1187 :     {
; 1188 : 		charDiff = *ourString - *compStr;

  00047	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  0004b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR compStr$[rsp]
  00053	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00056	2b c1		 sub	 eax, ecx
  00058	89 44 24 08	 mov	 DWORD PTR charDiff$[rsp], eax

; 1189 : 		if  (charDiff != 0)

  0005c	83 7c 24 08 00	 cmp	 DWORD PTR charDiff$[rsp], 0
  00061	74 06		 je	 SHORT $LN4@compareUTF

; 1190 : 		{
; 1191 : 			return charDiff;

  00063	8b 44 24 08	 mov	 eax, DWORD PTR charDiff$[rsp]
  00067	eb 2c		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1192 : 		}
; 1193 : 		ourString++;

  00069	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  0006d	48 83 c0 02	 add	 rax, 2
  00071	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1194 : 		compStr++;

  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR compStr$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 44 24 28	 mov	 QWORD PTR compStr$[rsp], rax

; 1195 :     }

  00082	eb ac		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1196 : 
; 1197 :     /* At this point, one of the strings was terminated
; 1198 :      */
; 1199 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  00084	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00088	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR compStr$[rsp]
  00090	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00093	2b c1		 sub	 eax, ecx
$LN1@compareUTF:

; 1200 : 
; 1201 : }

  00095	48 83 c4 10	 add	 rsp, 16
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
compareUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT compare8
_TEXT	SEGMENT
string$ = 48
compStr$ = 56
compare8 PROC						; COMDAT

; 1170 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1171 :     return  strcmp((const char *)(string->chars), compStr);

  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR compStr$[rsp]
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0002d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00031	e8 00 00 00 00	 call	 strcmp

; 1172 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
compare8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT insertiUTF16
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
point$ = 136
i$ = 144
insertiUTF16 PROC					; COMDAT

; 1012 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 1c 00 00 00	 mov	 ecx, 28
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1013 :     ANTLR3_UINT8	    newbit[32];
; 1014 : 
; 1015 :     sprintf((char *)newbit, "%d", i);

  00039	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00048	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004d	e8 00 00 00 00	 call	 sprintf

; 1016 :     return  string->insert8(string, point, (const char *)newbit);

  00052	4c 8d 44 24 28	 lea	 r8, QWORD PTR newbit$[rsp]
  00057	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR point$[rsp]
  0005e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0006e	ff 50 48	 call	 QWORD PTR [rax+72]

; 1017 : }

  00071	48 8b f8	 mov	 rdi, rax
  00074	48 8b cc	 mov	 rcx, rsp
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:insertiUTF16$rtcFrameData
  0007e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00083	48 8b c7	 mov	 rax, rdi
  00086	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
insertiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT inserti8
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
point$ = 136
i$ = 144
inserti8 PROC						; COMDAT

; 1004 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 1c 00 00 00	 mov	 ecx, 28
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1005 :     ANTLR3_UINT8	    newbit[32];
; 1006 : 
; 1007 :     sprintf((char *)newbit, "%d", i);

  00039	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00048	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004d	e8 00 00 00 00	 call	 sprintf

; 1008 :     return  string->insert8(string, point, (const char *)newbit);

  00052	4c 8d 44 24 28	 lea	 r8, QWORD PTR newbit$[rsp]
  00057	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR point$[rsp]
  0005e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0006e	ff 50 48	 call	 QWORD PTR [rax+72]

; 1009 : }

  00071	48 8b f8	 mov	 rdi, rax
  00074	48 8b cc	 mov	 rcx, rsp
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inserti8$rtcFrameData
  0007e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00083	48 8b c7	 mov	 rax, rdi
  00086	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
inserti8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT addiUTF16
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
i$ = 136
addiUTF16 PROC						; COMDAT

; 994  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 1c 00 00 00	 mov	 ecx, 28
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 995  :     ANTLR3_UINT8	    newbit[32];
; 996  : 
; 997  :     sprintf((char *)newbit, "%d", i);

  00034	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00043	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  00048	e8 00 00 00 00	 call	 sprintf

; 998  : 
; 999  :     return  string->append8(string, (const char *)newbit);

  0004d	48 8d 54 24 28	 lea	 rdx, QWORD PTR newbit$[rsp]
  00052	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00062	ff 50 38	 call	 QWORD PTR [rax+56]

; 1000 : }

  00065	48 8b f8	 mov	 rdi, rax
  00068	48 8b cc	 mov	 rcx, rsp
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addiUTF16$rtcFrameData
  00072	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00077	48 8b c7	 mov	 rax, rdi
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007f	48 33 cc	 xor	 rcx, rsp
  00082	e8 00 00 00 00	 call	 __security_check_cookie
  00087	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
addiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT addi8
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
i$ = 136
addi8	PROC						; COMDAT

; 985  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 1c 00 00 00	 mov	 ecx, 28
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 986  :     ANTLR3_UINT8	    newbit[32];
; 987  : 
; 988  :     sprintf((char *)newbit, "%d", i);

  00034	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00043	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  00048	e8 00 00 00 00	 call	 sprintf

; 989  : 
; 990  :     return  string->append8(string, (const char *)newbit);

  0004d	48 8d 54 24 28	 lea	 rdx, QWORD PTR newbit$[rsp]
  00052	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00062	ff 50 38	 call	 QWORD PTR [rax+56]

; 991  : }

  00065	48 8b f8	 mov	 rdi, rax
  00068	48 8b cc	 mov	 rcx, rsp
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addi8$rtcFrameData
  00072	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00077	48 8b c7	 mov	 rax, rdi
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007f	48 33 cc	 xor	 rcx, rsp
  00082	e8 00 00 00 00	 call	 __security_check_cookie
  00087	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
addi8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT addcUTF16
_TEXT	SEGMENT
ptr$ = 32
string$ = 64
c$ = 72
addcUTF16 PROC						; COMDAT

; 966  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 967  :     pANTLR3_UINT16  ptr;
; 968  : 
; 969  :     if	(string->size < string->len + 2)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00027	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002a	83 c0 02	 add	 eax, 2
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00032	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00035	73 3f		 jae	 SHORT $LN2@addcUTF16

; 970  :     {
; 971  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16) * (string->len + 2)));

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003f	83 c0 02	 add	 eax, 2
  00042	8b c0		 mov	 eax, eax
  00044	48 d1 e0	 shl	 rax, 1
  00047	8b c0		 mov	 eax, eax
  00049	8b d0		 mov	 edx, eax
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00050	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0005f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 972  : 		string->size	= string->len + 2;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00068	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006b	83 c0 02	 add	 eax, 2
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00073	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@addcUTF16:

; 973  :     }
; 974  :     ptr	= (pANTLR3_UINT16)(string->chars);

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0007b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007f	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 975  : 
; 976  :     *(ptr + string->len)	= (ANTLR3_UINT16)c;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00089	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00091	0f b7 54 24 48	 movzx	 edx, WORD PTR c$[rsp]
  00096	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 977  :     *(ptr + string->len + 1)	= '\0';

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0009f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a2	33 c9		 xor	 ecx, ecx
  000a4	48 8b 54 24 20	 mov	 rdx, QWORD PTR ptr$[rsp]
  000a9	66 89 4c 42 02	 mov	 WORD PTR [rdx+rax*2+2], cx

; 978  :     string->len++;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000b3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b6	ff c0		 inc	 eax
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000bd	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 979  : 
; 980  :     return  string->chars;

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000c5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 981  : }

  000c9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
addcUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT addc8
_TEXT	SEGMENT
string$ = 48
c$ = 56
addc8	PROC						; COMDAT

; 951  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 952  :     if	(string->size < string->len + 2)

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00027	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002a	83 c0 02	 add	 eax, 2
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00032	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00035	73 3a		 jae	 SHORT $LN2@addc8

; 953  :     {
; 954  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + 2));

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0003c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003f	83 c0 02	 add	 eax, 2
  00042	8b c0		 mov	 eax, eax
  00044	8b d0		 mov	 edx, eax
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0004b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0005a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 955  : 		string->size	= string->len + 2;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00063	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00066	83 c0 02	 add	 eax, 2
  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0006e	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@addc8:

; 956  :     }
; 957  :     *(string->chars + string->len)	= (ANTLR3_UINT8)c;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00076	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0007e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00082	0f b6 54 24 38	 movzx	 edx, BYTE PTR c$[rsp]
  00087	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 958  :     *(string->chars + string->len + 1)	= '\0';

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0008f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00097	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009b	c6 44 01 01 00	 mov	 BYTE PTR [rcx+rax+1], 0

; 959  :     string->len++;

  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  000a5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a8	ff c0		 inc	 eax
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  000af	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 960  : 
; 961  :     return  string->chars;

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  000b7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 962  : }

  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
addc8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT insertS
_TEXT	SEGMENT
string$ = 48
point$ = 56
newbit$ = 64
insertS	PROC						; COMDAT

; 1161 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1162 :     return  string->insert(string, point, (const char *)(newbit->chars));

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR newbit$[rsp]
  0002c	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00030	8b 54 24 38	 mov	 edx, DWORD PTR point$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0003e	ff 50 40	 call	 QWORD PTR [rax+64]

; 1163 : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
insertS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT appendS
_TEXT	SEGMENT
string$ = 48
newbit$ = 56
appendS	PROC						; COMDAT

; 1147 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1148 :     /* We may be passed an empty string, in which case we just return the current pointer
; 1149 :      */
; 1150 :     if	(newbit == NULL || newbit->len == 0 || newbit->size == 0 || newbit->chars == NULL)

  00023	48 83 7c 24 38
	00		 cmp	 QWORD PTR newbit$[rsp], 0
  00029	74 22		 je	 SHORT $LN4@appendS
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  00030	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00034	74 17		 je	 SHORT $LN4@appendS
  00036	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  0003b	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0003f	74 0c		 je	 SHORT $LN4@appendS
  00041	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  00046	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004b	75 0d		 jne	 SHORT $LN2@appendS
$LN4@appendS:

; 1151 :     {
; 1152 : 		return	string->chars;

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	eb 18		 jmp	 SHORT $LN1@appendS

; 1153 :     }

  00058	eb 16		 jmp	 SHORT $LN3@appendS
$LN2@appendS:

; 1154 :     else
; 1155 :     {
; 1156 : 		return  string->append(string, (const char *)(newbit->chars));

  0005a	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  0005f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0006d	ff 50 30	 call	 QWORD PTR [rax+48]
$LN3@appendS:
$LN1@appendS:

; 1157 :     }
; 1158 : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
appendS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT setS
_TEXT	SEGMENT
string$ = 48
chars$ = 56
setS	PROC						; COMDAT

; 1142 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1143 :     return  string->set(string, (const char *)(chars->chars));

  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR chars$[rsp]
  00028	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00036	ff 50 20	 call	 QWORD PTR [rax+32]

; 1144 : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
setS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT insertUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
tv73 = 48
tv74 = 52
tv155 = 56
string$ = 80
point$ = 88
newbit$ = 96
insertUTF16_UTF16 PROC					; COMDAT

; 1097 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1098 :     ANTLR3_UINT32	len;
; 1099 :     pANTLR3_UINT16	in;
; 1100 : 
; 1101 :     if	(point >= string->len)

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0002c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002f	39 44 24 58	 cmp	 DWORD PTR point$[rsp], eax
  00033	72 17		 jb	 SHORT $LN4@insertUTF1

; 1102 :     {
; 1103 : 		return	string->append(string, newbit);

  00035	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00044	ff 50 30	 call	 QWORD PTR [rax+48]
  00047	e9 70 01 00 00	 jmp	 $LN1@insertUTF1
$LN4@insertUTF1:

; 1104 :     }
; 1105 :  
; 1106 :     /** First, determine the length of the input string
; 1107 :      */
; 1108 :     in	    = (pANTLR3_UINT16)newbit;

  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR newbit$[rsp]
  00051	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 1109 :     len	    = 0;

  00056	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@insertUTF1:

; 1110 : 
; 1111 :     while   (*in++ != '\0')

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00063	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00066	89 44 24 30	 mov	 DWORD PTR tv73[rsp], eax
  0006a	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0006f	48 83 c0 02	 add	 rax, 2
  00073	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  00078	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  0007d	74 0a		 je	 SHORT $LN8@insertUTF1
  0007f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00087	eb 08		 jmp	 SHORT $LN9@insertUTF1
$LN8@insertUTF1:
  00089	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN9@insertUTF1:
  00091	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00096	74 0c		 je	 SHORT $LN3@insertUTF1

; 1112 :     {
; 1113 : 		len++;

  00098	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1114 :     }

  000a2	eb ba		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1115 : 
; 1116 :     if	(len == 0)

  000a4	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  000a9	75 0e		 jne	 SHORT $LN5@insertUTF1

; 1117 :     {
; 1118 : 		return	string->chars;

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b4	e9 03 01 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1119 :     }
; 1120 : 
; 1121 :     if	(string->size < (string->len + len + 1))

  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000be	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c1	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000c5	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000ce	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  000d1	73 49		 jae	 SHORT $LN6@insertUTF1

; 1122 :     {
; 1123 : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000d8	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000db	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000df	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000e3	8b c0		 mov	 eax, eax
  000e5	48 d1 e0	 shl	 rax, 1
  000e8	8b c0		 mov	 eax, eax
  000ea	8b d0		 mov	 edx, eax
  000ec	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00100	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1124 : 		string->size	= string->len + len + 1;

  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00109	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0010c	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00110	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00114	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00119	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN6@insertUTF1:

; 1125 :     }
; 1126 : 
; 1127 :     /* Move the characters we are inserting before, including the delimiter
; 1128 :      */
; 1129 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  0011c	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00121	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  00125	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00128	2b c1		 sub	 eax, ecx
  0012a	ff c0		 inc	 eax
  0012c	8b c0		 mov	 eax, eax
  0012e	48 d1 e0	 shl	 rax, 1
  00131	8b c0		 mov	 eax, eax
  00133	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  00137	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  0013c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00140	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00144	8b 54 24 58	 mov	 edx, DWORD PTR point$[rsp]
  00148	4c 8b 44 24 50	 mov	 r8, QWORD PTR string$[rsp]
  0014d	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00151	49 8d 14 50	 lea	 rdx, QWORD PTR [r8+rdx*2]
  00155	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0015a	4a 8d 14 42	 lea	 rdx, QWORD PTR [rdx+r8*2]
  0015e	48 89 54 24 38	 mov	 QWORD PTR tv155[rsp], rdx
  00163	44 8b c0	 mov	 r8d, eax
  00166	48 8b d1	 mov	 rdx, rcx
  00169	48 8b 44 24 38	 mov	 rax, QWORD PTR tv155[rsp]
  0016e	48 8b c8	 mov	 rcx, rax
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1130 : 
; 1131 : 
; 1132 :     /* Note we copy the exact number of characters
; 1133 :      */
; 1134 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len)));

  00177	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0017b	48 d1 e0	 shl	 rax, 1
  0017e	8b c0		 mov	 eax, eax
  00180	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  00184	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  00189	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0018d	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00191	44 8b c0	 mov	 r8d, eax
  00194	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1135 :     
; 1136 :     string->len += len;

  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  001a4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001a7	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  001ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  001b0	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1137 : 
; 1138 :     return  string->chars;

  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  001b8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insertUTF1:

; 1139 : }

  001bc	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c0	5f		 pop	 rdi
  001c1	c3		 ret	 0
insertUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT insertUTF16_8
_TEXT	SEGMENT
len$ = 32
count$ = 36
inPoint$ = 40
tv151 = 48
string$ = 80
point$ = 88
newbit$ = 96
insertUTF16_8 PROC					; COMDAT

; 1057 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1058 :     ANTLR3_UINT32	len;
; 1059 :     ANTLR3_UINT32	count;
; 1060 :     pANTLR3_UINT16	inPoint;
; 1061 : 
; 1062 :     if	(point >= string->len)

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0002c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002f	39 44 24 58	 cmp	 DWORD PTR point$[rsp], eax
  00033	72 17		 jb	 SHORT $LN5@insertUTF1

; 1063 :     {
; 1064 : 		return	string->append8(string, newbit);

  00035	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00044	ff 50 38	 call	 QWORD PTR [rax+56]
  00047	e9 4f 01 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1065 :     }
; 1066 :  
; 1067 :     len	= (ANTLR3_UINT32)strlen(newbit);

  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newbit$[rsp]
  00051	e8 00 00 00 00	 call	 strlen
  00056	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1068 : 
; 1069 :     if	(len == 0)

  0005a	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0005f	75 0e		 jne	 SHORT $LN6@insertUTF1

; 1070 :     {
; 1071 : 		return	string->chars;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00066	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006a	e9 2c 01 00 00	 jmp	 $LN1@insertUTF1
$LN6@insertUTF1:

; 1072 :     }
; 1073 : 
; 1074 :     if	(string->size < (string->len + len + 1))

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00074	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00077	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0007b	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0007f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00084	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00087	73 49		 jae	 SHORT $LN7@insertUTF1

; 1075 :     {
; 1076 : 	string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0008e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00091	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00095	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00099	8b c0		 mov	 eax, eax
  0009b	48 d1 e0	 shl	 rax, 1
  0009e	8b c0		 mov	 eax, eax
  000a0	8b d0		 mov	 edx, eax
  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000a7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000b6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1077 : 	string->size	= string->len + len + 1;

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000bf	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c2	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000c6	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000cf	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN7@insertUTF1:

; 1078 :     }
; 1079 : 
; 1080 :     /* Move the characters we are inserting before, including the delimiter
; 1081 :      */
; 1082 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000d7	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000db	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000de	2b c1		 sub	 eax, ecx
  000e0	ff c0		 inc	 eax
  000e2	8b c0		 mov	 eax, eax
  000e4	48 d1 e0	 shl	 rax, 1
  000e7	8b c0		 mov	 eax, eax
  000e9	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000ed	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  000f2	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000f6	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  000fa	8b 54 24 58	 mov	 edx, DWORD PTR point$[rsp]
  000fe	4c 8b 44 24 50	 mov	 r8, QWORD PTR string$[rsp]
  00103	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00107	49 8d 14 50	 lea	 rdx, QWORD PTR [r8+rdx*2]
  0010b	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00110	4a 8d 14 42	 lea	 rdx, QWORD PTR [rdx+r8*2]
  00114	48 89 54 24 30	 mov	 QWORD PTR tv151[rsp], rdx
  00119	44 8b c0	 mov	 r8d, eax
  0011c	48 8b d1	 mov	 rdx, rcx
  0011f	48 8b 44 24 30	 mov	 rax, QWORD PTR tv151[rsp]
  00124	48 8b c8	 mov	 rcx, rax
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1083 : 
; 1084 :     string->len += len;

  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00132	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00135	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0013e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1085 :     
; 1086 :     inPoint = ((pANTLR3_UINT16)(string->chars))+point;

  00141	8b 44 24 58	 mov	 eax, DWORD PTR point$[rsp]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0014a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0014e	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00152	48 89 44 24 28	 mov	 QWORD PTR inPoint$[rsp], rax

; 1087 :     for	(count = 0; count<len; count++)

  00157	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  0015f	eb 0a		 jmp	 SHORT $LN4@insertUTF1
$LN2@insertUTF1:
  00161	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00165	ff c0		 inc	 eax
  00167	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
$LN4@insertUTF1:
  0016b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0016f	39 44 24 24	 cmp	 DWORD PTR count$[rsp], eax
  00173	73 1d		 jae	 SHORT $LN3@insertUTF1

; 1088 :     {
; 1089 : 		*(inPoint + count) = (ANTLR3_UINT16)(*(newbit+count));

  00175	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00179	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newbit$[rsp]
  0017e	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  00183	8b 4c 24 24	 mov	 ecx, DWORD PTR count$[rsp]
  00187	48 8b 54 24 28	 mov	 rdx, QWORD PTR inPoint$[rsp]
  0018c	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 1090 :     }

  00190	eb cf		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1091 : 
; 1092 :     return  string->chars;

  00192	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00197	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insertUTF1:

; 1093 : }

  0019b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0019f	5f		 pop	 rdi
  001a0	c3		 ret	 0
insertUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT insert8
_TEXT	SEGMENT
len$ = 32
tv142 = 40
string$ = 64
point$ = 72
newbit$ = 80
insert8	PROC						; COMDAT

; 1021 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1022 :     ANTLR3_UINT32	len;
; 1023 : 
; 1024 :     if	(point >= string->len)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0002c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002f	39 44 24 48	 cmp	 DWORD PTR point$[rsp], eax
  00033	72 17		 jb	 SHORT $LN2@insert8

; 1025 :     {
; 1026 : 		return	string->append(string, newbit);

  00035	48 8b 54 24 50	 mov	 rdx, QWORD PTR newbit$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00044	ff 50 30	 call	 QWORD PTR [rax+48]
  00047	e9 10 01 00 00	 jmp	 $LN1@insert8
$LN2@insert8:

; 1027 :     }
; 1028 :  
; 1029 :     len	= (ANTLR3_UINT32)strlen(newbit);

  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newbit$[rsp]
  00051	e8 00 00 00 00	 call	 strlen
  00056	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1030 : 
; 1031 :     if	(len == 0)

  0005a	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0005f	75 0e		 jne	 SHORT $LN3@insert8

; 1032 :     {
; 1033 : 		return	string->chars;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00066	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006a	e9 ed 00 00 00	 jmp	 $LN1@insert8
$LN3@insert8:

; 1034 :     }
; 1035 : 
; 1036 :     if	(string->size < (string->len + len + 1))

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00074	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00077	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0007b	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00084	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00087	73 44		 jae	 SHORT $LN4@insert8

; 1037 :     {
; 1038 : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0008e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00091	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00095	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00099	8b c0		 mov	 eax, eax
  0009b	8b d0		 mov	 edx, eax
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000b1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1039 : 		string->size	= string->len + len + 1;

  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000ba	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000bd	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000c1	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000ca	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@insert8:

; 1040 :     }
; 1041 : 
; 1042 :     /* Move the characters we are inserting before, including the delimiter
; 1043 :      */
; 1044 :     ANTLR3_MEMMOVE((void *)(string->chars + point + len), (void *)(string->chars + point), (ANTLR3_UINT32)(string->len - point + 1));

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000d2	8b 4c 24 48	 mov	 ecx, DWORD PTR point$[rsp]
  000d6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000d9	2b c1		 sub	 eax, ecx
  000db	ff c0		 inc	 eax
  000dd	8b c0		 mov	 eax, eax
  000df	8b 4c 24 48	 mov	 ecx, DWORD PTR point$[rsp]
  000e3	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  000e8	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  000ec	8b 54 24 48	 mov	 edx, DWORD PTR point$[rsp]
  000f0	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  000f5	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  000f9	4c 03 c2	 add	 r8, rdx
  000fc	49 8b d0	 mov	 rdx, r8
  000ff	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00104	49 03 d0	 add	 rdx, r8
  00107	48 89 54 24 28	 mov	 QWORD PTR tv142[rsp], rdx
  0010c	44 8b c0	 mov	 r8d, eax
  0010f	48 8b d1	 mov	 rdx, rcx
  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR tv142[rsp]
  00117	48 8b c8	 mov	 rcx, rax
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1045 : 
; 1046 :     /* Note we copy the exact number of bytes
; 1047 :      */
; 1048 :     ANTLR3_MEMMOVE((void *)(string->chars + point), newbit, (ANTLR3_UINT32)(len));

  00120	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00124	8b 4c 24 48	 mov	 ecx, DWORD PTR point$[rsp]
  00128	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  0012d	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  00131	44 8b c0	 mov	 r8d, eax
  00134	48 8b 54 24 50	 mov	 rdx, QWORD PTR newbit$[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1049 :     
; 1050 :     string->len += len;

  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00144	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00147	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00150	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1051 : 
; 1052 :     return  string->chars;

  00153	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00158	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insert8:

; 1053 : }

  0015c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00160	5f		 pop	 rdi
  00161	c3		 ret	 0
insert8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT appendUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
tv67 = 48
tv68 = 52
string$ = 80
newbit$ = 88
appendUTF16_UTF16 PROC					; COMDAT

; 844  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 845  :     ANTLR3_UINT32 len;
; 846  :     pANTLR3_UINT16  in;
; 847  : 
; 848  :     /** First, determine the length of the input string
; 849  :      */
; 850  :     in	    = (pANTLR3_UINT16)newbit;

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR newbit$[rsp]
  00028	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 851  :     len   = 0;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@appendUTF1:

; 852  : 
; 853  :     while   (*in++ != '\0')

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0003a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0003d	89 44 24 30	 mov	 DWORD PTR tv67[rsp], eax
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00046	48 83 c0 02	 add	 rax, 2
  0004a	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  0004f	83 7c 24 30 00	 cmp	 DWORD PTR tv67[rsp], 0
  00054	74 0a		 je	 SHORT $LN6@appendUTF1
  00056	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0005e	eb 08		 jmp	 SHORT $LN7@appendUTF1
$LN6@appendUTF1:
  00060	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN7@appendUTF1:
  00068	83 7c 24 34 00	 cmp	 DWORD PTR tv68[rsp], 0
  0006d	74 0c		 je	 SHORT $LN3@appendUTF1

; 854  :     {
; 855  : 		len++;

  0006f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 856  :     }

  00079	eb ba		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 857  : 
; 858  :     if	(string->size < (string->len + len + 1))

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00080	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00083	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00087	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0008b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00090	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00093	73 49		 jae	 SHORT $LN4@appendUTF1

; 859  :     {
; 860  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)( sizeof(ANTLR3_UINT16) *(string->len + len + 1) ));

  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0009a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0009d	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000a1	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000a5	8b c0		 mov	 eax, eax
  000a7	48 d1 e0	 shl	 rax, 1
  000aa	8b c0		 mov	 eax, eax
  000ac	8b d0		 mov	 edx, eax
  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000c2	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 861  : 		string->size	= string->len + len + 1;

  000c6	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000cb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000d2	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000db	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@appendUTF1:

; 862  :     }
; 863  : 
; 864  :     /* Note we copy one more byte than the strlen in order to get the trailing delimiter
; 865  :      */
; 866  :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + string->len), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len+1)));

  000de	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000e2	ff c0		 inc	 eax
  000e4	8b c0		 mov	 eax, eax
  000e6	48 d1 e0	 shl	 rax, 1
  000e9	8b c0		 mov	 eax, eax
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000f0	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000f3	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  000f8	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000fc	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00100	44 8b c0	 mov	 r8d, eax
  00103	48 8b 54 24 58	 mov	 rdx, QWORD PTR newbit$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 867  :     string->len	+= len;

  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00113	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00116	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0011f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 868  : 
; 869  :     return string->chars;

  00122	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00127	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 870  : }

  0012b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0012f	5f		 pop	 rdi
  00130	c3		 ret	 0
appendUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT appendUTF16_8
_TEXT	SEGMENT
len$ = 32
apPoint$ = 40
count$ = 48
string$ = 80
newbit$ = 88
appendUTF16_8 PROC					; COMDAT

; 817  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 818  :     ANTLR3_UINT32   len;
; 819  :     pANTLR3_UINT16  apPoint;
; 820  :     ANTLR3_UINT32   count;
; 821  : 
; 822  :     len	= (ANTLR3_UINT32)strlen(newbit);

  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR newbit$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 823  : 
; 824  :     if	(string->size < (string->len + len + 1))

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00036	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00039	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0003d	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00046	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00049	73 49		 jae	 SHORT $LN5@appendUTF1

; 825  :     {
; 826  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)((sizeof(ANTLR3_UINT16)*(string->len + len + 1))));

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00050	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00057	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0005b	8b c0		 mov	 eax, eax
  0005d	48 d1 e0	 shl	 rax, 1
  00060	8b c0		 mov	 eax, eax
  00062	8b d0		 mov	 edx, eax
  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00069	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00078	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 827  : 		string->size	= string->len + len + 1;

  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00081	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00084	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00088	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00091	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN5@appendUTF1:

; 828  :     }
; 829  : 
; 830  :     apPoint = ((pANTLR3_UINT16)string->chars) + string->len;

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00099	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000a1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a5	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  000a9	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 831  :     string->len	+= len;

  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b6	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000bf	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 832  : 
; 833  :     for	(count = 0; count < len; count++)

  000c2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  000ca	eb 0a		 jmp	 SHORT $LN4@appendUTF1
$LN2@appendUTF1:
  000cc	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
$LN4@appendUTF1:
  000d6	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000da	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  000de	73 26		 jae	 SHORT $LN3@appendUTF1

; 834  :     {
; 835  : 		*apPoint++   = *(newbit + count);

  000e0	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR newbit$[rsp]
  000e9	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  000ee	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000f3	66 89 01	 mov	 WORD PTR [rcx], ax
  000f6	48 8b 44 24 28	 mov	 rax, QWORD PTR apPoint$[rsp]
  000fb	48 83 c0 02	 add	 rax, 2
  000ff	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 836  :     }

  00104	eb c6		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 837  :     *apPoint = '\0';

  00106	33 c0		 xor	 eax, eax
  00108	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  0010d	66 89 01	 mov	 WORD PTR [rcx], ax

; 838  : 
; 839  :     return string->chars;

  00110	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00115	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 840  : }

  00119	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011d	5f		 pop	 rdi
  0011e	c3		 ret	 0
appendUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT append8
_TEXT	SEGMENT
len$ = 32
string$ = 64
newbit$ = 72
append8	PROC						; COMDAT

; 796  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 797  :     ANTLR3_UINT32 len;
; 798  : 
; 799  :     len	= (ANTLR3_UINT32)strlen(newbit);

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newbit$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 800  : 
; 801  :     if	(string->size < (string->len + len + 1))

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00036	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00039	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0003d	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00046	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00049	73 44		 jae	 SHORT $LN2@append8

; 802  :     {
; 803  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00050	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00057	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0005b	8b c0		 mov	 eax, eax
  0005d	8b d0		 mov	 edx, eax
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00064	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00073	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 804  : 		string->size	= string->len + len + 1;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0007c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00083	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0008c	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@append8:

; 805  :     }
; 806  : 
; 807  :     /* Note we copy one more byte than the strlen in order to get the trailing
; 808  :      */
; 809  :     ANTLR3_MEMMOVE((void *)(string->chars + string->len), newbit, (ANTLR3_UINT32)(len+1));

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00093	ff c0		 inc	 eax
  00095	8b c0		 mov	 eax, eax
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0009c	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0009f	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  000a4	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  000a8	44 8b c0	 mov	 r8d, eax
  000ab	48 8b 54 24 48	 mov	 rdx, QWORD PTR newbit$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 810  :     string->len	+= len;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000bb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000be	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000c7	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 811  : 
; 812  :     return string->chars;

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000cf	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 813  : }

  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
append8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT setUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
tv67 = 48
tv68 = 52
string$ = 80
chars$ = 88
setUTF16_UTF16 PROC					; COMDAT

; 920  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 921  :     ANTLR3_UINT32   len;
; 922  :     pANTLR3_UINT16  in;
; 923  : 
; 924  :     /** First, determine the length of the input string
; 925  :      */
; 926  :     in	    = (pANTLR3_UINT16)chars;

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR chars$[rsp]
  00028	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 927  :     len   = 0;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@setUTF16_U:

; 928  : 
; 929  :     while   (*in++ != '\0')

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0003a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0003d	89 44 24 30	 mov	 DWORD PTR tv67[rsp], eax
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00046	48 83 c0 02	 add	 rax, 2
  0004a	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  0004f	83 7c 24 30 00	 cmp	 DWORD PTR tv67[rsp], 0
  00054	74 0a		 je	 SHORT $LN6@setUTF16_U
  00056	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0005e	eb 08		 jmp	 SHORT $LN7@setUTF16_U
$LN6@setUTF16_U:
  00060	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN7@setUTF16_U:
  00068	83 7c 24 34 00	 cmp	 DWORD PTR tv68[rsp], 0
  0006d	74 0c		 je	 SHORT $LN3@setUTF16_U

; 930  :     {
; 931  : 		len++;

  0006f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 932  :     }

  00079	eb ba		 jmp	 SHORT $LN2@setUTF16_U
$LN3@setUTF16_U:

; 933  : 
; 934  :     if	(string->size < len + 1)

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0007f	ff c0		 inc	 eax
  00081	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00086	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00089	73 35		 jae	 SHORT $LN4@setUTF16_U

; 935  :     {
; 936  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  0008b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0008f	ff c0		 inc	 eax
  00091	8b c0		 mov	 eax, eax
  00093	48 d1 e0	 shl	 rax, 1
  00096	8b c0		 mov	 eax, eax
  00098	8b d0		 mov	 edx, eax
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0009f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000ae	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 937  : 		string->size	= len + 1;

  000b2	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000b6	ff c0		 inc	 eax
  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000bd	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@setUTF16_U:

; 938  :     }
; 939  : 
; 940  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 941  :      */
; 942  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)((len+1) * sizeof(ANTLR3_UINT16)));

  000c0	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	8b c0		 mov	 eax, eax
  000c8	48 d1 e0	 shl	 rax, 1
  000cb	8b c0		 mov	 eax, eax
  000cd	44 8b c0	 mov	 r8d, eax
  000d0	48 8b 54 24 58	 mov	 rdx, QWORD PTR chars$[rsp]
  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000da	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 943  :     string->len	    = len;

  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000e9	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000ed	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 944  : 
; 945  :     return  string->chars;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000f5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 946  : 
; 947  : }

  000f9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
setUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT setUTF16_8
_TEXT	SEGMENT
len$ = 32
count$ = 36
apPoint$ = 40
string$ = 64
chars$ = 72
setUTF16_8 PROC						; COMDAT

; 895  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 896  :     ANTLR3_UINT32	len;
; 897  :     ANTLR3_UINT32	count;
; 898  :     pANTLR3_UINT16	apPoint;
; 899  : 
; 900  :     len = (ANTLR3_UINT32)strlen(chars);

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chars$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 901  :     if	(string->size < len + 1)

  00031	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00035	ff c0		 inc	 eax
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0003c	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0003f	73 35		 jae	 SHORT $LN5@setUTF16_8

; 902  : 	{
; 903  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  00041	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00045	ff c0		 inc	 eax
  00047	8b c0		 mov	 eax, eax
  00049	48 d1 e0	 shl	 rax, 1
  0004c	8b c0		 mov	 eax, eax
  0004e	8b d0		 mov	 edx, eax
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00055	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00064	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 904  : 		string->size	= len + 1;

  00068	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00073	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN5@setUTF16_8:

; 905  :     }
; 906  :     apPoint = ((pANTLR3_UINT16)string->chars);

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0007b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007f	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 907  :     string->len	= len;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00089	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0008d	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 908  : 
; 909  :     for	(count = 0; count < string->len; count++)

  00090	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  00098	eb 0a		 jmp	 SHORT $LN4@setUTF16_8
$LN2@setUTF16_8:
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  0009e	ff c0		 inc	 eax
  000a0	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
$LN4@setUTF16_8:
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ac	39 44 24 24	 cmp	 DWORD PTR count$[rsp], eax
  000b0	73 26		 jae	 SHORT $LN3@setUTF16_8

; 910  :     {
; 911  : 		*apPoint++   = *(chars + count);

  000b2	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  000b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chars$[rsp]
  000bb	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  000c0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000c5	66 89 01	 mov	 WORD PTR [rcx], ax
  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR apPoint$[rsp]
  000cd	48 83 c0 02	 add	 rax, 2
  000d1	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 912  :     }

  000d6	eb c2		 jmp	 SHORT $LN2@setUTF16_8
$LN3@setUTF16_8:

; 913  :     *apPoint = '\0';

  000d8	33 c0		 xor	 eax, eax
  000da	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000df	66 89 01	 mov	 WORD PTR [rcx], ax

; 914  : 
; 915  :     return  string->chars;

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000e7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 916  : }

  000eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
setUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT set8
_TEXT	SEGMENT
len$ = 32
string$ = 64
chars$ = 72
set8	PROC						; COMDAT

; 874  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 875  :     ANTLR3_UINT32	len;
; 876  : 
; 877  :     len = (ANTLR3_UINT32)strlen(chars);

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chars$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 878  :     if	(string->size < len + 1)

  00031	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00035	ff c0		 inc	 eax
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0003c	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0003f	73 30		 jae	 SHORT $LN2@set8

; 879  :     {
; 880  : 		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(len + 1));

  00041	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00045	ff c0		 inc	 eax
  00047	8b c0		 mov	 eax, eax
  00049	8b d0		 mov	 edx, eax
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00050	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0005f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 881  : 		string->size	= len + 1;

  00063	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00067	ff c0		 inc	 eax
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0006e	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@set8:

; 882  :     }
; 883  : 
; 884  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 885  :      */
; 886  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)(len+1));

  00071	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00075	ff c0		 inc	 eax
  00077	8b c0		 mov	 eax, eax
  00079	44 8b c0	 mov	 r8d, eax
  0007c	48 8b 54 24 48	 mov	 rdx, QWORD PTR chars$[rsp]
  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00086	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 887  :     string->len	    = len;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00095	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00099	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 888  : 
; 889  :     return  string->chars;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 890  : 
; 891  : }

  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
set8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT closeFactory
_TEXT	SEGMENT
factory$ = 48
closeFactory PROC					; COMDAT

; 783  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 784  :     /* Delete the vector we were tracking the strings with, this will
; 785  :      * causes all the allocated strings to be deallocated too
; 786  :      */
; 787  :     factory->strings->free(factory->strings);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 788  : 
; 789  :     /* Delete the space for the factory itself
; 790  :      */
; 791  :     ANTLR3_FREE((void *)factory);

  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 792  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
closeFactory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT printableUTF16
_TEXT	SEGMENT
string$ = 32
scannedText$ = 40
inText$ = 48
i$ = 56
outLen$ = 60
factory$ = 80
instr$ = 88
printableUTF16 PROC					; COMDAT

; 725  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 726  :     pANTLR3_STRING  string;
; 727  :     
; 728  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 729  :      */
; 730  :     pANTLR3_UINT16  scannedText;
; 731  :     pANTLR3_UINT16  inText;
; 732  :     ANTLR3_UINT32   i;
; 733  :     ANTLR3_UINT32   outLen;
; 734  : 
; 735  :     /* Assume we need as much as twice as much space to parse out the control characters
; 736  :      */
; 737  :     string  = factory->newSize(factory, instr->len *2 + 1);

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002b	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0002f	8b d0		 mov	 edx, eax
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  0003b	ff 50 18	 call	 QWORD PTR [rax+24]
  0003e	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 738  : 
; 739  :     /* Scan through and replace unprintable (in terms of this routine)
; 740  :      * characters
; 741  :      */
; 742  :     scannedText = (pANTLR3_UINT16)(string->chars);

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00048	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004c	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 743  :     inText	= (pANTLR3_UINT16)(instr->chars);

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00056	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005a	48 89 44 24 30	 mov	 QWORD PTR inText$[rsp], rax

; 744  :     outLen	= 0;

  0005f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR outLen$[rsp], 0

; 745  : 
; 746  :     for	(i = 0; i < instr->len; i++)

  00067	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@printableU
$LN2@printableU:
  00071	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@printableU:
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00080	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00083	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00087	0f 83 1f 01 00
	00		 jae	 $LN3@printableU

; 747  :     {
; 748  : 		if (*(inText + i) == '\n')

  0008d	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  00096	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0009a	83 f8 0a	 cmp	 eax, 10
  0009d	75 46		 jne	 SHORT $LN5@printableU

; 749  : 		{
; 750  : 			*scannedText++   = '\\';

  0009f	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  000a9	66 89 01	 mov	 WORD PTR [rcx], ax
  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000b1	48 83 c0 02	 add	 rax, 2
  000b5	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 751  : 			*scannedText++   = 'n';

  000ba	b8 6e 00 00 00	 mov	 eax, 110		; 0000006eH
  000bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  000c4	66 89 01	 mov	 WORD PTR [rcx], ax
  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000cc	48 83 c0 02	 add	 rax, 2
  000d0	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 752  : 			outLen	    += 2;

  000d5	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  000d9	83 c0 02	 add	 eax, 2
  000dc	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 753  : 		}

  000e0	e9 c2 00 00 00	 jmp	 $LN6@printableU
$LN5@printableU:

; 754  : 		else if (*(inText + i) == '\r')

  000e5	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  000ee	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000f2	83 f8 0d	 cmp	 eax, 13
  000f5	75 43		 jne	 SHORT $LN7@printableU

; 755  : 		{
; 756  : 			*scannedText++   = '\\';

  000f7	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  000fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00101	66 89 01	 mov	 WORD PTR [rcx], ax
  00104	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00109	48 83 c0 02	 add	 rax, 2
  0010d	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 757  : 			*scannedText++   = 'r';

  00112	b8 72 00 00 00	 mov	 eax, 114		; 00000072H
  00117	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  0011c	66 89 01	 mov	 WORD PTR [rcx], ax
  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00124	48 83 c0 02	 add	 rax, 2
  00128	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 758  : 			outLen	    += 2;

  0012d	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  00131	83 c0 02	 add	 eax, 2
  00134	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 759  : 		}

  00138	eb 6d		 jmp	 SHORT $LN8@printableU
$LN7@printableU:

; 760  : 		else if	(!isprint(*(inText +i)))

  0013a	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0013e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  00143	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00147	8b c8		 mov	 ecx, eax
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0014f	85 c0		 test	 eax, eax
  00151	75 27		 jne	 SHORT $LN9@printableU

; 761  : 		{
; 762  : 			*scannedText++ = '?';

  00153	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  0015d	66 89 01	 mov	 WORD PTR [rcx], ax
  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00165	48 83 c0 02	 add	 rax, 2
  00169	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 763  : 			outLen++;

  0016e	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  00172	ff c0		 inc	 eax
  00174	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 764  : 		}

  00178	eb 2d		 jmp	 SHORT $LN10@printableU
$LN9@printableU:

; 765  : 		else
; 766  : 		{
; 767  : 			*scannedText++ = *(inText + i);

  0017a	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0017e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00183	48 8b 54 24 30	 mov	 rdx, QWORD PTR inText$[rsp]
  00188	0f b7 04 42	 movzx	 eax, WORD PTR [rdx+rax*2]
  0018c	66 89 01	 mov	 WORD PTR [rcx], ax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00194	48 83 c0 02	 add	 rax, 2
  00198	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 768  : 			outLen++;

  0019d	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  001a1	ff c0		 inc	 eax
  001a3	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax
$LN10@printableU:
$LN8@printableU:
$LN6@printableU:

; 769  : 		}
; 770  :     }

  001a7	e9 c5 fe ff ff	 jmp	 $LN2@printableU
$LN3@printableU:

; 771  :     *scannedText  = '\0';

  001ac	33 c0		 xor	 eax, eax
  001ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  001b3	66 89 01	 mov	 WORD PTR [rcx], ax

; 772  : 
; 773  :     string->len	= outLen;

  001b6	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  001bb	8b 4c 24 3c	 mov	 ecx, DWORD PTR outLen$[rsp]
  001bf	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 774  :     
; 775  :     return  string;

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]

; 776  : }

  001c7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001cb	5f		 pop	 rdi
  001cc	c3		 ret	 0
printableUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT printable8
_TEXT	SEGMENT
string$ = 32
scannedText$ = 40
i$ = 48
factory$ = 80
instr$ = 88
printable8 PROC						; COMDAT

; 678  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 679  :     pANTLR3_STRING  string;
; 680  :     
; 681  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 682  :      */
; 683  :     pANTLR3_UINT8   scannedText;
; 684  :     ANTLR3_UINT32   i;
; 685  : 
; 686  :     /* Assume we need as much as twice as much space to parse out the control characters
; 687  :      */
; 688  :     string  = factory->newSize(factory, instr->len *2 + 1);

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002b	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0002f	8b d0		 mov	 edx, eax
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  0003b	ff 50 18	 call	 QWORD PTR [rax+24]
  0003e	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 689  : 
; 690  :     /* Scan through and replace unprintable (in terms of this routine)
; 691  :      * characters
; 692  :      */
; 693  :     scannedText = string->chars;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00048	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004c	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 694  : 
; 695  :     for	(i = 0; i < instr->len; i++)

  00051	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00059	eb 0a		 jmp	 SHORT $LN4@printable8
$LN2@printable8:
  0005b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0005f	ff c0		 inc	 eax
  00061	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@printable8:
  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  0006a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00071	0f 83 e5 00 00
	00		 jae	 $LN3@printable8

; 696  :     {
; 697  : 		if (*(instr->chars + i) == '\n')

  00077	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0007b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  00080	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00084	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00088	83 f8 0a	 cmp	 eax, 10
  0008b	75 2f		 jne	 SHORT $LN5@printable8

; 698  : 		{
; 699  : 			*scannedText++ = '\\';

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00092	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0009a	48 ff c0	 inc	 rax
  0009d	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 700  : 			*scannedText++ = 'n';

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000a7	c6 00 6e	 mov	 BYTE PTR [rax], 110	; 0000006eH
  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000af	48 ff c0	 inc	 rax
  000b2	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 701  : 		}

  000b7	e9 9b 00 00 00	 jmp	 $LN6@printable8
$LN5@printable8:

; 702  : 		else if (*(instr->chars + i) == '\r')

  000bc	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  000c5	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	83 f8 0d	 cmp	 eax, 13
  000d0	75 2c		 jne	 SHORT $LN7@printable8

; 703  : 		{
; 704  : 			*scannedText++ = '\\';

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000d7	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000df	48 ff c0	 inc	 rax
  000e2	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 705  : 			*scannedText++ = 'r';

  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000ec	c6 00 72	 mov	 BYTE PTR [rax], 114	; 00000072H
  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000f4	48 ff c0	 inc	 rax
  000f7	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 706  : 		}

  000fc	eb 59		 jmp	 SHORT $LN8@printable8
$LN7@printable8:

; 707  : 		else if	(!isprint(*(instr->chars +i)))

  000fe	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00102	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  00107	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0010b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010f	8b c8		 mov	 ecx, eax
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00117	85 c0		 test	 eax, eax
  00119	75 17		 jne	 SHORT $LN9@printable8

; 708  : 		{
; 709  : 			*scannedText++ = '?';

  0011b	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00120	c6 00 3f	 mov	 BYTE PTR [rax], 63	; 0000003fH
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00128	48 ff c0	 inc	 rax
  0012b	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 710  : 		}

  00130	eb 25		 jmp	 SHORT $LN10@printable8
$LN9@printable8:

; 711  : 		else
; 712  : 		{
; 713  : 			*scannedText++ = *(instr->chars + i);

  00132	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00136	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  0013b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0013f	48 8b 54 24 28	 mov	 rdx, QWORD PTR scannedText$[rsp]
  00144	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00148	88 02		 mov	 BYTE PTR [rdx], al
  0014a	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0014f	48 ff c0	 inc	 rax
  00152	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax
$LN10@printable8:
$LN8@printable8:
$LN6@printable8:

; 714  : 		}
; 715  :     }

  00157	e9 ff fe ff ff	 jmp	 $LN2@printable8
$LN3@printable8:

; 716  :     *scannedText  = '\0';

  0015c	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00161	c6 00 00	 mov	 BYTE PTR [rax], 0

; 717  : 
; 718  :     string->len	= (ANTLR3_UINT32)(scannedText - string->chars);

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00169	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00172	48 2b c8	 sub	 rcx, rax
  00175	48 8b c1	 mov	 rax, rcx
  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0017d	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 719  :     
; 720  :     return  string;

  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]

; 721  : }

  00185	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00189	5f		 pop	 rdi
  0018a	c3		 ret	 0
printable8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT destroy
_TEXT	SEGMENT
strIndex$ = 32
i$1 = 36
factory$ = 64
string$ = 72
destroy	PROC						; COMDAT

; 633  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 634  :     // Record which string we are deleting
; 635  :     //
; 636  :     ANTLR3_UINT32 strIndex = string->index;

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  00028	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002b	89 44 24 20	 mov	 DWORD PTR strIndex$[rsp], eax

; 637  :     
; 638  :     // Ensure that the string was not factory made, or we would try
; 639  :     // to delete memory that wasn't allocated outside the factory
; 640  :     // block.
; 641  :     // Remove the specific indexed string from the vector
; 642  :     //
; 643  :     factory->strings->del(factory->strings, strIndex);

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	8b 54 24 20	 mov	 edx, DWORD PTR strIndex$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00040	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00043	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 644  : 
; 645  :     // One less string in the vector, so decrement the factory index
; 646  :     // so that the next string allocated is indexed correctly with
; 647  :     // respect to the vector.
; 648  :     //
; 649  :     factory->index--;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0004e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00051	ff c8		 dec	 eax
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00058	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 650  : 
; 651  :     // Now we have to reindex the strings in the vector that followed
; 652  :     // the one we just deleted. We only do this if the one we just deleted
; 653  :     // was not the last one.
; 654  :     //
; 655  :     if  (strIndex< factory->index)

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00060	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00063	39 44 24 20	 cmp	 DWORD PTR strIndex$[rsp], eax
  00067	73 42		 jae	 SHORT $LN5@destroy

; 656  :     {
; 657  :         // We must reindex the strings after the one we just deleted.
; 658  :         // The one that follows the one we just deleted is also out
; 659  :         // of whack, so we start there.
; 660  :         //
; 661  :         ANTLR3_UINT32 i;
; 662  : 
; 663  :         for (i = strIndex; i < factory->index; i++)

  00069	8b 44 24 20	 mov	 eax, DWORD PTR strIndex$[rsp]
  0006d	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00071	eb 0a		 jmp	 SHORT $LN4@destroy
$LN2@destroy:
  00073	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00077	ff c0		 inc	 eax
  00079	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@destroy:
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00085	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  00089	73 20		 jae	 SHORT $LN3@destroy

; 664  :         {
; 665  :             // Renumber the entry
; 666  :             //
; 667  :             ((pANTLR3_STRING)(factory->strings->elements[i].element))->index = i;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	8b 4c 24 24	 mov	 ecx, DWORD PTR i$1[rsp]
  00097	48 6b c9 10	 imul	 rcx, rcx, 16
  0009b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009e	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  000a2	8b 4c 24 24	 mov	 ecx, DWORD PTR i$1[rsp]
  000a6	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 668  :         }

  000a9	eb c8		 jmp	 SHORT $LN2@destroy
$LN3@destroy:
$LN5@destroy:

; 669  :     }
; 670  : 
; 671  :     // The string has been destroyed and the elements of the factory are reindexed.
; 672  :     //
; 673  : 
; 674  : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
destroy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newStrUTF16_UTF16
_TEXT	SEGMENT
in$ = 32
count$ = 40
tv67 = 44
tv68 = 48
factory$ = 80
ptr$ = 88
newStrUTF16_UTF16 PROC					; COMDAT

; 615  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 616  :     pANTLR3_UINT16  in;
; 617  :     ANTLR3_UINT32   count;
; 618  : 
; 619  :     /** First, determine the length of the input string
; 620  :      */
; 621  :     in	    = (pANTLR3_UINT16)ptr;

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR in$[rsp], rax

; 622  :     count   = 0;

  0002d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@newStrUTF1:

; 623  : 
; 624  :     while   (*in++ != '\0')

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  0003a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0003d	89 44 24 2c	 mov	 DWORD PTR tv67[rsp], eax
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  00046	48 83 c0 02	 add	 rax, 2
  0004a	48 89 44 24 20	 mov	 QWORD PTR in$[rsp], rax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR tv67[rsp], 0
  00054	74 0a		 je	 SHORT $LN5@newStrUTF1
  00056	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0005e	eb 08		 jmp	 SHORT $LN6@newStrUTF1
$LN5@newStrUTF1:
  00060	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@newStrUTF1:
  00068	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  0006d	74 0c		 je	 SHORT $LN3@newStrUTF1

; 625  :     {
; 626  : 		count++;

  0006f	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax

; 627  :     }

  00079	eb ba		 jmp	 SHORT $LN2@newStrUTF1
$LN3@newStrUTF1:

; 628  :     return factory->newPtr(factory, ptr, count);

  0007b	44 8b 44 24 28	 mov	 r8d, DWORD PTR count$[rsp]
  00080	48 8b 54 24 58	 mov	 rdx, QWORD PTR ptr$[rsp]
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  0008f	ff 50 20	 call	 QWORD PTR [rax+32]

; 629  : }

  00092	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
newStrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newStrUTF16_8
_TEXT	SEGMENT
factory$ = 48
ptr$ = 56
newStrUTF16_8 PROC					; COMDAT

; 604  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 605  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	44 8b c0	 mov	 r8d, eax
  00030	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0003f	ff 50 28	 call	 QWORD PTR [rax+40]

; 606  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
newStrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newStr8
_TEXT	SEGMENT
factory$ = 48
ptr$ = 56
newStr8	PROC						; COMDAT

; 593  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 594  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	44 8b c0	 mov	 r8d, eax
  00030	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0003f	ff 50 28	 call	 QWORD PTR [rax+40]

; 595  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
newStr8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newPtrUTF16_UTF16
_TEXT	SEGMENT
string$ = 32
factory$ = 64
ptr$ = 72
size$ = 80
newPtrUTF16_UTF16 PROC					; COMDAT

; 558  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 559  : 	pANTLR3_STRING  string;
; 560  : 
; 561  : 	string  = factory->newSize(factory, size);

  00028	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00036	ff 50 18	 call	 QWORD PTR [rax+24]
  00039	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 562  : 
; 563  : 	if	(string == NULL)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00044	75 04		 jne	 SHORT $LN2@newPtrUTF1

; 564  : 	{
; 565  : 		return	NULL;

  00046	33 c0		 xor	 eax, eax
  00048	eb 58		 jmp	 SHORT $LN1@newPtrUTF1
$LN2@newPtrUTF1:

; 566  : 	}
; 567  : 
; 568  : 	if	(size <= 0)

  0004a	83 7c 24 50 00	 cmp	 DWORD PTR size$[rsp], 0
  0004f	77 07		 ja	 SHORT $LN3@newPtrUTF1

; 569  : 	{
; 570  : 		return	string;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00056	eb 4a		 jmp	 SHORT $LN1@newPtrUTF1
$LN3@newPtrUTF1:

; 571  : 	}
; 572  : 
; 573  : 	if	(ptr != NULL)

  00058	48 83 7c 24 48
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0005e	74 3d		 je	 SHORT $LN4@newPtrUTF1

; 574  : 	{
; 575  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, (size * sizeof(ANTLR3_UINT16)));

  00060	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00064	48 d1 e0	 shl	 rax, 1
  00067	4c 8b c0	 mov	 r8, rax
  0006a	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00074	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 576  : 
; 577  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 578  : 		*/
; 579  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';	    

  0007e	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00087	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0008b	33 d2		 xor	 edx, edx
  0008d	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 580  : 		string->len = size;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00096	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  0009a	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN4@newPtrUTF1:

; 581  : 	}
; 582  : 
; 583  : 	return  string;

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtrUTF1:

; 584  : }

  000a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
newPtrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newPtrUTF16_8
_TEXT	SEGMENT
string$ = 32
out$1 = 40
inSize$2 = 48
tv74 = 52
tv75 = 56
factory$ = 80
ptr$ = 88
size$ = 96
newPtrUTF16_8 PROC					; COMDAT

; 510  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 511  : 	pANTLR3_STRING  string;
; 512  : 
; 513  : 	/* newSize accepts size in characters, not bytes
; 514  : 	*/
; 515  : 	string  = factory->newSize(factory, size);

  00028	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00036	ff 50 18	 call	 QWORD PTR [rax+24]
  00039	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 516  : 
; 517  : 	if	(string == NULL)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00044	75 07		 jne	 SHORT $LN4@newPtrUTF1

; 518  : 	{
; 519  : 		return	NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 b6 00 00 00	 jmp	 $LN1@newPtrUTF1
$LN4@newPtrUTF1:

; 520  : 	}
; 521  : 
; 522  : 	if	(size <= 0)

  0004d	83 7c 24 60 00	 cmp	 DWORD PTR size$[rsp], 0
  00052	77 0a		 ja	 SHORT $LN5@newPtrUTF1

; 523  : 	{
; 524  : 		return	string;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00059	e9 a5 00 00 00	 jmp	 $LN1@newPtrUTF1
$LN5@newPtrUTF1:

; 525  : 	}
; 526  : 
; 527  : 	if	(ptr != NULL)

  0005e	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00064	0f 84 94 00 00
	00		 je	 $LN6@newPtrUTF1

; 528  : 	{
; 529  : 		pANTLR3_UINT16	out;
; 530  : 		ANTLR3_INT32    inSize;
; 531  : 
; 532  : 		out = (pANTLR3_UINT16)(string->chars);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0006f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00073	48 89 44 24 28	 mov	 QWORD PTR out$1[rsp], rax

; 533  : 		inSize	= size;

  00078	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  0007c	89 44 24 30	 mov	 DWORD PTR inSize$2[rsp], eax
$LN2@newPtrUTF1:

; 534  : 
; 535  : 		while	(inSize-- > 0)

  00080	8b 44 24 30	 mov	 eax, DWORD PTR inSize$2[rsp]
  00084	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
  00088	8b 44 24 30	 mov	 eax, DWORD PTR inSize$2[rsp]
  0008c	ff c8		 dec	 eax
  0008e	89 44 24 30	 mov	 DWORD PTR inSize$2[rsp], eax
  00092	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00097	7e 0a		 jle	 SHORT $LN8@newPtrUTF1
  00099	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  000a1	eb 08		 jmp	 SHORT $LN9@newPtrUTF1
$LN8@newPtrUTF1:
  000a3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@newPtrUTF1:
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR tv75[rsp], 0
  000b0	74 2d		 je	 SHORT $LN3@newPtrUTF1

; 536  : 		{
; 537  : 			*out++ = (ANTLR3_UINT16)(*ptr++);

  000b2	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  000b7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR out$1[rsp]
  000bf	66 89 01	 mov	 WORD PTR [rcx], ax
  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR out$1[rsp]
  000c7	48 83 c0 02	 add	 rax, 2
  000cb	48 89 44 24 28	 mov	 QWORD PTR out$1[rsp], rax
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  000d5	48 ff c0	 inc	 rax
  000d8	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 538  : 		}

  000dd	eb a1		 jmp	 SHORT $LN2@newPtrUTF1
$LN3@newPtrUTF1:

; 539  : 
; 540  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 541  : 		*/
; 542  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';

  000df	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  000e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000e8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ec	33 d2		 xor	 edx, edx
  000ee	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 543  : 
; 544  : 		string->len = size;

  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000f7	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  000fb	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN6@newPtrUTF1:

; 545  : 	}
; 546  : 
; 547  : 	return  string;

  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtrUTF1:

; 548  : }

  00103	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
newPtrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newPtr8
_TEXT	SEGMENT
string$ = 32
factory$ = 64
ptr$ = 72
size$ = 80
newPtr8	PROC						; COMDAT

; 477  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 478  : 	pANTLR3_STRING  string;
; 479  : 
; 480  : 	string  = factory->newSize(factory, size);

  00028	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00036	ff 50 18	 call	 QWORD PTR [rax+24]
  00039	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 481  : 
; 482  : 	if	(string == NULL)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00044	75 04		 jne	 SHORT $LN2@newPtr8

; 483  : 	{
; 484  : 		return	NULL;

  00046	33 c0		 xor	 eax, eax
  00048	eb 53		 jmp	 SHORT $LN1@newPtr8
$LN2@newPtr8:

; 485  : 	}
; 486  : 
; 487  : 	if	(size <= 0)

  0004a	83 7c 24 50 00	 cmp	 DWORD PTR size$[rsp], 0
  0004f	77 07		 ja	 SHORT $LN3@newPtr8

; 488  : 	{
; 489  : 		return	string;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00056	eb 45		 jmp	 SHORT $LN1@newPtr8
$LN3@newPtr8:

; 490  : 	}
; 491  : 
; 492  : 	if	(ptr != NULL)

  00058	48 83 7c 24 48
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0005e	74 38		 je	 SHORT $LN4@newPtr8

; 493  : 	{
; 494  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, size);

  00060	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00064	44 8b c0	 mov	 r8d, eax
  00067	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00071	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 495  : 		*(string->chars + size) = '\0';	    /* Terminate, these strings are usually used for Token streams and printing etc.	*/

  0007b	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0007f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00084	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00088	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 496  : 		string->len = size;

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00091	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  00095	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN4@newPtr8:

; 497  : 	}
; 498  : 
; 499  : 	return  string;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtr8:

; 500  : }

  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
newPtr8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newSizeUTF16
_TEXT	SEGMENT
string$ = 32
factory$ = 64
size$ = 72
newSizeUTF16 PROC					; COMDAT

; 450  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 451  :     pANTLR3_STRING  string;
; 452  : 
; 453  :     string  = factory->newRaw(factory);

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0002c	ff 50 10	 call	 QWORD PTR [rax+16]
  0002f	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 454  : 
; 455  :     if	(string == NULL)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN2@newSizeUTF

; 456  :     {
; 457  :         return	string;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00041	eb 3c		 jmp	 SHORT $LN1@newSizeUTF
$LN2@newSizeUTF:

; 458  :     }
; 459  : 
; 460  :     /* Always add one more byte for a terminator ;-)
; 461  :     */	
; 462  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT16) * (size+1)));

  00043	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00047	ff c0		 inc	 eax
  00049	8b c0		 mov	 eax, eax
  0004b	48 d1 e0	 shl	 rax, 1
  0004e	48 8b c8	 mov	 rcx, rax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0005c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 463  :     *(string->chars)	= '\0';

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00065	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00069	c6 00 00	 mov	 BYTE PTR [rax], 0

; 464  :     string->size	= size+1;	/* Size is always in characters, as is len */

  0006c	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00070	ff c0		 inc	 eax
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00077	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 465  : 
; 466  :     return string;

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newSizeUTF:

; 467  : }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
newSizeUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newSize8
_TEXT	SEGMENT
string$ = 32
factory$ = 64
size$ = 72
newSize8 PROC						; COMDAT

; 422  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 423  :     pANTLR3_STRING  string;
; 424  : 
; 425  :     string  = factory->newRaw(factory);

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0002c	ff 50 10	 call	 QWORD PTR [rax+16]
  0002f	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 426  : 
; 427  :     if	(string == NULL)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN2@newSize8

; 428  :     {
; 429  :         return	string;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00041	eb 38		 jmp	 SHORT $LN1@newSize8
$LN2@newSize8:

; 430  :     }
; 431  : 
; 432  :     /* Always add one more byte for a terminator ;-)
; 433  :     */
; 434  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT8) * (size+1)));

  00043	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00047	ff c0		 inc	 eax
  00049	8b c0		 mov	 eax, eax
  0004b	8b c8		 mov	 ecx, eax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00058	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 435  :     *(string->chars)	= '\0';

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00061	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 436  :     string->size	= size + 1;

  00068	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00073	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 437  : 
; 438  : 
; 439  :     return string;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newSize8:

; 440  : }

  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
newSize8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newRawUTF16
_TEXT	SEGMENT
string$ = 48
factory$ = 80
newRawUTF16 PROC					; COMDAT

; 216  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 217  :     pANTLR3_STRING  string;
; 218  : 
; 219  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0001e	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 30	 mov	 QWORD PTR string$[rsp], rax

; 220  : 
; 221  :     if	(string == NULL)

  0002e	48 83 7c 24 30
	00		 cmp	 QWORD PTR string$[rsp], 0
  00034	75 04		 jne	 SHORT $LN2@newRawUTF1

; 222  :     {
; 223  : 		return	NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 6d		 jmp	 SHORT $LN1@newRawUTF1
$LN2@newRawUTF1:

; 224  :     }
; 225  : 
; 226  :     /* Structure is allocated, now fill in the API etc.
; 227  :      */
; 228  :     stringInitUTF16(string);

  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0003f	e8 00 00 00 00	 call	 stringInitUTF16

; 229  :     string->factory = factory;

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0004e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 230  : 
; 231  :     /* Add the string into the allocated list
; 232  :      */
; 233  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:stringFree
  00065	4c 8b 44 24 30	 mov	 r8, QWORD PTR string$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0006f	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 234  :     string->index   = factory->index++;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0008a	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0008d	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00095	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00098	ff c0		 inc	 eax
  0009a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0009f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 235  : 
; 236  :     return string;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newRawUTF1:

; 237  : }

  000a7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
newRawUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT newRaw8
_TEXT	SEGMENT
string$ = 48
factory$ = 80
newRaw8	PROC						; COMDAT

; 187  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 188  :     pANTLR3_STRING  string;
; 189  : 
; 190  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0001e	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 30	 mov	 QWORD PTR string$[rsp], rax

; 191  : 
; 192  :     if	(string == NULL)

  0002e	48 83 7c 24 30
	00		 cmp	 QWORD PTR string$[rsp], 0
  00034	75 04		 jne	 SHORT $LN2@newRaw8

; 193  :     {
; 194  : 		return	NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 6d		 jmp	 SHORT $LN1@newRaw8
$LN2@newRaw8:

; 195  :     }
; 196  : 
; 197  :     /* Structure is allocated, now fill in the API etc.
; 198  :      */
; 199  :     stringInit8(string);

  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0003f	e8 00 00 00 00	 call	 stringInit8

; 200  :     string->factory = factory;

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0004e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 201  : 
; 202  :     /* Add the string into the allocated list
; 203  :      */
; 204  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:stringFree
  00065	4c 8b 44 24 30	 mov	 r8, QWORD PTR string$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0006f	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 205  :     string->index   = factory->index++;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0008a	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0008d	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00095	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00098	ff c0		 inc	 eax
  0009a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0009f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 206  : 
; 207  :     return string;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newRaw8:

; 208  : }

  000a7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
newRaw8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3string.c
;	COMDAT antlr3StringFactoryNew
_TEXT	SEGMENT
factory$ = 32
tv78 = 40
encoding$ = 64
antlr3StringFactoryNew PROC				; COMDAT

; 99   : {

$LN12:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 0c 00 00 00	 mov	 ecx, 12
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 100  : 	pANTLR3_STRING_FACTORY  factory;
; 101  : 
; 102  : 	/* Allocate memory
; 103  : 	*/
; 104  : 	factory	= (pANTLR3_STRING_FACTORY) ANTLR3_CALLOC(1, sizeof(ANTLR3_STRING_FACTORY));

  0001c	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002c	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 105  : 
; 106  : 	if	(factory == NULL)

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00037	75 07		 jne	 SHORT $LN4@antlr3Stri

; 107  : 	{
; 108  : 		return	NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 a5 01 00 00	 jmp	 $LN1@antlr3Stri
$LN4@antlr3Stri:

; 109  : 	}
; 110  : 
; 111  : 	/* Now we make a new list to track the strings.
; 112  : 	*/
; 113  : 	factory->strings	= antlr3VectorNew(0);

  00040	33 c9		 xor	 ecx, ecx
  00042	e8 00 00 00 00	 call	 antlr3VectorNew
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  0004c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 114  : 	factory->index	= 0;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00054	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 115  : 
; 116  : 	if	(factory->strings == NULL)

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	75 12		 jne	 SHORT $LN5@antlr3Stri

; 117  : 	{
; 118  : 		ANTLR3_FREE(factory);

  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 119  : 		return	NULL;

  00071	33 c0		 xor	 eax, eax
  00073	e9 6d 01 00 00	 jmp	 $LN1@antlr3Stri
$LN5@antlr3Stri:

; 120  : 	}
; 121  : 
; 122  :     // Install the API
; 123  :     //
; 124  :     // TODO: These encodings need equivalent functions to
; 125  :     // UTF16 and 8Bit if I am going to support those encodings in the STRING stuff.
; 126  : 	// The STRING stuff was intended as a quick and dirty hack for people that did not
; 127  : 	// want to worry about memory and performance very much, but nobody ever reads the 
; 128  : 	// notes or comments or uses the email list search. I want to discourage using these
; 129  : 	// interfaces as it is much more efficient to use the pointers within the tokens
; 130  : 	// directly, so I am not implementing the string stuff for the newer encodings.
; 131  :     // We install the standard 8 and 16 bit functions for the UTF 8 and 16 but they
; 132  : 	// will not be useful beyond returning the text.
; 133  : 	// 
; 134  :     switch(encoding)

  00078	8b 44 24 40	 mov	 eax, DWORD PTR encoding$[rsp]
  0007c	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  00080	83 7c 24 28 10	 cmp	 DWORD PTR tv78[rsp], 16
  00085	0f 82 c5 00 00
	00		 jb	 $LN10@antlr3Stri
  0008b	83 7c 24 28 12	 cmp	 DWORD PTR tv78[rsp], 18
  00090	76 29		 jbe	 SHORT $LN9@antlr3Stri
  00092	83 7c 24 28 20	 cmp	 DWORD PTR tv78[rsp], 32	; 00000020H
  00097	74 13		 je	 SHORT $LN6@antlr3Stri
  00099	83 7c 24 28 21	 cmp	 DWORD PTR tv78[rsp], 33	; 00000021H
  0009e	74 11		 je	 SHORT $LN7@antlr3Stri
  000a0	83 7c 24 28 22	 cmp	 DWORD PTR tv78[rsp], 34	; 00000022H
  000a5	74 0f		 je	 SHORT $LN8@antlr3Stri
  000a7	e9 a4 00 00 00	 jmp	 $LN10@antlr3Stri
$LN6@antlr3Stri:

; 135  :     {
; 136  : 		case    ANTLR3_ENC_UTF32:
; 137  : 			break;

  000ac	e9 2f 01 00 00	 jmp	 $LN2@antlr3Stri
$LN7@antlr3Stri:

; 138  : 
; 139  : 		case    ANTLR3_ENC_UTF32BE:
; 140  : 			break;

  000b1	e9 2a 01 00 00	 jmp	 $LN2@antlr3Stri
$LN8@antlr3Stri:

; 141  : 
; 142  : 		case    ANTLR3_ENC_UTF32LE:
; 143  : 			break;

  000b6	e9 25 01 00 00	 jmp	 $LN2@antlr3Stri
$LN9@antlr3Stri:

; 144  : 
; 145  : 		case    ANTLR3_ENC_UTF16BE:
; 146  : 		case    ANTLR3_ENC_UTF16LE:
; 147  : 		case    ANTLR3_ENC_UTF16:
; 148  : 
; 149  : 			factory->newRaw	    =  newRawUTF16;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newRawUTF16
  000c7	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 150  : 			factory->newSize	=  newSizeUTF16;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newSizeUTF16
  000d7	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 151  : 			factory->newPtr	    =  newPtrUTF16_UTF16;

  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtrUTF16_UTF16
  000e7	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 152  : 			factory->newPtr8	=  newPtrUTF16_8;

  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtrUTF16_8
  000f7	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 153  : 			factory->newStr	    =  newStrUTF16_UTF16;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStrUTF16_UTF16
  00107	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 154  : 			factory->newStr8	=  newStrUTF16_8;

  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStrUTF16_8
  00117	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 155  : 			factory->printable	=  printableUTF16;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:printableUTF16
  00127	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 156  : 			factory->destroy	=  destroy;

  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:destroy
  00137	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 157  : 			factory->close	    =  closeFactory;

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeFactory
  00147	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 158  : 			break;

  0014b	e9 90 00 00 00	 jmp	 $LN2@antlr3Stri
$LN10@antlr3Stri:

; 159  : 	 
; 160  : 		case    ANTLR3_ENC_UTF8:
; 161  : 		case    ANTLR3_ENC_EBCDIC:
; 162  : 		case    ANTLR3_ENC_8BIT:
; 163  : 		default:
; 164  : 
; 165  : 			factory->newRaw	    =  newRaw8;

  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newRaw8
  0015c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 166  : 			factory->newSize	=  newSize8;

  00160	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newSize8
  0016c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 167  : 			factory->newPtr	    =  newPtr8;

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtr8
  0017c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 168  : 			factory->newPtr8	=  newPtr8;

  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtr8
  0018c	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 169  : 			factory->newStr	    =  newStr8;

  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStr8
  0019c	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 170  : 			factory->newStr8	=  newStr8;

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStr8
  001ac	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 171  : 			factory->printable	=  printable8;

  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:printable8
  001bc	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 172  : 			factory->destroy	=  destroy;

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:destroy
  001cc	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 173  : 			factory->close	    =  closeFactory;

  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeFactory
  001dc	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
$LN2@antlr3Stri:

; 174  : 			break;
; 175  :     }
; 176  : 	return  factory;

  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Stri:

; 177  : }

  001e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
antlr3StringFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00049	e8 00 00 00 00	 call	 _vsprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
