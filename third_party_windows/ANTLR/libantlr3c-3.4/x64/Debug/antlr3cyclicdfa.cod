; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3dfaspecialTransition
PUBLIC	antlr3dfaspecialStateTransition
PUBLIC	antlr3dfapredict
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfaspecialTransition DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$antlr3dfaspecialTransition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfaspecialStateTransition DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$antlr3dfaspecialStateTransition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfapredict DD imagerel $LN15
	DD	imagerel $LN15+745
	DD	imagerel $unwind$antlr3dfapredict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$noViableAlt DD imagerel noViableAlt
	DD	imagerel noViableAlt+180
	DD	imagerel $unwind$noViableAlt
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$noViableAlt DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfapredict DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfaspecialStateTransition DD 011501H
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfaspecialTransition DD 011501H
	DD	07015H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT noViableAlt
_TEXT	SEGMENT
rec$ = 48
cdfa$ = 56
s$ = 64
noViableAlt PROC					; COMDAT

; 54   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 55   : 	// In backtracking mode, we just set the failed flag so that the
; 56   : 	// alt can just exit right now. If we are parsing though, then 
; 57   : 	// we want the exception to be raised.
; 58   : 	//
; 59   :     if	(rec->state->backtracking > 0)

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0002d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00031	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00035	7e 0f		 jle	 SHORT $LN2@noViableAl

; 60   :     {
; 61   : 		rec->state->failed = ANTLR3_TRUE;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 62   :     }

  00044	eb 68		 jmp	 SHORT $LN3@noViableAl
$LN2@noViableAl:

; 63   : 	else
; 64   : 	{
; 65   : 		rec->exConstruct(rec);

  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00050	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 66   : 		rec->state->exception->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0005b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00063	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 67   : 		rec->state->exception->message      = cdfa->description;

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0006e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00072	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00076	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0007b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0007f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 68   : 		rec->state->exception->decisionNum  = cdfa->decisionNumber;

  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00095	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00097	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 69   : 		rec->state->exception->state        = s;

  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0009f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a7	8b 4c 24 40	 mov	 ecx, DWORD PTR s$[rsp]
  000ab	89 48 60	 mov	 DWORD PTR [rax+96], ecx
$LN3@noViableAl:

; 70   : 	}
; 71   : }

  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
noViableAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfapredict
_TEXT	SEGMENT
mark$ = 48
s$ = 56
specialState$ = 60
c$ = 64
snext$1 = 68
ctx$ = 96
rec$ = 104
is$ = 112
cdfa$ = 120
antlr3dfapredict PROC					; COMDAT

; 80   : {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 81   :     ANTLR3_MARKER	mark;
; 82   :     ANTLR3_INT32	s;
; 83   :     ANTLR3_INT32	specialState;
; 84   :     ANTLR3_INT32	c;
; 85   : 
; 86   :     mark	= is->mark(is);	    /* Store where we are right now	*/

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00032	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00037	ff 50 38	 call	 QWORD PTR [rax+56]
  0003a	48 89 44 24 30	 mov	 QWORD PTR mark$[rsp], rax

; 87   :     s		= 0;		    /* Always start with state 0	*/

  0003f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR s$[rsp], 0
$LN2@antlr3dfap:

; 88   :     
; 89   : 	for (;;)
; 90   : 	{
; 91   : 		/* Pick out any special state entry for this state
; 92   : 		 */
; 93   : 		specialState	= cdfa->special[s];

  00047	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  0004c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00051	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00055	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00058	89 44 24 3c	 mov	 DWORD PTR specialState$[rsp], eax

; 94   : 
; 95   : 		/* Transition the special state and consume an input token
; 96   : 		 */
; 97   : 		if  (specialState >= 0)

  0005c	83 7c 24 3c 00	 cmp	 DWORD PTR specialState$[rsp], 0
  00061	7c 7f		 jl	 SHORT $LN5@antlr3dfap

; 98   : 		{
; 99   : 			s = cdfa->specialStateTransition(ctx, rec, is, cdfa, specialState);

  00063	8b 44 24 3c	 mov	 eax, DWORD PTR specialState$[rsp]
  00067	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR cdfa$[rsp]
  00070	4c 8b 44 24 70	 mov	 r8, QWORD PTR is$[rsp]
  00075	48 8b 54 24 68	 mov	 rdx, QWORD PTR rec$[rsp]
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR cdfa$[rsp]
  00084	ff 50 10	 call	 QWORD PTR [rax+16]
  00087	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 100  : 
; 101  : 			// Error?
; 102  : 			//
; 103  : 			if	(s<0)

  0008b	83 7c 24 38 00	 cmp	 DWORD PTR s$[rsp], 0
  00090	7d 3e		 jge	 SHORT $LN6@antlr3dfap

; 104  : 			{
; 105  : 				// If the predicate/rule raised an exception then we leave it
; 106  : 				// in tact, else we have an NVA.
; 107  : 				//
; 108  : 				if	(rec->state->error != ANTLR3_TRUE)

  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$[rsp]
  00097	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009e	83 f8 01	 cmp	 eax, 1
  000a1	74 14		 je	 SHORT $LN7@antlr3dfap

; 109  : 				{
; 110  : 					noViableAlt(rec,cdfa, s);

  000a3	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  000a8	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  000ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  000b2	e8 00 00 00 00	 call	 noViableAlt
$LN7@antlr3dfap:

; 111  : 				}
; 112  : 				is->rewind(is, mark);

  000b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  000bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  000c1	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  000c6	ff 50 48	 call	 QWORD PTR [rax+72]

; 113  : 				return	0;

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 13 02 00 00	 jmp	 $LN1@antlr3dfap
$LN6@antlr3dfap:

; 114  : 			}
; 115  : 			is->consume(is);

  000d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  000d5	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  000da	ff 50 28	 call	 QWORD PTR [rax+40]

; 116  : 			continue;

  000dd	e9 65 ff ff ff	 jmp	 $LN2@antlr3dfap
$LN5@antlr3dfap:

; 117  : 		}
; 118  : 
; 119  : 		/* Accept state?
; 120  : 		 */
; 121  : 		if  (cdfa->accept[s] >= 1)

  000e2	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  000ec	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000f0	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  000f4	7c 28		 jl	 SHORT $LN8@antlr3dfap

; 122  : 		{
; 123  : 			is->rewind(is, mark);

  000f6	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  000fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00105	ff 50 48	 call	 QWORD PTR [rax+72]

; 124  : 			return  cdfa->accept[s];

  00108	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00112	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00116	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00119	e9 c5 01 00 00	 jmp	 $LN1@antlr3dfap
$LN8@antlr3dfap:

; 125  : 		}
; 126  : 
; 127  : 		/* Look for a normal transition state based upon the input token element
; 128  : 		 */
; 129  : 		c = is->_LA(is, 1);

  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00128	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  0012d	ff 50 30	 call	 QWORD PTR [rax+48]
  00130	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax

; 130  : 
; 131  : 		/* Check against min and max for this state
; 132  : 		 */
; 133  : 		if  (c>= cdfa->min[s] && c <= cdfa->max[s])

  00134	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00139	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0013e	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00142	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00145	39 44 24 40	 cmp	 DWORD PTR c$[rsp], eax
  00149	0f 8c dd 00 00
	00		 jl	 $LN9@antlr3dfap
  0014f	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00154	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00159	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0015d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00160	39 44 24 40	 cmp	 DWORD PTR c$[rsp], eax
  00164	0f 8f c2 00 00
	00		 jg	 $LN9@antlr3dfap

; 134  : 		{
; 135  : 			ANTLR3_INT32   snext;
; 136  : 
; 137  : 			/* What is the next state?
; 138  : 			 */
; 139  : 			snext = cdfa->transition[s][c - cdfa->min[s]];

  0016a	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  0016f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00174	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00178	48 63 54 24 38	 movsxd	 rdx, DWORD PTR s$[rsp]
  0017d	4c 8b 44 24 78	 mov	 r8, QWORD PTR cdfa$[rsp]
  00182	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  00186	41 8b 14 90	 mov	 edx, DWORD PTR [r8+rdx*4]
  0018a	44 8b 44 24 40	 mov	 r8d, DWORD PTR c$[rsp]
  0018f	44 2b c2	 sub	 r8d, edx
  00192	41 8b d0	 mov	 edx, r8d
  00195	48 63 d2	 movsxd	 rdx, edx
  00198	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0019c	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  0019f	89 44 24 44	 mov	 DWORD PTR snext$1[rsp], eax

; 140  : 
; 141  : 			if	(snext < 0)

  001a3	83 7c 24 44 00	 cmp	 DWORD PTR snext$1[rsp], 0
  001a8	7d 68		 jge	 SHORT $LN10@antlr3dfap

; 142  : 			{
; 143  : 				/* Was in range but not a normal transition
; 144  : 				 * must check EOT, which is like the else clause.
; 145  : 				 * eot[s]>=0 indicates that an EOT edge goes to another
; 146  : 				 * state.
; 147  : 				 */
; 148  : 				if  (cdfa->eot[s] >= 0)

  001aa	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  001af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  001b4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001b8	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  001bc	7c 27		 jl	 SHORT $LN11@antlr3dfap

; 149  : 				{
; 150  : 					s = cdfa->eot[s];

  001be	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  001c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  001c8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001cc	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001cf	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 151  : 					is->consume(is);

  001d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  001dd	ff 50 28	 call	 QWORD PTR [rax+40]

; 152  : 					continue;

  001e0	e9 62 fe ff ff	 jmp	 $LN2@antlr3dfap
$LN11@antlr3dfap:

; 153  : 				}
; 154  : 				noViableAlt(rec,cdfa, s);

  001e5	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  001ea	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  001ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  001f4	e8 00 00 00 00	 call	 noViableAlt

; 155  : 				is->rewind(is, mark);

  001f9	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  001fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00203	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00208	ff 50 48	 call	 QWORD PTR [rax+72]

; 156  : 				return	0;

  0020b	33 c0		 xor	 eax, eax
  0020d	e9 d1 00 00 00	 jmp	 $LN1@antlr3dfap
$LN10@antlr3dfap:

; 157  : 			}
; 158  : 
; 159  : 			/* New current state - move to it
; 160  : 			 */
; 161  : 			s	= snext;

  00212	8b 44 24 44	 mov	 eax, DWORD PTR snext$1[rsp]
  00216	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 162  : 			is->consume(is);

  0021a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0021f	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00224	ff 50 28	 call	 QWORD PTR [rax+40]

; 163  : 			continue;

  00227	e9 1b fe ff ff	 jmp	 $LN2@antlr3dfap
$LN9@antlr3dfap:

; 164  : 		}
; 165  : 		/* EOT Transition?
; 166  : 		 */
; 167  : 		if  (cdfa->eot[s] >= 0)

  0022c	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00231	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00236	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0023a	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  0023e	7c 27		 jl	 SHORT $LN12@antlr3dfap

; 168  : 		{
; 169  : 			s	= cdfa->eot[s];

  00240	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00245	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0024a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0024e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00251	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 170  : 			is->consume(is);

  00255	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0025a	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  0025f	ff 50 28	 call	 QWORD PTR [rax+40]

; 171  : 			continue;

  00262	e9 e0 fd ff ff	 jmp	 $LN2@antlr3dfap
$LN12@antlr3dfap:

; 172  : 		}
; 173  : 		/* EOF transition to accept state?
; 174  : 		 */
; 175  : 		if  ( c == ANTLR3_TOKEN_EOF && cdfa->eof[s] >= 0)

  00267	83 7c 24 40 ff	 cmp	 DWORD PTR c$[rsp], -1	; ffffffffH
  0026c	75 46		 jne	 SHORT $LN13@antlr3dfap
  0026e	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00273	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00278	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0027c	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00280	7c 32		 jl	 SHORT $LN13@antlr3dfap

; 176  : 		{
; 177  : 			is->rewind(is, mark);

  00282	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  00287	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0028c	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00291	ff 50 48	 call	 QWORD PTR [rax+72]

; 178  : 			return  cdfa->accept[cdfa->eof[s]];

  00294	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00299	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0029e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002a2	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  002a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  002ab	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002af	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002b2	eb 2f		 jmp	 SHORT $LN1@antlr3dfap
$LN13@antlr3dfap:

; 179  : 		}
; 180  : 
; 181  : 		/* No alt, so bomb
; 182  : 		 */
; 183  : 		noViableAlt(rec, cdfa, s);

  002b4	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  002b9	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  002be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  002c3	e8 00 00 00 00	 call	 noViableAlt

; 184  : 		is->rewind(is, mark);

  002c8	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  002cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  002d2	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  002d7	ff 50 48	 call	 QWORD PTR [rax+72]

; 185  : 		return 0;

  002da	33 c0		 xor	 eax, eax
  002dc	eb 05		 jmp	 SHORT $LN1@antlr3dfap

; 186  : 	}

  002de	e9 64 fd ff ff	 jmp	 $LN2@antlr3dfap
$LN1@antlr3dfap:

; 187  : 
; 188  : }

  002e3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002e7	5f		 pop	 rdi
  002e8	c3		 ret	 0
antlr3dfapredict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfaspecialStateTransition
_TEXT	SEGMENT
ctx$ = 16
recognizer$ = 24
is$ = 32
dfa$ = 40
s$ = 48
antlr3dfaspecialStateTransition PROC			; COMDAT

; 194  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 195  :     return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1

; 196  : }

  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
antlr3dfaspecialStateTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfaspecialTransition
_TEXT	SEGMENT
ctx$ = 16
recognizer$ = 24
is$ = 32
dfa$ = 40
s$ = 48
antlr3dfaspecialTransition PROC				; COMDAT

; 202  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 203  :     return 0;

  00015	33 c0		 xor	 eax, eax

; 204  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
antlr3dfaspecialTransition ENDP
_TEXT	ENDS
END
