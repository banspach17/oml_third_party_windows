; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ANTLR3_TREE_ADAPTORNew
PUBLIC	ANTLR3_TREE_ADAPTORDebugNew
PUBLIC	??_C@_0BA@IPNBIIJO@Tree?5Error?5Node?$AA@	; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	antlr3ArboretumNew:PROC
EXTRN	antlr3BaseTreeAdaptorInit:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ANTLR3_TREE_ADAPTORNew DD imagerel $LN4
	DD	imagerel $LN4+569
	DD	imagerel $unwind$ANTLR3_TREE_ADAPTORNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ANTLR3_TREE_ADAPTORDebugNew DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$ANTLR3_TREE_ADAPTORDebugNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupNode DD imagerel dupNode
	DD	imagerel dupNode+83
	DD	imagerel $unwind$dupNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$create DD imagerel create
	DD	imagerel create+102
	DD	imagerel $unwind$create
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreate DD imagerel dbgCreate
	DD	imagerel dbgCreate+95
	DD	imagerel $unwind$dbgCreate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createToken DD imagerel createToken
	DD	imagerel createToken+176
	DD	imagerel $unwind$createToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTokenFromToken DD imagerel createTokenFromToken
	DD	imagerel createTokenFromToken+403
	DD	imagerel $unwind$createTokenFromToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+57
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+57
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+63
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+57
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replaceChildren DD imagerel replaceChildren
	DD	imagerel replaceChildren+86
	DD	imagerel $unwind$replaceChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setDebugEventListener DD imagerel setDebugEventListener
	DD	imagerel setDebugEventListener+94
	DD	imagerel $unwind$setDebugEventListener
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChildIndex DD imagerel setChildIndex
	DD	imagerel setChildIndex+63
	DD	imagerel $unwind$setChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildIndex DD imagerel getChildIndex
	DD	imagerel getChildIndex+57
	DD	imagerel $unwind$getChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setParent DD imagerel setParent
	DD	imagerel setParent+67
	DD	imagerel $unwind$setParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getParent DD imagerel getParent
	DD	imagerel getParent+57
	DD	imagerel $unwind$getParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChild DD imagerel setChild
	DD	imagerel setChild+76
	DD	imagerel $unwind$setChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deleteChild DD imagerel deleteChild
	DD	imagerel deleteChild+63
	DD	imagerel $unwind$deleteChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$errorNode DD imagerel errorNode
	DD	imagerel errorNode+76
	DD	imagerel $unwind$errorNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenBoundaries DD imagerel setTokenBoundaries
	DD	imagerel setTokenBoundaries+182
	DD	imagerel $unwind$setTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgSetTokenBoundaries DD imagerel dbgSetTokenBoundaries
	DD	imagerel dbgSetTokenBoundaries+187
	DD	imagerel $unwind$dbgSetTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenStartIndex DD imagerel getTokenStartIndex
	DD	imagerel getTokenStartIndex+25
	DD	imagerel $unwind$getTokenStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenStopIndex DD imagerel getTokenStopIndex
	DD	imagerel getTokenStopIndex+25
	DD	imagerel $unwind$getTokenStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ctaFree DD imagerel ctaFree
	DD	imagerel ctaFree+130
	DD	imagerel $unwind$ctaFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BA@IPNBIIJO@Tree?5Error?5Node?$AA@
CONST	SEGMENT
??_C@_0BA@IPNBIIJO@Tree?5Error?5Node?$AA@ DB 'Tree Error Node', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ctaFree DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenStopIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenStartIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgSetTokenBoundaries DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenBoundaries DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$errorNode DD 022d01H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deleteChild DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChild DD 022d01H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getParent DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setParent DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildIndex DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChildIndex DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setDebugEventListener DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replaceChildren DD 022d01H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTokenFromToken DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createToken DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreate DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupNode DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ANTLR3_TREE_ADAPTORDebugNew DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ANTLR3_TREE_ADAPTORNew DD 021e01H
	DD	07006520aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ctaFree
_TEXT	SEGMENT
cta$ = 32
tv77 = 40
adaptor$ = 64
ctaFree	PROC						; COMDAT

; 217  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 218  :     pANTLR3_COMMON_TREE_ADAPTOR cta;
; 219  : 
; 220  :     cta	= (pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 89 44 24 20	 mov	 QWORD PTR cta$[rsp], rax

; 221  : 
; 222  :     /* Free the tree factory we created
; 223  :      */
; 224  :     cta->arboretum->close(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum);

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  00038	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0003f	48 89 4c 24 28	 mov	 QWORD PTR tv77[rsp], rcx
  00044	48 8b 88 60 01
	00 00		 mov	 rcx, QWORD PTR [rax+352]
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv77[rsp]
  00050	ff 90 70 01 00
	00		 call	 QWORD PTR [rax+368]

; 225  : 
; 226  :     /* Free the token factory we created
; 227  :      */
; 228  :     adaptor->tokenFactory->close(adaptor->tokenFactory);

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00064	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00068	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 229  : 
; 230  :     /* Free the super pointer, as it is this that was allocated
; 231  :      * and is the common tree structure.
; 232  :      */
; 233  :     ANTLR3_FREE(adaptor->super);

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00073	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 234  : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
ctaFree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getTokenStopIndex
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getTokenStopIndex PROC					; COMDAT

; 427  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 428  :     return  ((pANTLR3_COMMON_TREE)(t->super))->stopIndex;

  0000b	48 8b 44 24 18	 mov	 rax, QWORD PTR t$[rsp]
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 429  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getTokenStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getTokenStartIndex
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getTokenStartIndex PROC					; COMDAT

; 421  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 422  :     return  ((pANTLR3_COMMON_TREE)(t->super))->startIndex;

  0000b	48 8b 44 24 18	 mov	 rax, QWORD PTR t$[rsp]
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 423  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getTokenStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dbgSetTokenBoundaries
_TEXT	SEGMENT
tv74 = 32
tv84 = 40
adaptor$ = 64
t$ = 72
startToken$ = 80
stopToken$ = 88
dbgSetTokenBoundaries PROC				; COMDAT

; 410  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 411  : 	setTokenBoundaries(adaptor, t, startToken, stopToken);

  0002d	4c 8b 4c 24 58	 mov	 r9, QWORD PTR stopToken$[rsp]
  00032	4c 8b 44 24 50	 mov	 r8, QWORD PTR startToken$[rsp]
  00037	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00041	e8 00 00 00 00	 call	 setTokenBoundaries

; 412  : 
; 413  : 	if	(t != NULL && startToken != NULL && stopToken != NULL)

  00046	48 83 7c 24 48
	00		 cmp	 QWORD PTR t$[rsp], 0
  0004c	74 67		 je	 SHORT $LN2@dbgSetToke
  0004e	48 83 7c 24 50
	00		 cmp	 QWORD PTR startToken$[rsp], 0
  00054	74 5f		 je	 SHORT $LN2@dbgSetToke
  00056	48 83 7c 24 58
	00		 cmp	 QWORD PTR stopToken$[rsp], 0
  0005c	74 57		 je	 SHORT $LN2@dbgSetToke

; 414  : 	{
; 415  : 		adaptor->debugger->setTokenBoundaries(adaptor->debugger, t, startToken->getTokenIndex(startToken), stopToken->getTokenIndex(stopToken));

  0005e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR stopToken$[rsp]
  00063	48 8b 44 24 58	 mov	 rax, QWORD PTR stopToken$[rsp]
  00068	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0006e	48 89 44 24 20	 mov	 QWORD PTR tv74[rsp], rax
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR startToken$[rsp]
  00078	48 8b 54 24 50	 mov	 rdx, QWORD PTR startToken$[rsp]
  0007d	ff 92 d0 00 00
	00		 call	 QWORD PTR [rdx+208]
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00088	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0008c	48 89 4c 24 28	 mov	 QWORD PTR tv84[rsp], rcx
  00091	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv74[rsp]
  00096	4c 8b ca	 mov	 r9, rdx
  00099	4c 8b c0	 mov	 r8, rax
  0009c	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  000a6	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR tv84[rsp]
  000af	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
$LN2@dbgSetToke:

; 416  : 	}
; 417  : }

  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
dbgSetTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setTokenBoundaries
_TEXT	SEGMENT
start$ = 32
stop$ = 40
ct$ = 48
adaptor$ = 80
t$ = 88
startToken$ = 96
stopToken$ = 104
setTokenBoundaries PROC					; COMDAT

; 373  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 374  : 	ANTLR3_MARKER   start;
; 375  : 	ANTLR3_MARKER   stop;
; 376  : 
; 377  : 	pANTLR3_COMMON_TREE	    ct;
; 378  : 
; 379  : 	if	(t == NULL)

  0002d	48 83 7c 24 58
	00		 cmp	 QWORD PTR t$[rsp], 0
  00033	75 02		 jne	 SHORT $LN2@setTokenBo

; 380  : 	{
; 381  : 		return;

  00035	eb 79		 jmp	 SHORT $LN1@setTokenBo
$LN2@setTokenBo:

; 382  : 	}
; 383  : 
; 384  : 	if	( startToken != NULL)

  00037	48 83 7c 24 60
	00		 cmp	 QWORD PTR startToken$[rsp], 0
  0003d	74 17		 je	 SHORT $LN3@setTokenBo

; 385  : 	{
; 386  : 		start = startToken->getTokenIndex(startToken);

  0003f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR startToken$[rsp]
  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR startToken$[rsp]
  00049	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0004f	48 89 44 24 20	 mov	 QWORD PTR start$[rsp], rax

; 387  : 	}

  00054	eb 09		 jmp	 SHORT $LN4@setTokenBo
$LN3@setTokenBo:

; 388  : 	else
; 389  : 	{
; 390  : 		start = 0;

  00056	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN4@setTokenBo:

; 391  : 	}
; 392  : 
; 393  : 	if	( stopToken != NULL)

  0005f	48 83 7c 24 68
	00		 cmp	 QWORD PTR stopToken$[rsp], 0
  00065	74 17		 je	 SHORT $LN5@setTokenBo

; 394  : 	{
; 395  : 		stop = stopToken->getTokenIndex(stopToken);

  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR stopToken$[rsp]
  0006c	48 8b 44 24 68	 mov	 rax, QWORD PTR stopToken$[rsp]
  00071	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00077	48 89 44 24 28	 mov	 QWORD PTR stop$[rsp], rax

; 396  : 	}

  0007c	eb 09		 jmp	 SHORT $LN6@setTokenBo
$LN5@setTokenBo:

; 397  : 	else
; 398  : 	{
; 399  : 		stop = 0;

  0007e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR stop$[rsp], 0
$LN6@setTokenBo:

; 400  : 	}
; 401  : 
; 402  : 	ct	= (pANTLR3_COMMON_TREE)(t->super);

  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 89 44 24 30	 mov	 QWORD PTR ct$[rsp], rax

; 403  : 
; 404  : 	ct->startIndex  = start;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR ct$[rsp]
  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR start$[rsp]
  0009e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 405  : 	ct->stopIndex   = stop;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR ct$[rsp]
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR stop$[rsp]
  000ac	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN1@setTokenBo:

; 406  : 
; 407  : }

  000b0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT errorNode
_TEXT	SEGMENT
adaptor$ = 48
ctnstream$ = 56
startToken$ = 64
stopToken$ = 72
e$ = 80
errorNode PROC						; COMDAT

; 240  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 241  : 	// Use the supplied common tree node stream to get another tree from the factory
; 242  : 	// TODO: Look at creating the erronode as in Java, but this is complicated by the
; 243  : 	// need to track and free the memory allocated to it, so for now, we just
; 244  : 	// want something in the tree that isn't a NULL pointer.
; 245  : 	//
; 246  : 	return adaptor->createTypeText(adaptor, ANTLR3_TOKEN_INVALID, (pANTLR3_UINT8)"Tree Error Node");

  0002d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@IPNBIIJO@Tree?5Error?5Node?$AA@
  00034	33 d2		 xor	 edx, edx
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00040	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 247  : 
; 248  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT deleteChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
deleteChild PROC					; COMDAT

; 466  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 467  : 	t->deleteChild(t, i);

  00028	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0002c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00036	ff 50 48	 call	 QWORD PTR [rax+72]

; 468  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
child$ = 72
setChild PROC						; COMDAT

; 460  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 461  : 	t->setChild(t, i, child);

  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR child$[rsp]
  00032	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0003b	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00040	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 462  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getParent
_TEXT	SEGMENT
adaptor$ = 48
child$ = 56
getParent PROC						; COMDAT

; 494  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 495  : 	return child->getParent(child);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR child$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR child$[rsp]
  0002d	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]

; 496  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
getParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setParent
_TEXT	SEGMENT
adaptor$ = 48
child$ = 56
parent$ = 64
setParent PROC						; COMDAT

; 489  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 490  : 	child->setParent(child, parent);

  00028	48 8b 54 24 40	 mov	 rdx, QWORD PTR parent$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR child$[rsp]
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR child$[rsp]
  00037	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 491  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
setParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChildIndex
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getChildIndex PROC					; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 485  : 	return t->getChildIndex(t);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 486  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
getChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setChildIndex
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
setChildIndex PROC					; COMDAT

; 478  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 479  : 	t->setChildIndex(t, i);

  00028	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0002c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00036	ff 50 78	 call	 QWORD PTR [rax+120]

; 480  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
setChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setDebugEventListener
_TEXT	SEGMENT
adaptor$ = 48
debugger$ = 56
setDebugEventListener PROC				; COMDAT

; 203  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 204  : 	// Reinitialize as a debug version
; 205  : 	//
; 206  : 	antlr3BaseTreeAdaptorInit(adaptor, debugger);

  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR debugger$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 207  : 
; 208  : 	adaptor->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreate
  0003e	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 209  :                                     dbgCreate;
; 210  : 	adaptor->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSetTokenBoundaries
  00051	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 211  :                                     dbgSetTokenBoundaries;
; 212  : 
; 213  : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
setDebugEventListener ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT replaceChildren
_TEXT	SEGMENT
adaptor$ = 48
parent$ = 56
startChildIndex$ = 64
stopChildIndex$ = 72
t$ = 80
replaceChildren PROC					; COMDAT

; 446  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 447  : 	if	(parent != NULL)

  0002d	48 83 7c 24 38
	00		 cmp	 QWORD PTR parent$[rsp], 0
  00033	74 1b		 je	 SHORT $LN2@replaceChi

; 448  : 	{
; 449  : 		parent->replaceChildren(parent, startChildIndex, stopChildIndex, t);

  00035	4c 8b 4c 24 50	 mov	 r9, QWORD PTR t$[rsp]
  0003a	44 8b 44 24 48	 mov	 r8d, DWORD PTR stopChildIndex$[rsp]
  0003f	8b 54 24 40	 mov	 edx, DWORD PTR startChildIndex$[rsp]
  00043	48 8b 4c 24 38	 mov	 rcx, QWORD PTR parent$[rsp]
  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR parent$[rsp]
  0004d	ff 50 50	 call	 QWORD PTR [rax+80]
$LN2@replaceChi:

; 450  : 	}
; 451  : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChildCount
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getChildCount PROC					; COMDAT

; 472  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 473  : 	return t->getChildCount(t);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 474  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
getChild PROC						; COMDAT

; 455  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 456  : 	return t->getChild(t, i);

  00028	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0002c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00036	ff 50 70	 call	 QWORD PTR [rax+112]

; 457  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getType
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getType	PROC						; COMDAT

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 440  :     return  t->getType(t);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 441  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getText	PROC						; COMDAT

; 433  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 434  :     return  t->getText(t);

  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 435  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT createTokenFromToken
_TEXT	SEGMENT
newToken$ = 32
text$1 = 40
adaptor$ = 64
fromToken$ = 72
createTokenFromToken PROC				; COMDAT

; 328  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 329  :     pANTLR3_COMMON_TOKEN    newToken;
; 330  : 
; 331  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00031	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00035	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0003b	48 89 44 24 20	 mov	 QWORD PTR newToken$[rsp], rax

; 332  :     
; 333  :     if	(newToken != NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR newToken$[rsp], 0
  00046	0f 84 3c 01 00
	00		 je	 $LN2@createToke

; 334  :     {
; 335  : 		// Create the text using our own string factory to avoid complicating
; 336  : 		// commontoken.
; 337  : 		//
; 338  : 		pANTLR3_STRING	text;
; 339  : 
; 340  : 		newToken->toString  = fromToken->toString;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00051	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00056	48 8b 89 00 01
	00 00		 mov	 rcx, QWORD PTR [rcx+256]
  0005d	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 341  : 
; 342  : 		if	(fromToken->textState == ANTLR3_TEXT_CHARP)

  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00069	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  0006d	75 20		 jne	 SHORT $LN3@createToke

; 343  : 		{
; 344  : 			newToken->textState		= ANTLR3_TEXT_CHARP;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00074	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 345  : 			newToken->tokText.chars	= fromToken->tokText.chars;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00085	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00089	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 346  : 		}

  0008d	eb 4e		 jmp	 SHORT $LN4@createToke
$LN3@createToke:

; 347  : 		else
; 348  : 		{
; 349  : 			text						= fromToken->getText(fromToken);

  0008f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00099	ff 50 78	 call	 QWORD PTR [rax+120]
  0009c	48 89 44 24 28	 mov	 QWORD PTR text$1[rsp], rax

; 350  : 			newToken->textState			= ANTLR3_TEXT_STRING;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  000a6	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 351  : 			newToken->tokText.text	    = adaptor->strFactory->newPtr(adaptor->strFactory, text->chars, text->len);

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  000b2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR text$1[rsp]
  000bb	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  000bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR text$1[rsp]
  000c4	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000cd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d1	ff 50 20	 call	 QWORD PTR [rax+32]
  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  000d9	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN4@createToke:

; 352  : 		}
; 353  : 
; 354  : 		newToken->setLine				(newToken, fromToken->getLine(fromToken));

  000dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  000e2	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  000e7	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  000f9	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 355  : 		newToken->setTokenIndex			(newToken, fromToken->getTokenIndex(fromToken));

  000ff	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00109	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00117	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0011c	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]

; 356  : 		newToken->setCharPositionInLine	(newToken, fromToken->getCharPositionInLine(fromToken));

  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00127	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  0012c	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00132	8b d0		 mov	 edx, eax
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00139	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0013e	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 357  : 		newToken->setChannel			(newToken, fromToken->getChannel(fromToken));

  00144	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00149	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  0014e	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00154	8b d0		 mov	 edx, eax
  00156	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00160	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 358  : 		newToken->setType				(newToken, fromToken->getType(fromToken));

  00166	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  0016b	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00170	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00176	8b d0		 mov	 edx, eax
  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  0017d	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00182	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN2@createToke:

; 359  :     }
; 360  : 
; 361  :     return  newToken;

  00188	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]

; 362  : }

  0018d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00191	5f		 pop	 rdi
  00192	c3		 ret	 0
createTokenFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT createToken
_TEXT	SEGMENT
newToken$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
createToken PROC					; COMDAT

; 292  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 293  :     pANTLR3_COMMON_TOKEN    newToken;
; 294  : 
; 295  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00035	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00039	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0003f	48 89 44 24 20	 mov	 QWORD PTR newToken$[rsp], rax

; 296  : 
; 297  :     if	(newToken != NULL)

  00044	48 83 7c 24 20
	00		 cmp	 QWORD PTR newToken$[rsp], 0
  0004a	74 59		 je	 SHORT $LN2@createToke

; 298  :     {	
; 299  : 		newToken->textState		= ANTLR3_TEXT_CHARP;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00051	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 300  : 		newToken->tokText.chars = (pANTLR3_UCHAR)text;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  00062	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 301  : 		newToken->setType(newToken, tokenType);

  00066	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00074	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 302  : 		newToken->input				= adaptor->tokenFactory->input;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00088	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  0008f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 303  :         newToken->strFactory        = adaptor->strFactory;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0009d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN2@createToke:

; 304  :     }
; 305  :     return  newToken;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]

; 306  : }

  000aa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
createToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dbgCreate
_TEXT	SEGMENT
ct$ = 32
adaptor$ = 64
payload$ = 72
dbgCreate PROC						; COMDAT

; 273  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 274  : 	pANTLR3_BASE_TREE	ct;
; 275  : 
; 276  : 	ct = create(adaptor, payload);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR payload$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 create
  00032	48 89 44 24 20	 mov	 QWORD PTR ct$[rsp], rax

; 277  : 	adaptor->debugger->createNode(adaptor->debugger, ct);

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 8b 54 24 20	 mov	 rdx, QWORD PTR ct$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004e	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 278  : 
; 279  : 	return ct;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR ct$[rsp]

; 280  : }

  00059	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
dbgCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT create
_TEXT	SEGMENT
ct$ = 32
tv72 = 40
adaptor$ = 64
payload$ = 72
create	PROC						; COMDAT

; 260  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 261  :     pANTLR3_BASE_TREE	ct;
; 262  :     
; 263  :     /* Create a new common tree as this is what this adaptor deals with
; 264  :      */
; 265  :     ct = ((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum->newFromToken(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum, payload);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0003a	48 89 4c 24 28	 mov	 QWORD PTR tv72[rsp], rcx
  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR payload$[rsp]
  00044	48 8b 88 60 01
	00 00		 mov	 rcx, QWORD PTR [rax+352]
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  00050	ff 90 68 01 00
	00		 call	 QWORD PTR [rax+360]
  00056	48 89 44 24 20	 mov	 QWORD PTR ct$[rsp], rax

; 266  : 
; 267  :     /* But all adaptors return the pointer to the base interface.
; 268  :      */
; 269  :     return  ct;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR ct$[rsp]

; 270  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
create	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dupNode
_TEXT	SEGMENT
tv68 = 32
adaptor$ = 64
treeNode$ = 72
dupNode	PROC						; COMDAT

; 254  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 255  : 	return  treeNode == NULL ? NULL : treeNode->dupNode(treeNode);

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR treeNode$[rsp], 0
  00029	75 0b		 jne	 SHORT $LN3@dupNode
  0002b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00034	eb 12		 jmp	 SHORT $LN4@dupNode
$LN3@dupNode:
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR treeNode$[rsp]
  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR treeNode$[rsp]
  00040	ff 50 58	 call	 QWORD PTR [rax+88]
  00043	48 89 44 24 20	 mov	 QWORD PTR tv68[rsp], rax
$LN4@dupNode:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR tv68[rsp]

; 256  : }

  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
dupNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ANTLR3_TREE_ADAPTORDebugNew
_TEXT	SEGMENT
ta$ = 32
strFactory$ = 64
debugger$ = 72
ANTLR3_TREE_ADAPTORDebugNew PROC			; COMDAT

; 178  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 179  : 	pANTLR3_BASE_TREE_ADAPTOR	ta;
; 180  : 
; 181  : 	// Create a normal one first
; 182  : 	//
; 183  : 	ta	= ANTLR3_TREE_ADAPTORNew(strFactory);

  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00028	e8 00 00 00 00	 call	 ANTLR3_TREE_ADAPTORNew
  0002d	48 89 44 24 20	 mov	 QWORD PTR ta$[rsp], rax

; 184  : 	
; 185  : 	if	(ta != NULL)

  00032	48 83 7c 24 20
	00		 cmp	 QWORD PTR ta$[rsp], 0
  00038	74 35		 je	 SHORT $LN2@ANTLR3_TRE

; 186  : 	{
; 187  : 		// Reinitialize as a debug version
; 188  : 		//
; 189  : 		antlr3BaseTreeAdaptorInit(ta, debugger);

  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR debugger$[rsp]
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ta$[rsp]
  00044	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 190  : 		ta->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreate
  00055	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 191  : 									dbgCreate;
; 192  : 		ta->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSetTokenBoundaries
  00068	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx
$LN2@ANTLR3_TRE:

; 193  : 									dbgSetTokenBoundaries;
; 194  : 	}
; 195  : 
; 196  : 	return	ta;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]

; 197  : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
ANTLR3_TREE_ADAPTORDebugNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ANTLR3_TREE_ADAPTORNew
_TEXT	SEGMENT
cta$ = 32
strFactory$ = 64
ANTLR3_TREE_ADAPTORNew PROC				; COMDAT

; 85   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 86   : 	pANTLR3_COMMON_TREE_ADAPTOR	cta;
; 87   : 
; 88   : 	// First job is to create the memory we need for the tree adaptor interface.
; 89   : 	//
; 90   : 	cta	= (pANTLR3_COMMON_TREE_ADAPTOR) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE_ADAPTOR)));

  0001e	b9 68 01 00 00	 mov	 ecx, 360		; 00000168H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00029	48 89 44 24 20	 mov	 QWORD PTR cta$[rsp], rax

; 91   : 
; 92   : 	if	(cta == NULL)

  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR cta$[rsp], 0
  00034	75 07		 jne	 SHORT $LN2@ANTLR3_TRE

; 93   : 	{
; 94   : 		return	NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 f6 01 00 00	 jmp	 $LN1@ANTLR3_TRE
$LN2@ANTLR3_TRE:

; 95   : 	}
; 96   : 
; 97   : 	// Memory is initialized, so initialize the base tree adaptor
; 98   : 	//
; 99   : 	antlr3BaseTreeAdaptorInit(&(cta->baseAdaptor), NULL);

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00042	48 83 c0 08	 add	 rax, 8
  00046	33 d2		 xor	 edx, edx
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 100  : 
; 101  : 	// Install our interface overrides. Strangeness is to allow generated code to treat them
; 102  :     // as returning void *
; 103  : 	//
; 104  : 	cta->baseAdaptor.dupNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupNode
  0005c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 105  : 													dupNode;
; 106  : 	cta->baseAdaptor.create					=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:create
  0006f	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 107  : 													create;
; 108  : 	cta->baseAdaptor.createToken			=  

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createToken
  00082	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 109  : 													createToken;
; 110  : 	cta->baseAdaptor.createTokenFromToken   =  

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTokenFromToken
  00095	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 111  : 													createTokenFromToken;
; 112  : 	cta->baseAdaptor.setTokenBoundaries	    =  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenBoundaries
  000a8	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 113  : 													setTokenBoundaries;
; 114  : 	cta->baseAdaptor.getTokenStartIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenStartIndex
  000bb	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 115  :                                                     getTokenStartIndex;
; 116  : 	cta->baseAdaptor.getTokenStopIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000c2	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenStopIndex
  000ce	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 117  :                                                     getTokenStopIndex;
; 118  : 	cta->baseAdaptor.getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000d5	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  000e1	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 119  :                                                     getText;
; 120  : 	cta->baseAdaptor.getType				=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  000f4	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 121  :                                                     getType;
; 122  : 	cta->baseAdaptor.getChild				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  00107	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 123  :                                                     getChild;
; 124  : 	cta->baseAdaptor.setChild				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32, void *))

  0010e	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChild
  0011a	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 125  :                                                     setChild;
; 126  : 	cta->baseAdaptor.setParent				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setParent
  0012d	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 127  :                                                     setParent;
; 128  :     cta->baseAdaptor.getParent				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getParent
  0013d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 129  :                                                     getParent;
; 130  : 	cta->baseAdaptor.setChildIndex			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  00141	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChildIndex
  0014d	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 131  :                                                     setChildIndex;
; 132  : 	cta->baseAdaptor.deleteChild			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:deleteChild
  00160	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 133  :                                                     deleteChild;
; 134  : 	cta->baseAdaptor.getChildCount			=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  00173	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 135  :                                                     getChildCount;
; 136  : 	cta->baseAdaptor.getChildIndex			=  (ANTLR3_INT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildIndex
  00186	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 137  :                                                     getChildIndex;
; 138  : 	cta->baseAdaptor.free					=  (void  (*) (pANTLR3_BASE_TREE_ADAPTOR))

  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ctaFree
  00199	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 139  :                                                     ctaFree;
; 140  : 	cta->baseAdaptor.setDebugEventListener	=  

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setDebugEventListener
  001ac	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 141  : 													setDebugEventListener;
; 142  : 	cta->baseAdaptor.replaceChildren		=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_INT32, ANTLR3_INT32, void *))

  001b3	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:replaceChildren
  001bf	48 89 88 50 01
	00 00		 mov	 QWORD PTR [rax+336], rcx

; 143  :                                                     replaceChildren;
; 144  : 	cta->baseAdaptor.errorNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_TOKEN_STREAM, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN, pANTLR3_EXCEPTION))

  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:errorNode
  001d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 145  :                                                     errorNode;
; 146  : 
; 147  : 	// Install the super class pointer
; 148  : 	//
; 149  : 	cta->baseAdaptor.super	    = cta;

  001d6	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  001e0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 150  : 
; 151  : 	// Install a tree factory for creating new tree nodes
; 152  : 	//
; 153  : 	cta->arboretum  = antlr3ArboretumNew(strFactory);

  001e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  001e9	e8 00 00 00 00	 call	 antlr3ArboretumNew
  001ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  001f3	48 89 81 60 01
	00 00		 mov	 QWORD PTR [rcx+352], rax

; 154  : 
; 155  : 	// Install a token factory for imaginary tokens, these imaginary
; 156  : 	// tokens do not require access to the input stream so we can
; 157  : 	// dummy the creation of it, but they will need a string factory.
; 158  : 	//
; 159  : 	cta->baseAdaptor.tokenFactory						= antlr3TokenFactoryNew(NULL);

  001fa	33 c9		 xor	 ecx, ecx
  001fc	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  00201	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  00206	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 160  : 	cta->baseAdaptor.tokenFactory->unTruc.strFactory	= strFactory;

  0020a	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0020f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00213	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00218	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 161  : 
; 162  : 	// Allow the base tree adaptor to share the tree factory's string factory.
; 163  : 	//
; 164  : 	cta->baseAdaptor.strFactory	= strFactory;

  0021c	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00221	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00226	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 165  : 
; 166  : 	// Return the address of the base adaptor interface.
; 167  : 	//
; 168  : 	return  &(cta->baseAdaptor);

  0022a	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0022f	48 83 c0 08	 add	 rax, 8
$LN1@ANTLR3_TRE:

; 169  : }

  00233	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00237	5f		 pop	 rdi
  00238	c3		 ret	 0
ANTLR3_TREE_ADAPTORNew ENDP
_TEXT	ENDS
END
