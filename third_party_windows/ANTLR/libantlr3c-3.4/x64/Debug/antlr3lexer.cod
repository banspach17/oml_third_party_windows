; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3LexerNewStream
PUBLIC	antlr3LexerNew
PUBLIC	??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lexe@ ; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI?$AA@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@		; `string'
PUBLIC	??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offset@ ; `string'
PUBLIC	??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6?$AA@	; `string'
PUBLIC	??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6?$AA@ ; `string'
PUBLIC	??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6?$AA@		; `string'
PUBLIC	??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicates@ ; `string'
PUBLIC	??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5li@ ; `string'
PUBLIC	??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6?$AA@ ; `string'
PUBLIC	??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so?5@ ; `string'
EXTRN	__imp_isprint:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3BaseRecognizerNew:PROC
EXTRN	antlr3RecognitionExceptionNew:PROC
EXTRN	antlr3StackNew:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	antlr3SetTokenAPI:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3LexerNewStream DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$antlr3LexerNewStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3LexerNew DD imagerel $LN7
	DD	imagerel $LN7+1041
	DD	imagerel $unwind$antlr3LexerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mTokens DD imagerel mTokens
	DD	imagerel mTokens+70
	DD	imagerel $unwind$mTokens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setCharStream DD imagerel setCharStream
	DD	imagerel setCharStream+392
	DD	imagerel $unwind$setCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pushCharStream DD imagerel pushCharStream
	DD	imagerel pushCharStream+236
	DD	imagerel $unwind$pushCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$popCharStream DD imagerel popCharStream
	DD	imagerel popCharStream+261
	DD	imagerel $unwind$popCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$emitNew DD imagerel emitNew
	DD	imagerel emitNew+35
	DD	imagerel $unwind$emitNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$emit DD	imagerel emit
	DD	imagerel emit+480
	DD	imagerel $unwind$emit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchs DD imagerel matchs
	DD	imagerel matchs+282
	DD	imagerel $unwind$matchs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchc DD imagerel matchc
	DD	imagerel matchc+225
	DD	imagerel $unwind$matchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchRange DD imagerel matchRange
	DD	imagerel matchRange+248
	DD	imagerel $unwind$matchRange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchAny DD imagerel matchAny
	DD	imagerel matchAny+73
	DD	imagerel $unwind$matchAny
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recover DD imagerel recover
	DD	imagerel recover+73
	DD	imagerel $unwind$recover
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+60
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharIndex DD imagerel getCharIndex
	DD	imagerel getCharIndex+73
	DD	imagerel $unwind$getCharIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+20
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+173
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextToken DD imagerel nextToken
	DD	imagerel nextToken+204
	DD	imagerel $unwind$nextToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$displayRecognitionError DD imagerel displayRecognitionError
	DD	imagerel displayRecognitionError+922
	DD	imagerel $unwind$displayRecognitionError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reportError DD imagerel reportError
	DD	imagerel reportError+88
	DD	imagerel $unwind$reportError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCurrentInputSymbol DD imagerel getCurrentInputSymbol
	DD	imagerel getCurrentInputSymbol+15
	DD	imagerel $unwind$getCurrentInputSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getMissingSymbol DD imagerel getMissingSymbol
	DD	imagerel getMissingSymbol+25
	DD	imagerel $unwind$getMissingSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+268
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeLexer DD imagerel freeLexer
	DD	imagerel freeLexer+347
	DD	imagerel $unwind$freeLexer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextTokenStr DD imagerel nextTokenStr
	DD	imagerel nextTokenStr+608
	DD	imagerel $unwind$nextTokenStr
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so?5@
CONST	SEGMENT
??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so?5@ DB 'is also'
	DB	' the end of the line, so you must check your lexer rules', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6?$AA@ DB 'looks '
	DB	'like this:', 0aH, 09H, 09H, '%.*s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5li@
CONST	SEGMENT
??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5li@ DB 09H, ' The'
	DB	' lexer was matching from line %d, offset %d, which', 0aH, 09H
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicates@
CONST	SEGMENT
??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicates@ DB '(en'
	DB	'd of input).', 0aH, 09H, ' This indicates a poorly specified '
	DB	'lexer RULE', 0aH, 09H, ' or unterminated input element such a'
	DB	's: "STRING["]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6?$AA@
CONST	SEGMENT
??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6?$AA@ DB 09H, '%.*s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6?$AA@ DB 'near char(%'
	DB	'#02X) :', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6?$AA@
CONST	SEGMENT
??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6?$AA@ DB 'near ''%c'' :', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offset@
CONST	SEGMENT
??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offset@ DB ':'
	DB	' lexer error %d :', 0aH, 09H, '%s at offset %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@ DB '%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI?$AA@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI?$AA@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lexe@
CONST	SEGMENT
??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lexe@ DB 'l'
	DB	'exer->mTokens(): Error: No lexer rules were added to the lexe'
	DB	'r yet!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextTokenStr DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeLexer DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getMissingSymbol DD 011501H
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCurrentInputSymbol DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reportError DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$displayRecognitionError DD 032901H
	DD	0160112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextToken DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharIndex DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recover DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchAny DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchRange DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchc DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchs DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$emit DD	021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$emitNew DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$popCharStream DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pushCharStream DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setCharStream DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mTokens DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3LexerNew DD 022101H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3LexerNewStream DD 022601H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022d01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT nextTokenStr
_TEXT	SEGMENT
lexer$ = 32
state$ = 40
input$ = 48
istream$ = 56
teof$1 = 64
toksource$ = 96
nextTokenStr PROC					; COMDAT

; 218  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 219  :     pANTLR3_LEXER                   lexer;
; 220  :     pANTLR3_RECOGNIZER_SHARED_STATE state;
; 221  :     pANTLR3_INPUT_STREAM            input;
; 222  :     pANTLR3_INT_STREAM              istream;
; 223  : 
; 224  :     lexer   = (pANTLR3_LEXER)(toksource->super);

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  00023	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  0002a	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 225  :     state   = lexer->rec->state;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00034	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00038	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003c	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 226  :     input   = lexer->input;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 89 44 24 30	 mov	 QWORD PTR input$[rsp], rax

; 227  :     istream = input->istream;

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 89 44 24 38	 mov	 QWORD PTR istream$[rsp], rax
$LN2@nextTokenS:

; 228  : 
; 229  :     /// Loop until we get a non skipped token or EOF
; 230  :     ///
; 231  :     for	(;;)
; 232  :     {
; 233  :         // Get rid of any previous token (token factory takes care of
; 234  :         // any de-allocation when this token is finally used up.
; 235  :         //
; 236  :         state->token		    = NULL;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00061	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 237  :         state->error		    = ANTLR3_FALSE;	    // Start out without an exception

  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 238  :         state->failed		    = ANTLR3_FALSE;

  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00076	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0
$LN5@nextTokenS:

; 239  : 
; 240  :         // Now call the matching rules and see if we can generate a new token
; 241  :         //
; 242  :         for	(;;)
; 243  :         {
; 244  :             // Record the start of the token in our input stream.
; 245  :             //
; 246  :             state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007f	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 247  :             state->tokenStartCharIndex	            = (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0008b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00090	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00094	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 248  :             state->tokenStartCharPositionInLine     = input->charPositionInLine;

  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000a5	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  000a8	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 249  :             state->tokenStartLine		    = input->line;

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000b5	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  000b8	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 250  :             state->text			            = NULL;

  000bb	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c0	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 251  :             state->custom                           = NULL;

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d0	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 252  :             state->user1                            = 0;

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e0	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 253  :             state->user2                            = 0;

  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ef	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 254  :             state->user3                            = 0;

  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000fe	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 255  : 
; 256  :             if  (istream->_LA(istream, 1) == ANTLR3_CHARSTREAM_EOF)

  00108	ba 01 00 00 00	 mov	 edx, 1
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR istream$[rsp]
  00112	48 8b 44 24 38	 mov	 rax, QWORD PTR istream$[rsp]
  00117	ff 50 30	 call	 QWORD PTR [rax+48]
  0011a	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0011d	0f 85 86 00 00
	00		 jne	 $LN8@nextTokenS

; 257  :             {
; 258  :                 // Reached the end of the current stream, nothing more to do if this is
; 259  :                 // the last in the stack.
; 260  :                 //
; 261  :                 pANTLR3_COMMON_TOKEN    teof = &(toksource->eofToken);

  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  00128	48 83 c0 10	 add	 rax, 16
  0012c	48 89 44 24 40	 mov	 QWORD PTR teof$1[rsp], rax

; 262  : 
; 263  :                 teof->setStartIndex (teof, lexer->getCharIndex(lexer));

  00131	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0013b	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00141	48 8b d0	 mov	 rdx, rax
  00144	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  00149	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  0014e	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 264  :                 teof->setStopIndex  (teof, lexer->getCharIndex(lexer));

  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0015e	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00164	48 8b d0	 mov	 rdx, rax
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  0016c	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  00171	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]

; 265  :                 teof->setLine	    (teof, lexer->getLine(lexer));

  00177	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0017c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00181	ff 50 78	 call	 QWORD PTR [rax+120]
  00184	8b d0		 mov	 edx, eax
  00186	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  0018b	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  00190	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 266  :                 teof->factoryMade = ANTLR3_TRUE;	// This isn't really manufactured but it stops things from trying to free it

  00196	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  0019b	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 267  :                 return  teof;

  0019f	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  001a4	e9 b1 00 00 00	 jmp	 $LN1@nextTokenS
$LN8@nextTokenS:

; 268  :             }
; 269  : 
; 270  :             state->token		= NULL;

  001a9	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001ae	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 271  :             state->error		= ANTLR3_FALSE;	    // Start out without an exception

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001bb	c6 00 00	 mov	 BYTE PTR [rax], 0

; 272  :             state->failed		= ANTLR3_FALSE;

  001be	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001c3	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 273  : 
; 274  :             // Call the generated lexer, see if it can get a new token together.
; 275  :             //
; 276  :             lexer->mTokens(lexer->ctx);

  001c7	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001cc	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001d5	ff 50 48	 call	 QWORD PTR [rax+72]

; 277  : 
; 278  :             if  (state->error  == ANTLR3_TRUE)

  001d8	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001dd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e0	83 f8 01	 cmp	 eax, 1
  001e3	75 2d		 jne	 SHORT $LN9@nextTokenS

; 279  :             {
; 280  :                 // Recognition exception, report it and try to recover.
; 281  :                 //
; 282  :                 state->failed	    = ANTLR3_TRUE;

  001e5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001ea	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 283  :                 lexer->rec->reportError(lexer->rec);

  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001f3	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001f7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  001fc	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00200	ff 50 48	 call	 QWORD PTR [rax+72]

; 284  :                 lexer->recover(lexer); 

  00203	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00208	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0020d	ff 50 70	 call	 QWORD PTR [rax+112]

; 285  :             }

  00210	eb 3e		 jmp	 SHORT $LN10@nextTokenS
$LN9@nextTokenS:

; 286  :             else
; 287  :             {
; 288  :                 if (state->token == NULL)

  00212	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00217	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  0021c	75 0c		 jne	 SHORT $LN11@nextTokenS

; 289  :                 {
; 290  :                     // Emit the real token, which adds it in to the token stream basically
; 291  :                     //
; 292  :                     emit(lexer);

  0021e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00223	e8 00 00 00 00	 call	 emit

; 293  :                 }

  00228	eb 1b		 jmp	 SHORT $LN12@nextTokenS
$LN11@nextTokenS:

; 294  :                 else if	(state->token ==  &(toksource->skipToken))

  0022a	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  0022f	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  00235	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0023a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0023e	75 05		 jne	 SHORT $LN13@nextTokenS

; 295  :                 {
; 296  :                     // A real token could have been generated, but "Computer say's naaaaah" and it
; 297  :                     // it is just something we need to skip altogether.
; 298  :                     //
; 299  :                     continue;

  00240	e9 35 fe ff ff	 jmp	 $LN5@nextTokenS
$LN13@nextTokenS:
$LN12@nextTokenS:

; 300  :                 }
; 301  : 
; 302  :                 // Good token, not skipped, not EOF token
; 303  :                 //
; 304  :                 return  state->token;

  00245	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0024a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0024e	eb 0a		 jmp	 SHORT $LN1@nextTokenS
$LN10@nextTokenS:

; 305  :             }
; 306  :         }

  00250	e9 25 fe ff ff	 jmp	 $LN5@nextTokenS

; 307  :     }

  00255	e9 02 fe ff ff	 jmp	 $LN2@nextTokenS
$LN1@nextTokenS:

; 308  : }

  0025a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0025e	5f		 pop	 rdi
  0025f	c3		 ret	 0
nextTokenStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT freeLexer
_TEXT	SEGMENT
tv161 = 32
tv154 = 40
lexer$ = 64
freeLexer PROC						; COMDAT

; 689  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 690  : 	// This may have ben a delegate or delegator lexer, in which case the
; 691  : 	// state may already have been freed (and set to NULL therefore)
; 692  : 	// so we ignore the state if we don't have it.
; 693  : 	//
; 694  : 	if	(lexer->rec->state != NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002c	0f 84 e7 00 00
	00		 je	 $LN2@freeLexer

; 695  : 	{
; 696  : 		if	(lexer->rec->state->streams != NULL)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00037	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003f	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00047	74 35		 je	 SHORT $LN3@freeLexer

; 697  : 		{
; 698  : 			lexer->rec->state->streams->free(lexer->rec->state->streams);

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0004e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00052	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0005b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00063	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  0006a	48 89 4c 24 20	 mov	 QWORD PTR tv161[rsp], rcx
  0006f	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR tv161[rsp]
  0007b	ff 50 10	 call	 QWORD PTR [rax+16]
$LN3@freeLexer:

; 699  : 		}
; 700  : 		if	(lexer->rec->state->tokFactory != NULL)

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00083	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00087	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00090	74 47		 je	 SHORT $LN4@freeLexer

; 701  : 		{
; 702  : 			lexer->rec->state->tokFactory->close(lexer->rec->state->tokFactory);

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00097	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000a4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ac	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000b0	48 89 4c 24 28	 mov	 QWORD PTR tv154[rsp], rcx
  000b5	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR tv154[rsp]
  000be	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 703  : 			lexer->rec->state->tokFactory = NULL;

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000cd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d1	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN4@freeLexer:

; 704  : 		}
; 705  : 		if	(lexer->rec->state->tokSource != NULL)

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000de	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000e2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e6	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000eb	74 2c		 je	 SHORT $LN5@freeLexer

; 706  : 		{
; 707  : 			ANTLR3_FREE(lexer->rec->state->tokSource);

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000f2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fa	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 708  : 			lexer->rec->state->tokSource = NULL;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00109	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0010d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00111	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN5@freeLexer:
$LN2@freeLexer:

; 709  : 		}
; 710  : 	}
; 711  : 	if	(lexer->rec != NULL)

  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0011e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00123	74 25		 je	 SHORT $LN6@freeLexer

; 712  : 	{
; 713  : 		lexer->rec->free(lexer->rec);

  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0012a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0012e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00133	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00137	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 714  : 		lexer->rec = NULL;

  0013d	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00142	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN6@freeLexer:

; 715  : 	}
; 716  : 	ANTLR3_FREE(lexer);

  0014a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 717  : }

  00155	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00159	5f		 pop	 rdi
  0015a	c3		 ret	 0
freeLexer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT reset
_TEXT	SEGMENT
lexer$ = 32
tv130 = 40
rec$ = 64
reset	PROC						; COMDAT

; 176  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 177  :     pANTLR3_LEXER   lexer;
; 178  : 
; 179  :     lexer   = rec->super;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 180  : 
; 181  :     lexer->rec->state->token			    = NULL;

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00030	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00034	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00038	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 182  :     lexer->rec->state->type			    = ANTLR3_TOKEN_INVALID;

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00045	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [rax+116], 0

; 183  :     lexer->rec->state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00059	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00061	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 184  :     lexer->rec->state->tokenStartCharIndex	    = -1;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0006d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00071	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00075	48 c7 80 80 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+128], -1

; 185  :     lexer->rec->state->tokenStartCharPositionInLine = -1;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00085	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00089	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008d	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 186  :     lexer->rec->state->tokenStartLine		    = -1;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00099	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a1	c7 40 78 ff ff
	ff ff		 mov	 DWORD PTR [rax+120], -1

; 187  : 
; 188  :     lexer->rec->state->text	                    = NULL;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000ad	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b5	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 189  : 
; 190  :     // OK - that's all hunky dory, but we may well have had
; 191  :     // a token factory that needs a reset. Do that here
; 192  :     //
; 193  :     if  (lexer->rec->state->tokFactory != NULL)

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000c5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cd	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d2	74 32		 je	 SHORT $LN2@reset

; 194  :     {
; 195  :         lexer->rec->state->tokFactory->reset(lexer->rec->state->tokFactory);

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000d9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000dd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  000e6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000ea	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ee	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000f2	48 89 4c 24 28	 mov	 QWORD PTR tv130[rsp], rcx
  000f7	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR tv130[rsp]
  00100	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
$LN2@reset:

; 196  :     }
; 197  : }

  00106	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010a	5f		 pop	 rdi
  0010b	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getMissingSymbol
_TEXT	SEGMENT
recognizer$ = 16
istream$ = 24
e$ = 32
expectedTokenType$ = 40
follow$ = 48
getMissingSymbol PROC					; COMDAT

; 902  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 903  : 	return NULL;

  00015	33 c0		 xor	 eax, eax

; 904  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCurrentInputSymbol
_TEXT	SEGMENT
recognizer$ = 16
istream$ = 24
getCurrentInputSymbol PROC				; COMDAT

; 895  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 896  : 	return NULL;

  0000b	33 c0		 xor	 eax, eax

; 897  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT reportError
_TEXT	SEGMENT
rec$ = 48
reportError PROC					; COMDAT

; 412  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 413  :     // Indicate this recognizer had an error while processing.
; 414  : 	//
; 415  : 	rec->state->errorCount++;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0002a	ff c0		 inc	 eax
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  00031	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00035	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 416  : 
; 417  :     rec->displayRecognitionError(rec, rec->state->tokenNames);

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0003d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00041	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0004f	ff 50 50	 call	 QWORD PTR [rax+80]

; 418  : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT displayRecognitionError
_TEXT	SEGMENT
lexer$ = 48
ex$ = 56
ftext$ = 64
width$1 = 72
tv236 = 80
tv95 = 88
tv233 = 96
tv234 = 104
tv161 = 112
tv170 = 116
tv230 = 120
tv228 = 128
tv226 = 136
tv227 = 144
tv212 = 152
tv206 = 160
recognizer$ = 192
tokenNames$ = 200
displayRecognitionError PROC				; COMDAT

; 428  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]

; 429  :     pANTLR3_LEXER			lexer;
; 430  : 	pANTLR3_EXCEPTION	    ex;
; 431  : 	pANTLR3_STRING			ftext;
; 432  : 
; 433  :     lexer   = (pANTLR3_LEXER)(recognizer->super);

  00029	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 89 44 24 30	 mov	 QWORD PTR lexer$[rsp], rax

; 434  : 	ex		= lexer->rec->state->exception;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  0003e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00042	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00046	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004a	48 89 44 24 38	 mov	 QWORD PTR ex$[rsp], rax

; 435  : 
; 436  : 	// See if there is a 'filename' we can use
; 437  :     //
; 438  :     if	(ex->name == NULL)

  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  00054	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00059	75 1c		 jne	 SHORT $LN2@displayRec

; 439  :     {
; 440  : 		ANTLR3_FPRINTF(stderr, "-unknown source-(");

  0005b	b9 02 00 00 00	 mov	 ecx, 2
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI?$AA@
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 fprintf

; 441  :     }

  00075	eb 40		 jmp	 SHORT $LN3@displayRec
$LN2@displayRec:

; 442  :     else
; 443  :     {
; 444  : 		ftext = ex->streamName->to8(ex->streamName);

  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  0007c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00085	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00089	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  0008f	48 89 44 24 40	 mov	 QWORD PTR ftext$[rsp], rax

; 445  : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  00094	b9 02 00 00 00	 mov	 ecx, 2
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ftext$[rsp]
  000a4	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ECLNAHEM@?$CFs?$CI?$AA@
  000af	48 8b c8	 mov	 rcx, rax
  000b2	e8 00 00 00 00	 call	 fprintf
$LN3@displayRec:

; 446  :     }
; 447  : 
; 448  :     ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000bf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c7	48 89 44 24 50	 mov	 QWORD PTR tv236[rsp], rax
  000cc	b9 02 00 00 00	 mov	 ecx, 2
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv236[rsp]
  000dc	44 8b 41 54	 mov	 r8d, DWORD PTR [rcx+84]
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 fprintf

; 449  :     ANTLR3_FPRINTF(stderr, ": lexer error %d :\n\t%s at offset %d, ", 

  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  000f4	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000f7	ff c0		 inc	 eax
  000f9	89 44 24 58	 mov	 DWORD PTR tv95[rsp], eax
  000fd	b9 02 00 00 00	 mov	 ecx, 2
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00108	8b 4c 24 58	 mov	 ecx, DWORD PTR tv95[rsp]
  0010c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00110	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00115	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  0011e	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offset@
  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 fprintf

; 450  : 						ex->type,
; 451  : 						(pANTLR3_UINT8)	   (ex->message),
; 452  : 					    ex->charPositionInLine+1
; 453  : 		    );
; 454  : 	{
; 455  : 		ANTLR3_INT32	width;
; 456  : 
; 457  : 		width	= ANTLR3_UINT32_CAST(( (pANTLR3_UINT8)(lexer->input->data) + (lexer->input->size(lexer->input) )) - (pANTLR3_UINT8)(ex->index));

  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00135	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00139	48 89 44 24 60	 mov	 QWORD PTR tv233[rsp], rax
  0013e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  00143	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00147	48 89 4c 24 68	 mov	 QWORD PTR tv234[rsp], rcx
  0014c	48 8b 54 24 30	 mov	 rdx, QWORD PTR lexer$[rsp]
  00151	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  00155	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv234[rsp]
  0015a	ff 92 90 00 00
	00		 call	 QWORD PTR [rdx+144]
  00160	8b c0		 mov	 eax, eax
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv233[rsp]
  00167	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0016b	48 03 c8	 add	 rcx, rax
  0016e	48 8b c1	 mov	 rax, rcx
  00171	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00176	48 2b 41 28	 sub	 rax, QWORD PTR [rcx+40]
  0017a	89 44 24 48	 mov	 DWORD PTR width$1[rsp], eax

; 458  : 
; 459  : 		if	(width >= 1)

  0017e	83 7c 24 48 01	 cmp	 DWORD PTR width$1[rsp], 1
  00183	0f 8c ab 00 00
	00		 jl	 $LN4@displayRec

; 460  : 		{			
; 461  : 			if	(isprint(ex->c))

  00189	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  0018e	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00197	85 c0		 test	 eax, eax
  00199	74 25		 je	 SHORT $LN6@displayRec

; 462  : 			{
; 463  : 				ANTLR3_FPRINTF(stderr, "near '%c' :\n", ex->c);

  0019b	b9 02 00 00 00	 mov	 ecx, 2
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  001ab	44 8b 41 50	 mov	 r8d, DWORD PTR [rcx+80]
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6?$AA@
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	e8 00 00 00 00	 call	 fprintf

; 464  : 			}

  001be	eb 2e		 jmp	 SHORT $LN7@displayRec
$LN6@displayRec:

; 465  : 			else
; 466  : 			{
; 467  : 				ANTLR3_FPRINTF(stderr, "near char(%#02X) :\n", (ANTLR3_UINT8)(ex->c));

  001c0	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  001c5	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  001c9	89 44 24 70	 mov	 DWORD PTR tv161[rsp], eax
  001cd	b9 02 00 00 00	 mov	 ecx, 2
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d8	8b 4c 24 70	 mov	 ecx, DWORD PTR tv161[rsp]
  001dc	44 8b c1	 mov	 r8d, ecx
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6?$AA@
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	e8 00 00 00 00	 call	 fprintf
$LN7@displayRec:

; 468  : 			}
; 469  : 			ANTLR3_FPRINTF(stderr, "\t%.*s\n", width > 20 ? 20 : width ,((pANTLR3_UINT8)ex->index));

  001ee	83 7c 24 48 14	 cmp	 DWORD PTR width$1[rsp], 20
  001f3	7e 0a		 jle	 SHORT $LN11@displayRec
  001f5	c7 44 24 74 14
	00 00 00	 mov	 DWORD PTR tv170[rsp], 20
  001fd	eb 08		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:
  001ff	8b 44 24 48	 mov	 eax, DWORD PTR width$1[rsp]
  00203	89 44 24 74	 mov	 DWORD PTR tv170[rsp], eax
$LN12@displayRec:
  00207	b9 02 00 00 00	 mov	 ecx, 2
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00217	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0021b	44 8b 44 24 74	 mov	 r8d, DWORD PTR tv170[rsp]
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6?$AA@
  00227	48 8b c8	 mov	 rcx, rax
  0022a	e8 00 00 00 00	 call	 fprintf

; 470  : 		}

  0022f	e9 5d 01 00 00	 jmp	 $LN5@displayRec
$LN4@displayRec:

; 471  : 		else
; 472  : 		{
; 473  : 			ANTLR3_FPRINTF(stderr, "(end of input).\n\t This indicates a poorly specified lexer RULE\n\t or unterminated input element such as: \"STRING[\"]\n");

  00234	b9 02 00 00 00	 mov	 ecx, 2
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicates@
  00246	48 8b c8	 mov	 rcx, rax
  00249	e8 00 00 00 00	 call	 fprintf

; 474  : 			ANTLR3_FPRINTF(stderr, "\t The lexer was matching from line %d, offset %d, which\n\t ", 

  0024e	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00253	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00257	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0025b	48 89 44 24 78	 mov	 QWORD PTR tv230[rsp], rax
  00260	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  00265	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00269	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0026d	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv228[rsp], rcx
  00275	b9 02 00 00 00	 mov	 ecx, 2
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00280	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv230[rsp]
  00285	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]
  00289	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  00291	44 8b 41 78	 mov	 r8d, DWORD PTR [rcx+120]
  00295	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5li@
  0029c	48 8b c8	 mov	 rcx, rax
  0029f	e8 00 00 00 00	 call	 fprintf

; 475  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartLine),
; 476  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartCharPositionInLine)
; 477  : 								);
; 478  : 			width = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)(lexer->input->data)+(lexer->input->size(lexer->input))) - (pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  002a4	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  002a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002ad	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  002b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  002ba	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002be	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv227[rsp], rcx
  002c6	48 8b 54 24 30	 mov	 rdx, QWORD PTR lexer$[rsp]
  002cb	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  002cf	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv227[rsp]
  002d7	ff 92 90 00 00
	00		 call	 QWORD PTR [rdx+144]
  002dd	8b c0		 mov	 eax, eax
  002df	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  002e7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002eb	48 03 c8	 add	 rcx, rax
  002ee	48 8b c1	 mov	 rax, rcx
  002f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  002f6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002fa	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002fe	48 2b 81 80 00
	00 00		 sub	 rax, QWORD PTR [rcx+128]
  00305	89 44 24 48	 mov	 DWORD PTR width$1[rsp], eax

; 479  : 
; 480  : 			if	(width >= 1)

  00309	83 7c 24 48 01	 cmp	 DWORD PTR width$1[rsp], 1
  0030e	7c 67		 jl	 SHORT $LN8@displayRec

; 481  : 			{
; 482  : 				ANTLR3_FPRINTF(stderr, "looks like this:\n\t\t%.*s\n", width > 20 ? 20 : width ,(pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  00310	83 7c 24 48 14	 cmp	 DWORD PTR width$1[rsp], 20
  00315	7e 0d		 jle	 SHORT $LN13@displayRec
  00317	c7 84 24 98 00
	00 00 14 00 00
	00		 mov	 DWORD PTR tv212[rsp], 20
  00322	eb 0b		 jmp	 SHORT $LN14@displayRec
$LN13@displayRec:
  00324	8b 44 24 48	 mov	 eax, DWORD PTR width$1[rsp]
  00328	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
$LN14@displayRec:
  0032f	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00334	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00338	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0033c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  00344	b9 02 00 00 00	 mov	 ecx, 2
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  00357	4c 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [rcx+128]
  0035e	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR tv212[rsp]
  00366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6?$AA@
  0036d	48 8b c8	 mov	 rcx, rax
  00370	e8 00 00 00 00	 call	 fprintf

; 483  : 			}

  00375	eb 1a		 jmp	 SHORT $LN9@displayRec
$LN8@displayRec:

; 484  : 			else
; 485  : 			{
; 486  : 				ANTLR3_FPRINTF(stderr, "is also the end of the line, so you must check your lexer rules\n");

  00377	b9 02 00 00 00	 mov	 ecx, 2
  0037c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so?5@
  00389	48 8b c8	 mov	 rcx, rax
  0038c	e8 00 00 00 00	 call	 fprintf
$LN9@displayRec:
$LN5@displayRec:

; 487  : 			}
; 488  : 		}
; 489  : 	}
; 490  : }

  00391	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00398	5f		 pop	 rdi
  00399	c3		 ret	 0
displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT nextToken
_TEXT	SEGMENT
tok$ = 32
lexer$1 = 40
tv87 = 48
toksource$ = 80
nextToken PROC						; COMDAT

; 331  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 332  : 	pANTLR3_COMMON_TOKEN tok;
; 333  : 
; 334  : 	// Find the next token in the current stream
; 335  : 	//
; 336  : 	tok = nextTokenStr(toksource);

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR toksource$[rsp]
  00023	e8 00 00 00 00	 call	 nextTokenStr
  00028	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax
$LN2@nextToken:

; 337  : 
; 338  : 	// If we got to the EOF token then switch to the previous
; 339  : 	// input stream if there were any and just return the
; 340  : 	// EOF if there are none. We must check the next token
; 341  : 	// in any outstanding input stream we pop into the active
; 342  : 	// role to see if it was sitting at EOF after PUSHing the
; 343  : 	// stream we just consumed, otherwise we will return EOF
; 344  : 	// on the reinstalled input stream, when in actual fact
; 345  : 	// there might be more input streams to POP before the
; 346  : 	// real EOF of the whole logical inptu stream. Hence we
; 347  : 	// use a while loop here until we find somethign in the stream
; 348  : 	// that isn't EOF or we reach the actual end of the last input
; 349  : 	// stream on the stack.
; 350  : 	//
; 351  : 	while	(tok->type == ANTLR3_TOKEN_EOF)

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00032	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00035	0f 85 86 00 00
	00		 jne	 $LN3@nextToken

; 352  : 	{
; 353  : 		pANTLR3_LEXER   lexer;
; 354  : 
; 355  : 		lexer   = (pANTLR3_LEXER)(toksource->super);

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR toksource$[rsp]
  00040	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00047	48 89 44 24 28	 mov	 QWORD PTR lexer$1[rsp], rax

; 356  : 
; 357  : 		if  (lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  00051	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00055	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00059	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00061	74 57		 je	 SHORT $LN4@nextToken
  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  00068	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lexer$1[rsp]
  00075	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00079	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007d	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  00084	48 89 4c 24 30	 mov	 QWORD PTR tv87[rsp], rcx
  00089	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00090	48 8b 44 24 30	 mov	 rax, QWORD PTR tv87[rsp]
  00095	ff 50 30	 call	 QWORD PTR [rax+48]
  00098	85 c0		 test	 eax, eax
  0009a	76 1e		 jbe	 SHORT $LN4@nextToken

; 358  : 		{
; 359  : 			// We have another input stream in the stack so we
; 360  : 			// need to revert to it, then resume the loop to check
; 361  : 			// it wasn't sitting at EOF itself.
; 362  : 			//
; 363  : 			lexer->popCharStream(lexer);

  0009c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lexer$1[rsp]
  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  000a6	ff 50 30	 call	 QWORD PTR [rax+48]

; 364  : 			tok = nextTokenStr(toksource);

  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR toksource$[rsp]
  000ae	e8 00 00 00 00	 call	 nextTokenStr
  000b3	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 365  : 		}

  000b8	eb 02		 jmp	 SHORT $LN5@nextToken
$LN4@nextToken:

; 366  : 		else
; 367  : 		{
; 368  : 			// There were no more streams on the input stack
; 369  : 			// so this EOF is the 'real' logical EOF for
; 370  : 			// the input stream. So we just exit the loop and 
; 371  : 			// return the EOF we have found.
; 372  : 			//
; 373  : 			break;

  000ba	eb 05		 jmp	 SHORT $LN3@nextToken
$LN5@nextToken:

; 374  : 		}
; 375  : 		
; 376  : 	}

  000bc	e9 6c ff ff ff	 jmp	 $LN2@nextToken
$LN3@nextToken:

; 377  : 
; 378  : 	// return whatever token we have, which may be EOF
; 379  : 	//
; 380  : 	return  tok;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]

; 381  : }

  000c6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
nextToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getText
_TEXT	SEGMENT
tv88 = 32
lexer$ = 64
getText	PROC						; COMDAT

; 879  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 880  : 	if (lexer->rec->state->text)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00033	74 16		 je	 SHORT $LN2@getText

; 881  : 	{
; 882  : 		return	lexer->rec->state->text;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0003a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00042	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00049	eb 5c		 jmp	 SHORT $LN1@getText
$LN2@getText:

; 883  : 
; 884  : 	}
; 885  : 	return  lexer->input->substr(

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00055	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00060	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00064	0f b6 89 d4 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+212]
  0006b	48 2b c1	 sub	 rax, rcx
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00073	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00077	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007b	48 8b 54 24 40	 mov	 rdx, QWORD PTR lexer$[rsp]
  00080	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00084	48 89 54 24 20	 mov	 QWORD PTR tv88[rsp], rdx
  00089	4c 8b c0	 mov	 r8, rax
  0008c	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00098	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR tv88[rsp]
  000a1	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN1@getText:

; 886  : 									lexer->input, 
; 887  : 									lexer->rec->state->tokenStartCharIndex,
; 888  : 									lexer->getCharIndex(lexer) - lexer->input->charByteSize
; 889  : 							);
; 890  : 
; 891  : }

  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
lexer$ = 16
getCharPositionInLine PROC				; COMDAT

; 868  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 869  :     return  lexer->input->charPositionInLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR lexer$[rsp]
  0000b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000f	8b 40 40	 mov	 eax, DWORD PTR [rax+64]

; 870  : }

  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCharIndex
_TEXT	SEGMENT
tv71 = 32
lexer$ = 64
getCharIndex PROC					; COMDAT

; 873  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 874  :     return lexer->input->istream->index(lexer->input->istream);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 89 4c 24 20	 mov	 QWORD PTR tv71[rsp], rcx
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00040	ff 50 40	 call	 QWORD PTR [rax+64]

; 875  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
getCharIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getLine
_TEXT	SEGMENT
lexer$ = 48
getLine	PROC						; COMDAT

; 862  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 863  :     return  lexer->input->getLine(lexer->input);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 864  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT recover
_TEXT	SEGMENT
tv70 = 32
lexer$ = 64
recover	PROC						; COMDAT

; 856  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 857  :     lexer->input->istream->consume(lexer->input->istream);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 89 4c 24 20	 mov	 QWORD PTR tv70[rsp], rcx
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR tv70[rsp]
  00040	ff 50 28	 call	 QWORD PTR [rax+40]

; 858  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
recover	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchAny
_TEXT	SEGMENT
tv70 = 32
lexer$ = 64
matchAny PROC						; COMDAT

; 850  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 851  :     lexer->input->istream->consume(lexer->input->istream);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 89 4c 24 20	 mov	 QWORD PTR tv70[rsp], rcx
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR tv70[rsp]
  00040	ff 50 28	 call	 QWORD PTR [rax+40]

; 852  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchRange
_TEXT	SEGMENT
c$ = 32
tv138 = 40
tv135 = 48
lexer$ = 80
low$ = 88
high$ = 96
matchRange PROC						; COMDAT

; 811  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 812  :     ANTLR3_UCHAR    c;
; 813  : 
; 814  :     /* What is in the stream at the moment?
; 815  :      */
; 816  :     c	= lexer->input->istream->_LA(lexer->input->istream, 1);

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0002c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00030	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00035	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 89 4c 24 28	 mov	 QWORD PTR tv138[rsp], rcx
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  0004e	ff 50 30	 call	 QWORD PTR [rax+48]
  00051	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax

; 817  :     if	( c >= low && c <= high)

  00055	8b 44 24 58	 mov	 eax, DWORD PTR low$[rsp]
  00059	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  0005d	72 44		 jb	 SHORT $LN2@matchRange
  0005f	8b 44 24 60	 mov	 eax, DWORD PTR high$[rsp]
  00063	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  00067	77 3a		 ja	 SHORT $LN2@matchRange

; 818  :     {
; 819  : 	/* Matched correctly, consume it
; 820  : 	 */
; 821  : 	lexer->input->istream->consume(lexer->input->istream);

  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0006e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00077	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007e	48 89 4c 24 30	 mov	 QWORD PTR tv135[rsp], rcx
  00083	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR tv135[rsp]
  0008b	ff 50 28	 call	 QWORD PTR [rax+40]

; 822  : 
; 823  : 	/* Reset any failed indicator
; 824  : 	 */
; 825  : 	lexer->rec->state->failed = ANTLR3_FALSE;

  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00093	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00097	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009b	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 826  : 
; 827  : 	return	ANTLR3_TRUE;

  0009f	b0 01		 mov	 al, 1
  000a1	eb 4f		 jmp	 SHORT $LN1@matchRange
$LN2@matchRange:

; 828  :     }
; 829  :     
; 830  :     /* Failed to match, execption and recovery time.
; 831  :      */
; 832  : 
; 833  :     if	(lexer->rec->state->backtracking > 0)

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000a8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ac	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b0	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000b4	7e 15		 jle	 SHORT $LN3@matchRange

; 834  :     {
; 835  : 	lexer->rec->state->failed  = ANTLR3_TRUE;

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000bb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000bf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c3	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 836  : 	return	ANTLR3_FALSE;

  000c7	32 c0		 xor	 al, al
  000c9	eb 27		 jmp	 SHORT $LN1@matchRange
$LN3@matchRange:

; 837  :     }
; 838  : 
; 839  :     lexer->rec->exConstruct(lexer->rec);

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000d0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000dd	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 840  : 
; 841  :     /* TODO: Implement exception creation more fully
; 842  :      */
; 843  :     lexer->recover(lexer);

  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000e8	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000ed	ff 50 70	 call	 QWORD PTR [rax+112]

; 844  : 
; 845  :     return  ANTLR3_FALSE;

  000f0	32 c0		 xor	 al, al
$LN1@matchRange:

; 846  : }

  000f2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
matchRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchc
_TEXT	SEGMENT
tv137 = 32
tv134 = 40
lexer$ = 64
c$ = 72
matchc	PROC						; COMDAT

; 771  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 772  : 	if	(lexer->input->istream->_LA(lexer->input->istream, 1) == c)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00030	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00034	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00037	48 89 4c 24 20	 mov	 QWORD PTR tv137[rsp], rcx
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR tv137[rsp]
  00049	ff 50 30	 call	 QWORD PTR [rax+48]
  0004c	3b 44 24 48	 cmp	 eax, DWORD PTR c$[rsp]
  00050	75 3a		 jne	 SHORT $LN2@matchc

; 773  : 	{
; 774  : 		/* Matched correctly, do consume it
; 775  : 		 */
; 776  : 		lexer->input->istream->consume(lexer->input->istream);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00057	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00060	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00064	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00067	48 89 4c 24 28	 mov	 QWORD PTR tv134[rsp], rcx
  0006c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR tv134[rsp]
  00074	ff 50 28	 call	 QWORD PTR [rax+40]

; 777  : 
; 778  : 		/* Reset any failed indicator
; 779  : 		 */
; 780  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0007c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 781  : 
; 782  : 		return	ANTLR3_TRUE;

  00088	b0 01		 mov	 al, 1
  0008a	eb 4f		 jmp	 SHORT $LN1@matchc
$LN2@matchc:

; 783  : 	}
; 784  : 
; 785  : 	/* Failed to match, exception and recovery time.
; 786  : 	 */
; 787  : 	if	(lexer->rec->state->backtracking > 0)

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00091	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00095	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00099	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0009d	7e 15		 jle	 SHORT $LN3@matchc

; 788  : 	{
; 789  : 		lexer->rec->state->failed  = ANTLR3_TRUE;

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ac	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 790  : 		return	ANTLR3_FALSE;

  000b0	32 c0		 xor	 al, al
  000b2	eb 27		 jmp	 SHORT $LN1@matchc
$LN3@matchc:

; 791  : 	}
; 792  : 
; 793  : 	lexer->rec->exConstruct(lexer->rec);

  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000b9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000c2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000c6	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 794  : 
; 795  : 	/* TODO: Implement exception creation more fully perhaps
; 796  : 	 */
; 797  : 	lexer->recover(lexer);

  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000d6	ff 50 70	 call	 QWORD PTR [rax+112]

; 798  : 
; 799  : 	return  ANTLR3_FALSE;

  000d9	32 c0		 xor	 al, al
$LN1@matchc:

; 800  : }

  000db	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
matchc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchs
_TEXT	SEGMENT
tv144 = 32
tv134 = 40
lexer$ = 64
string$ = 72
matchs	PROC						; COMDAT

; 728  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
$LN2@matchs:

; 729  : 	while   (*string != ANTLR3_STRING_TERMINATOR)

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  00028	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  0002b	0f 84 e1 00 00
	00		 je	 $LN3@matchs

; 730  : 	{
; 731  : 		if  (lexer->input->istream->_LA(lexer->input->istream, 1) != (*string))

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00036	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0003f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00043	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00046	48 89 4c 24 20	 mov	 QWORD PTR tv144[rsp], rcx
  0004b	ba 01 00 00 00	 mov	 edx, 1
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR tv144[rsp]
  00058	ff 50 30	 call	 QWORD PTR [rax+48]
  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR string$[rsp]
  00060	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00062	74 65		 je	 SHORT $LN4@matchs

; 732  : 		{
; 733  : 			if	(lexer->rec->state->backtracking > 0)

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00069	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00071	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00075	7e 18		 jle	 SHORT $LN5@matchs

; 734  : 			{
; 735  : 				lexer->rec->state->failed = ANTLR3_TRUE;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0007c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 736  : 				return ANTLR3_FALSE;

  00088	32 c0		 xor	 al, al
  0008a	e9 85 00 00 00	 jmp	 $LN1@matchs
$LN5@matchs:

; 737  : 			}
; 738  : 
; 739  : 			lexer->rec->exConstruct(lexer->rec);

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00094	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0009d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a1	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 740  : 			lexer->rec->state->failed	 = ANTLR3_TRUE;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ac	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b4	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 741  : 
; 742  : 			/* TODO: Implement exception creation more fully perhaps
; 743  : 			 */
; 744  : 			lexer->recover(lexer);

  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c2	ff 50 70	 call	 QWORD PTR [rax+112]

; 745  : 			return  ANTLR3_FALSE;

  000c5	32 c0		 xor	 al, al
  000c7	eb 4b		 jmp	 SHORT $LN1@matchs
$LN4@matchs:

; 746  : 		}
; 747  : 
; 748  : 		/* Matched correctly, do consume it
; 749  : 		 */
; 750  : 		lexer->input->istream->consume(lexer->input->istream);

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ce	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000db	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000de	48 89 4c 24 28	 mov	 QWORD PTR tv134[rsp], rcx
  000e3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e6	48 8b 44 24 28	 mov	 rax, QWORD PTR tv134[rsp]
  000eb	ff 50 28	 call	 QWORD PTR [rax+40]

; 751  : 		string++;

  000ee	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  000f3	48 83 c0 04	 add	 rax, 4
  000f7	48 89 44 24 48	 mov	 QWORD PTR string$[rsp], rax

; 752  : 
; 753  : 		/* Reset any failed indicator
; 754  : 		 */
; 755  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  000fc	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00101	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00105	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00109	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 756  : 	}

  0010d	e9 11 ff ff ff	 jmp	 $LN2@matchs
$LN3@matchs:

; 757  : 
; 758  : 
; 759  : 	return  ANTLR3_TRUE;

  00112	b0 01		 mov	 al, 1
$LN1@matchs:

; 760  : }

  00114	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00118	5f		 pop	 rdi
  00119	c3		 ret	 0
matchs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT emit
_TEXT	SEGMENT
token$ = 32
tv187 = 40
lexer$ = 64
emit	PROC						; COMDAT

; 643  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 644  :     pANTLR3_COMMON_TOKEN	token;
; 645  : 
; 646  :     /* We could check pointers to token factories and so on, but
; 647  :     * we are in code that we want to run as fast as possible
; 648  :     * so we are not checking any errors. So make sure you have installed an input stream before
; 649  :     * trying to emit a new token.
; 650  :     */
; 651  :     token   = lexer->rec->state->tokFactory->newToken(lexer->rec->state->tokFactory);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00030	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00034	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00038	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0003c	48 89 4c 24 28	 mov	 QWORD PTR tv187[rsp], rcx
  00041	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR tv187[rsp]
  0004a	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00050	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 652  : 
; 653  :     /* Install the supplied information, and some other bits we already know
; 654  :     * get added automatically, such as the input stream it is associated with
; 655  :     * (though it can all be overridden of course)
; 656  :     */
; 657  :     token->type		    = lexer->rec->state->type;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0005a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00067	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0006a	89 01		 mov	 DWORD PTR [rcx], eax

; 658  :     token->channel	    = lexer->rec->state->channel;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00071	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0007e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00081	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 659  :     token->start	    = lexer->rec->state->tokenStartCharIndex;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00089	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00096	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0009d	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 660  :     token->stop		    = lexer->getCharIndex(lexer) - 1;

  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ab	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  000b1	48 ff c8	 dec	 rax
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000b9	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 661  :     token->line		    = lexer->rec->state->tokenStartLine;

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ca	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000cf	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  000d2	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 662  :     token->charPosition	= lexer->rec->state->tokenStartCharPositionInLine;

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000da	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000de	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000e7	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  000ea	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 663  : 
; 664  :     if	(lexer->rec->state->text != NULL)

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000f2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fa	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00102	74 2b		 je	 SHORT $LN2@emit

; 665  :     {
; 666  :         token->textState	    = ANTLR3_TEXT_STRING;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00109	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 667  :         token->tokText.text	    = lexer->rec->state->text;

  00110	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00115	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00119	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00122	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00129	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 668  :     }

  0012d	eb 0c		 jmp	 SHORT $LN3@emit
$LN2@emit:

; 669  :     else
; 670  :     {
; 671  :         token->textState	= ANTLR3_TEXT_NONE;

  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00134	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0
$LN3@emit:

; 672  :     }
; 673  :     token->lineStart	= lexer->input->currentLine;

  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00149	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0014d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 674  :     token->user1	= lexer->rec->state->user1;

  00151	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00156	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0015a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0015e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00163	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00169	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 675  :     token->user2	= lexer->rec->state->user2;

  0016c	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00171	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00175	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00179	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0017e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00184	89 41 5c	 mov	 DWORD PTR [rcx+92], eax

; 676  :     token->user3	= lexer->rec->state->user3;

  00187	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0018c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00190	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00194	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00199	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  0019f	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 677  :     token->custom	= lexer->rec->state->custom;

  001a2	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  001a7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ab	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001b4	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 678  : 
; 679  :     lexer->rec->state->token	    = token;

  001bf	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  001c4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001d1	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 680  : 
; 681  :     return  token;

  001d5	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]

; 682  : }

  001da	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001de	5f		 pop	 rdi
  001df	c3		 ret	 0
emit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT emitNew
_TEXT	SEGMENT
lexer$ = 16
token$ = 24
emitNew	PROC						; COMDAT

; 637  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 638  :     lexer->rec->state->token    = token;	/* Voila!   */

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR lexer$[rsp]
  00010	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 8b 4c 24 18	 mov	 rcx, QWORD PTR token$[rsp]
  0001d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 639  : }

  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
emitNew	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT popCharStream
_TEXT	SEGMENT
input$ = 32
tv142 = 40
tv134 = 48
tv131 = 56
lexer$ = 80
popCharStream PROC					; COMDAT

; 611  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 612  :     pANTLR3_INPUT_STREAM input;
; 613  : 
; 614  :     // If we do not have a stream stack or we are already at the
; 615  :     // stack bottom, then do nothing.
; 616  :     //
; 617  :     if	(lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00033	0f 84 c6 00 00
	00		 je	 $LN2@popCharStr
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0003e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00042	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  0004b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00053	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  0005a	48 89 4c 24 28	 mov	 QWORD PTR tv142[rsp], rcx
  0005f	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR tv142[rsp]
  0006b	ff 50 30	 call	 QWORD PTR [rax+48]
  0006e	85 c0		 test	 eax, eax
  00070	0f 86 89 00 00
	00		 jbe	 $LN2@popCharStr

; 618  :     {
; 619  : 	// We just leave the current stream to its fate, we do not close
; 620  : 	// it or anything as we do not know what the programmer intended
; 621  : 	// for it. This method can always be overridden of course.
; 622  : 	// So just find out what was currently saved on the stack and use
; 623  : 	// that now, then pop it from the stack.
; 624  : 	//
; 625  : 	input	= (pANTLR3_INPUT_STREAM)(lexer->rec->state->streams->top);

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0007b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  0008a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008e	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 626  : 	lexer->rec->state->streams->pop(lexer->rec->state->streams);

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00098	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000a5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ad	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  000b4	48 89 4c 24 30	 mov	 QWORD PTR tv134[rsp], rcx
  000b9	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR tv134[rsp]
  000c5	ff 50 18	 call	 QWORD PTR [rax+24]

; 627  : 
; 628  : 	// Now install the stream as the current one.
; 629  : 	//
; 630  : 	lexer->setCharStream(lexer, input);

  000c8	48 8b 54 24 20	 mov	 rdx, QWORD PTR input$[rsp]
  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000d7	ff 50 20	 call	 QWORD PTR [rax+32]

; 631  : 	lexer->input->istream->rewindLast(lexer->input->istream);

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000df	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000e8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ef	48 89 4c 24 38	 mov	 QWORD PTR tv131[rsp], rcx
  000f4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR tv131[rsp]
  000fc	ff 50 50	 call	 QWORD PTR [rax+80]
$LN2@popCharStr:

; 632  :     }
; 633  :     return;
; 634  : }

  000ff	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00103	5f		 pop	 rdi
  00104	c3		 ret	 0
popCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT pushCharStream
_TEXT	SEGMENT
tv134 = 32
tv129 = 40
lexer$ = 64
input$ = 72
pushCharStream PROC					; COMDAT

; 565  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 566  : 	// Do we need a new input stream stack?
; 567  : 	//
; 568  : 	if	(lexer->rec->state->streams == NULL)

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00030	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00038	75 34		 jne	 SHORT $LN2@pushCharSt

; 569  : 	{
; 570  : 		// This is the first call to stack a new
; 571  : 		// stream and so we must create the stack first.
; 572  : 		//
; 573  : 		lexer->rec->state->streams = antlr3StackNew(0);

  0003a	33 c9		 xor	 ecx, ecx
  0003c	e8 00 00 00 00	 call	 antlr3StackNew
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00046	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004e	48 89 81 a8 00
	00 00		 mov	 QWORD PTR [rcx+168], rax

; 574  : 
; 575  : 		if  (lexer->rec->state->streams == NULL)

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0005a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  0006a	75 02		 jne	 SHORT $LN3@pushCharSt

; 576  : 		{
; 577  : 			// Could not do this, we just fail to push it.
; 578  : 			// TODO: Consider if this is what we want to do, but then
; 579  : 			//       any programmer can override this method to do something else.
; 580  : 			return;

  0006c	eb 78		 jmp	 SHORT $LN1@pushCharSt
$LN3@pushCharSt:
$LN2@pushCharSt:

; 581  : 		}
; 582  : 	}
; 583  : 
; 584  : 	// We have a stack, so we can save the current input stream
; 585  : 	// into it.
; 586  : 	//
; 587  : 	lexer->input->istream->mark(lexer->input->istream);

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00073	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0007c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00080	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00083	48 89 4c 24 20	 mov	 QWORD PTR tv134[rsp], rcx
  00088	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR tv134[rsp]
  00090	ff 50 38	 call	 QWORD PTR [rax+56]

; 588  : 	lexer->rec->state->streams->push(lexer->rec->state->streams, lexer->input, NULL);

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00098	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000a5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ad	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  000b4	48 89 4c 24 28	 mov	 QWORD PTR tv129[rsp], rcx
  000b9	45 33 c0	 xor	 r8d, r8d
  000bc	48 8b 54 24 40	 mov	 rdx, QWORD PTR lexer$[rsp]
  000c1	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000c5	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR tv129[rsp]
  000d1	ff 50 28	 call	 QWORD PTR [rax+40]

; 589  : 
; 590  : 	// And now we can install this new one
; 591  : 	//
; 592  : 	lexer->setCharStream(lexer, input);

  000d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000de	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000e3	ff 50 20	 call	 QWORD PTR [rax+32]
$LN1@pushCharSt:

; 593  : }

  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
pushCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT setCharStream
_TEXT	SEGMENT
tv173 = 32
lexer$ = 64
input$ = 72
setCharStream PROC					; COMDAT

; 493  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 494  :     /* Install the input interface
; 495  :      */
; 496  :     lexer->input	= input;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00028	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0002d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 497  : 
; 498  :     /* We may need a token factory for the lexer; we don't destroy any existing factory
; 499  :      * until the lexer is destroyed, as people may still be using the tokens it produced.
; 500  :      * TODO: Later I will provide a dup() method for a token so that it can extract itself
; 501  :      * out of the factory. 
; 502  :      */
; 503  :     if	(lexer->rec->state->tokFactory == NULL)

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00036	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00043	75 1d		 jne	 SHORT $LN2@setCharStr

; 504  :     {
; 505  : 	lexer->rec->state->tokFactory	= antlr3TokenFactoryNew(input);

  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0004a	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00054	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00058	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0005c	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 506  :     }

  00060	eb 37		 jmp	 SHORT $LN3@setCharStr
$LN2@setCharStr:

; 507  :     else
; 508  :     {
; 509  : 	/* When the input stream is being changed on the fly, rather than
; 510  : 	 * at the start of a new lexer, then we must tell the tokenFactory
; 511  : 	 * which input stream to adorn the tokens with so that when they
; 512  : 	 * are asked to provide their original input strings they can
; 513  : 	 * do so from the correct text stream.
; 514  : 	 */
; 515  : 	lexer->rec->state->tokFactory->setInputStream(lexer->rec->state->tokFactory, input);

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00067	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00074	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00078	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00080	48 89 4c 24 20	 mov	 QWORD PTR tv173[rsp], rcx
  00085	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  0008a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv173[rsp]
  00093	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
$LN3@setCharStr:

; 516  :     }
; 517  : 
; 518  :     /* Propagate the string factory so that we preserve the encoding form from
; 519  :      * the input stream.
; 520  :      */
; 521  :     if	(lexer->rec->state->tokSource->strFactory == NULL)

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0009e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000aa	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000af	75 54		 jne	 SHORT $LN4@setCharStr

; 522  :     {
; 523  :         lexer->rec->state->tokSource->strFactory	= input->strFactory;

  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000b6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000c7	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000cb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 524  : 
; 525  :         // Set the newly acquired string factory up for our pre-made tokens
; 526  :         // for EOF.
; 527  :         //
; 528  :         if (lexer->rec->state->tokSource->eofToken.strFactory == NULL)

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000d4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000dc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	75 1e		 jne	 SHORT $LN5@setCharStr

; 529  :         {
; 530  :             lexer->rec->state->tokSource->eofToken.strFactory = input->strFactory;

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000fd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00101	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN5@setCharStr:
$LN4@setCharStr:

; 531  :         }
; 532  :     }
; 533  : 
; 534  :     /* This is a lexer, install the appropriate exception creator
; 535  :      */
; 536  :     lexer->rec->exConstruct = antlr3RecognitionExceptionNew;

  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0010a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3RecognitionExceptionNew
  00115	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 537  : 
; 538  :     /* Set the current token to nothing
; 539  :      */
; 540  :     lexer->rec->state->token		= NULL;

  0011c	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00121	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00125	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00129	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 541  :     lexer->rec->state->text			= NULL;

  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00136	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0013a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013e	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 542  :     lexer->rec->state->tokenStartCharIndex	= -1;

  00149	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0014e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00152	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00156	48 c7 80 80 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+128], -1

; 543  : 
; 544  :     /* Copy the name of the char stream to the token source
; 545  :      */
; 546  :     lexer->rec->state->tokSource->fileName = input->fileName;

  00161	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00166	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0016a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0016e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00172	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00177	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0017b	48 89 88 28 02
	00 00		 mov	 QWORD PTR [rax+552], rcx

; 547  : }

  00182	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00186	5f		 pop	 rdi
  00187	c3		 ret	 0
setCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT mTokens
_TEXT	SEGMENT
lexer$ = 48
mTokens	PROC						; COMDAT

; 403  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 404  :     if	(lexer)	    // Fool compiler, avoid pragmas

  0001e	48 83 7c 24 30
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  00024	74 1a		 je	 SHORT $LN2@mTokens

; 405  :     {
; 406  : 		ANTLR3_FPRINTF(stderr, "lexer->mTokens(): Error: No lexer rules were added to the lexer yet!\n");

  00026	b9 02 00 00 00	 mov	 ecx, 2
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lexe@
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 fprintf
$LN2@mTokens:

; 407  :     }
; 408  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
mTokens	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT antlr3LexerNew
_TEXT	SEGMENT
lexer$ = 32
specialT$ = 40
sizeHint$ = 64
state$ = 72
antlr3LexerNew PROC					; COMDAT

; 73   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 74   :     pANTLR3_LEXER   lexer;
; 75   :     pANTLR3_COMMON_TOKEN	specialT;
; 76   : 
; 77   : 	/* Allocate memory
; 78   : 	*/
; 79   : 	lexer   = (pANTLR3_LEXER) ANTLR3_MALLOC(sizeof(ANTLR3_LEXER));

  00021	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0002c	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 80   : 
; 81   : 	if	(lexer == NULL)

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  00037	75 07		 jne	 SHORT $LN2@antlr3Lexe

; 82   : 	{
; 83   : 		return	NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 cb 03 00 00	 jmp	 $LN1@antlr3Lexe
$LN2@antlr3Lexe:

; 84   : 	}
; 85   : 
; 86   : 	/* Now we need to create the base recognizer
; 87   : 	*/
; 88   : 	lexer->rec	    =  antlr3BaseRecognizerNew(ANTLR3_TYPE_LEXER, sizeHint, state);

  00040	4c 8b 44 24 48	 mov	 r8, QWORD PTR state$[rsp]
  00045	8b 54 24 40	 mov	 edx, DWORD PTR sizeHint$[rsp]
  00049	b9 01 00 00 00	 mov	 ecx, 1
  0004e	e8 00 00 00 00	 call	 antlr3BaseRecognizerNew
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00058	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 89   : 
; 90   : 	if	(lexer->rec == NULL)

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00061	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00066	75 17		 jne	 SHORT $LN3@antlr3Lexe

; 91   : 	{
; 92   : 		lexer->free(lexer);

  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00072	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 93   : 		return	NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 8c 03 00 00	 jmp	 $LN1@antlr3Lexe
$LN3@antlr3Lexe:

; 94   : 	}
; 95   : 	lexer->rec->super  =  lexer;

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00084	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 96   : 
; 97   : 	lexer->rec->displayRecognitionError	    = displayRecognitionError;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00095	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:displayRecognitionError
  000a0	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 98   : 	lexer->rec->reportError					= reportError;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000a9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reportError
  000b4	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 99   : 	lexer->rec->reset						= reset;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000bd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  000c8	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 100  : 	lexer->rec->getCurrentInputSymbol		= getCurrentInputSymbol;

  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000d4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCurrentInputSymbol
  000df	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 101  : 	lexer->rec->getMissingSymbol			= getMissingSymbol;

  000e6	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000eb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getMissingSymbol
  000f6	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 102  : 
; 103  : 	/* Now install the token source interface
; 104  : 	*/
; 105  : 	if	(lexer->rec->state->tokSource == NULL) 

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00102	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00106	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010a	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010f	0f 85 ca 00 00
	00		 jne	 $LN4@antlr3Lexe

; 106  : 	{
; 107  : 		lexer->rec->state->tokSource	= (pANTLR3_TOKEN_SOURCE)ANTLR3_CALLOC(1, sizeof(ANTLR3_TOKEN_SOURCE));

  00115	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00125	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0012a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0012e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00132	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 108  : 
; 109  : 		if	(lexer->rec->state->tokSource == NULL) 

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0013b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0013f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00143	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00148	75 2f		 jne	 SHORT $LN5@antlr3Lexe

; 110  : 		{
; 111  : 			lexer->rec->free(lexer->rec);

  0014a	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0014f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00153	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00158	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0015c	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 112  : 			lexer->free(lexer);

  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0016c	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 113  : 
; 114  : 			return	NULL;

  00172	33 c0		 xor	 eax, eax
  00174	e9 92 02 00 00	 jmp	 $LN1@antlr3Lexe
$LN5@antlr3Lexe:

; 115  : 		}
; 116  : 		lexer->rec->state->tokSource->super    =  lexer;

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0017e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00182	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00186	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0018f	48 89 88 20 02
	00 00		 mov	 QWORD PTR [rax+544], rcx

; 117  : 
; 118  : 		/* Install the default nextToken() method, which may be overridden
; 119  : 		 * by generated code, or by anything else in fact.
; 120  : 		 */
; 121  : 		lexer->rec->state->tokSource->nextToken	    =  nextToken;

  00196	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0019b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0019f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001a3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextToken
  001ae	48 89 08	 mov	 QWORD PTR [rax], rcx

; 122  : 		lexer->rec->state->tokSource->strFactory    = NULL;

  001b1	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001b6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001c2	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 123  : 
; 124  : 		lexer->rec->state->tokFactory				= NULL;

  001ca	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001cf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001d3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001d7	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN4@antlr3Lexe:

; 125  : 	}
; 126  : 
; 127  :     /* Install the lexer API
; 128  :      */
; 129  :     lexer->setCharStream			=  setCharStream;

  001df	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharStream
  001eb	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 130  :     lexer->mTokens					= (void (*)(void *))(mTokens);

  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mTokens
  001fb	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 131  :     lexer->setCharStream			=  setCharStream;

  001ff	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharStream
  0020b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 132  :     lexer->pushCharStream			=  pushCharStream;

  0020f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pushCharStream
  0021b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 133  :     lexer->popCharStream			=  popCharStream;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:popCharStream
  0022b	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 134  :     lexer->emit						=  emit;

  0022f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:emit
  0023b	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 135  :     lexer->emitNew					=  emitNew;

  0023f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:emitNew
  0024b	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 136  :     lexer->matchs					=  matchs;

  0024f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchs
  0025b	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 137  :     lexer->matchc					=  matchc;

  0025f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchc
  0026b	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 138  :     lexer->matchRange				=  matchRange;

  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00274	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchRange
  0027b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 139  :     lexer->matchAny					=  matchAny;

  0027f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchAny
  0028b	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 140  :     lexer->recover					=  recover;

  0028f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recover
  0029b	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 141  :     lexer->getLine					=  getLine;

  0029f	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  002ab	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 142  :     lexer->getCharIndex				=  getCharIndex;

  002af	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharIndex
  002bb	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 143  :     lexer->getCharPositionInLine    =  getCharPositionInLine;

  002c2	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  002ce	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 144  :     lexer->getText					=  getText;

  002d5	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  002e1	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 145  :     lexer->free						=  freeLexer;

  002e8	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeLexer
  002f4	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 146  :     
; 147  :     /* Initialise the eof token
; 148  :      */
; 149  :     specialT					= &(lexer->rec->state->tokSource->eofToken);

  002fb	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00300	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00304	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00308	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0030c	48 83 c0 10	 add	 rax, 16
  00310	48 89 44 24 28	 mov	 QWORD PTR specialT$[rsp], rax

; 150  :     antlr3SetTokenAPI	  (specialT);

  00315	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  0031a	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 151  :     specialT->setType	  (specialT, ANTLR3_TOKEN_EOF);

  0031f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00324	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  00329	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0032e	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 152  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  00334	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00339	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 153  :     specialT->strFactory        = NULL;

  0033d	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00342	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 154  : 	specialT->textState			= ANTLR3_TEXT_NONE;

  0034a	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0034f	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 155  : 	specialT->custom			= NULL;

  00356	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0035b	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 156  : 	specialT->user1				= 0;

  00363	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00368	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 157  : 	specialT->user2				= 0;

  0036f	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00374	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 158  : 	specialT->user3				= 0;

  0037b	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00380	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 159  : 
; 160  : 	// Initialize the skip token.
; 161  : 	//
; 162  :     specialT					= &(lexer->rec->state->tokSource->skipToken);

  00387	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0038c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00390	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00394	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00398	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  0039e	48 89 44 24 28	 mov	 QWORD PTR specialT$[rsp], rax

; 163  :     antlr3SetTokenAPI	  (specialT);

  003a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  003a8	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 164  :     specialT->setType	  (specialT, ANTLR3_TOKEN_INVALID);

  003ad	33 d2		 xor	 edx, edx
  003af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  003b4	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003b9	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 165  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  003bf	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003c4	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 166  :     specialT->strFactory        = NULL;

  003c8	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003cd	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 167  : 	specialT->custom			= NULL;

  003d5	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003da	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 168  : 	specialT->user1				= 0;

  003e2	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003e7	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 169  : 	specialT->user2				= 0;

  003ee	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003f3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 170  : 	specialT->user3				= 0;

  003fa	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003ff	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 171  :     return  lexer;

  00406	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
$LN1@antlr3Lexe:

; 172  : }

  0040b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0040f	5f		 pop	 rdi
  00410	c3		 ret	 0
antlr3LexerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\oss\third_party\antlr\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT antlr3LexerNewStream
_TEXT	SEGMENT
lexer$ = 32
sizeHint$ = 64
input$ = 72
state$ = 80
antlr3LexerNewStream PROC				; COMDAT

; 385  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]

; 386  :     pANTLR3_LEXER   lexer;
; 387  : 
; 388  :     // Create a basic lexer first
; 389  :     //
; 390  :     lexer   = antlr3LexerNew(sizeHint, state);

  00026	48 8b 54 24 50	 mov	 rdx, QWORD PTR state$[rsp]
  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  0002f	e8 00 00 00 00	 call	 antlr3LexerNew
  00034	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 391  : 
; 392  :     if	(lexer != NULL) 

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  0003f	74 0f		 je	 SHORT $LN2@antlr3Lexe

; 393  :     {
; 394  : 		// Install the input stream and reset the lexer
; 395  : 		//
; 396  : 		setCharStream(lexer, input);

  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0004b	e8 00 00 00 00	 call	 setCharStream
$LN2@antlr3Lexe:

; 397  :     }
; 398  : 
; 399  :     return  lexer;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]

; 400  : }

  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
antlr3LexerNewStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 831  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 14 00 00 00	 mov	 ecx, 20
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0002d	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00032	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00037	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00049	e8 00 00 00 00	 call	 _vfprintf_l
  0004e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 836  :     __crt_va_end(_ArgList);

  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 837  :     return _Result;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 838  : }

  0005f	8b f8		 mov	 edi, eax
  00061	48 8b cc	 mov	 rcx, rsp
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00070	8b c7		 mov	 eax, edi
  00072	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
